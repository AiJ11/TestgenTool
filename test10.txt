
╔════════════════════════════════════════╗
║  TESTGEN - RESTAURANT TEST SUITE      ║
║  Total Tests: 25                       ║
╚════════════════════════════════════════╝


=== DEPTH TESTS ===

========================================
TEST: Test 10: Browse → Leave Review (No Auth) (Depth=2)
MODE: Full Pipeline (With Backend)
DEPTH: 19 API calls
========================================

[RestaurantFunctionFactory] Initialized with baseUrl: http://localhost:5002
[RewriteGlobalsVisitor] Detected 10 globals: Assignments C M O Owners R Rev Roles T U 
[RewriteGlobalsVisitor] Generated 0 statements in rewritten program

=== TEST-API ATC (After Rewrite) ===
=== Program ===
Statement 0: _ := reset()
Statement 1: ownerEmail0 := input()
Statement 2: ownerPassword0 := input()
Statement 3: ownerFullName0 := input()
Statement 4: ownerMobile0 := input()
Statement 5: tmp_Roles_0 := get_Roles()
Statement 6: Roles_old := tmp_Roles_0
Statement 7: tmp_U_0 := get_U()
Statement 8: U_old := tmp_U_0
Statement 9: tmp_U_1 := get_U()
Statement 10: assume(not_in(ownerEmail, dom(tmp_U_1)))
Statement 11: _result0 := registerOwner(ownerEmail, ownerPassword, ownerFullName, ownerMobile)
Statement 12: tmp_U_2 := get_U()
Statement 13: tmp_Roles_1 := get_Roles()
Statement 14: assert(AND(=([](tmp_U_2, ownerEmail), ownerPassword), =([](tmp_Roles_1, ownerEmail), OWNER)))
Statement 15: ownerEmail1 := input()
Statement 16: ownerPassword1 := input()
Statement 17: tmp_T_0 := get_T()
Statement 18: T_old := tmp_T_0
Statement 19: tmp_U_3 := get_U()
Statement 20: tmp_U_4 := get_U()
Statement 21: assume(AND(in(ownerEmail, dom(tmp_U_3)), =([](tmp_U_4, ownerEmail), ownerPassword)))
Statement 22: _result1 := login(ownerEmail, ownerPassword)
Statement 23: tmp_T_1 := get_T()
Statement 24: assert(=([](tmp_T_1, ownerEmail), _result1))
Statement 25: ownerEmail2 := input()
Statement 26: restaurantName2 := input()
Statement 27: restaurantAddress2 := input()
Statement 28: restaurantContact2 := input()
Statement 29: tmp_Owners_0 := get_Owners()
Statement 30: Owners_old := tmp_Owners_0
Statement 31: tmp_R_0 := get_R()
Statement 32: R_old := tmp_R_0
Statement 33: tmp_T_2 := get_T()
Statement 34: tmp_Roles_2 := get_Roles()
Statement 35: assume(AND(in(ownerEmail, dom(tmp_T_2)), =([](tmp_Roles_2, ownerEmail), OWNER)))
Statement 36: _result2 := createRestaurant(ownerEmail, restaurantName, restaurantAddress, restaurantContact)
Statement 37: tmp_R_1 := get_R()
Statement 38: tmp_Owners_1 := get_Owners()
Statement 39: assert(AND(in(_result2, dom(tmp_R_1)), =([](tmp_Owners_1, _result2), ownerEmail)))
Statement 40: ownerEmail3 := input()
Statement 41: restaurantId3 := input()
Statement 42: itemName3 := input()
Statement 43: itemPrice3 := input()
Statement 44: tmp_M_0 := get_M()
Statement 45: M_old := tmp_M_0
Statement 46: tmp_T_3 := get_T()
Statement 47: tmp_Roles_3 := get_Roles()
Statement 48: tmp_R_2 := get_R()
Statement 49: assume(AND(in(ownerEmail, dom(tmp_T_3)), =([](tmp_Roles_3, ownerEmail), OWNER), in(restaurantId, dom(tmp_R_2))))
Statement 50: _result3 := addMenuItem(ownerEmail, restaurantId, itemName, itemPrice)
Statement 51: tmp_M_1 := get_M()
Statement 52: assert(in(_result3, dom(tmp_M_1)))
Statement 53: customerEmail4 := input()
Statement 54: customerPassword4 := input()
Statement 55: customerFullName4 := input()
Statement 56: customerMobile4 := input()
Statement 57: tmp_Roles_4 := get_Roles()
Statement 58: Roles_old := tmp_Roles_4
Statement 59: tmp_U_5 := get_U()
Statement 60: U_old := tmp_U_5
Statement 61: tmp_U_6 := get_U()
Statement 62: assume(not_in(customerEmail, dom(tmp_U_6)))
Statement 63: _result4 := registerCustomer(customerEmail, customerPassword, customerFullName, customerMobile)
Statement 64: tmp_U_7 := get_U()
Statement 65: tmp_Roles_5 := get_Roles()
Statement 66: assert(AND(=([](tmp_U_7, customerEmail), customerPassword), =([](tmp_Roles_5, customerEmail), CUSTOMER)))
Statement 67: customerEmail5 := input()
Statement 68: customerPassword5 := input()
Statement 69: tmp_T_4 := get_T()
Statement 70: T_old := tmp_T_4
Statement 71: tmp_U_8 := get_U()
Statement 72: tmp_U_9 := get_U()
Statement 73: assume(AND(in(customerEmail, dom(tmp_U_8)), =([](tmp_U_9, customerEmail), customerPassword)))
Statement 74: _result5 := login(customerEmail, customerPassword)
Statement 75: tmp_T_5 := get_T()
Statement 76: assert(=([](tmp_T_5, customerEmail), _result5))
Statement 77: customerEmail6 := input()
Statement 78: tmp_T_6 := get_T()
Statement 79: assume(in(customerEmail, dom(tmp_T_6)))
Statement 80: _result6 := browseRestaurants(customerEmail)
Statement 81: assert()
Statement 82: customerEmail7 := input()
Statement 83: restaurantId7 := input()
Statement 84: tmp_T_7 := get_T()
Statement 85: tmp_R_3 := get_R()
Statement 86: assume(AND(in(customerEmail, dom(tmp_T_7)), in(restaurantId, dom(tmp_R_3))))
Statement 87: _result7 := viewMenu(customerEmail, restaurantId)
Statement 88: assert()
Statement 89: customerEmail8 := input()
Statement 90: menuItemId8 := input()
Statement 91: quantity8 := input()
Statement 92: tmp_C_0 := get_C()
Statement 93: C_old := tmp_C_0
Statement 94: tmp_T_8 := get_T()
Statement 95: tmp_M_2 := get_M()
Statement 96: assume(AND(in(customerEmail, dom(tmp_T_8)), in(menuItemId, dom(tmp_M_2))))
Statement 97: _result8 := addToCart(customerEmail, menuItemId, quantity)
Statement 98: tmp_C_1 := get_C()
Statement 99: assert(in(customerEmail, dom(tmp_C_1)))
Statement 100: customerEmail9 := input()
Statement 101: deliveryAddress9 := input()
Statement 102: paymentMethod9 := input()
Statement 103: tmp_C_2 := get_C()
Statement 104: C_old := tmp_C_2
Statement 105: tmp_O_0 := get_O()
Statement 106: O_old := tmp_O_0
Statement 107: tmp_T_9 := get_T()
Statement 108: tmp_C_3 := get_C()
Statement 109: assume(AND(in(customerEmail, dom(tmp_T_9)), in(customerEmail, dom(tmp_C_3))))
Statement 110: _result9 := placeOrder(customerEmail, deliveryAddress, paymentMethod)
Statement 111: tmp_O_1 := get_O()
Statement 112: tmp_C_4 := get_C()
Statement 113: assert(AND(in(_result9, dom(tmp_O_1)), not_in(customerEmail, dom(tmp_C_4))))
Statement 114: agentEmail10 := input()
Statement 115: agentPassword10 := input()
Statement 116: agentFullName10 := input()
Statement 117: agentMobile10 := input()
Statement 118: tmp_Roles_6 := get_Roles()
Statement 119: Roles_old := tmp_Roles_6
Statement 120: tmp_U_10 := get_U()
Statement 121: U_old := tmp_U_10
Statement 122: tmp_U_11 := get_U()
Statement 123: assume(not_in(agentEmail, dom(tmp_U_11)))
Statement 124: _result10 := registerAgent(agentEmail, agentPassword, agentFullName, agentMobile)
Statement 125: tmp_U_12 := get_U()
Statement 126: tmp_Roles_7 := get_Roles()
Statement 127: assert(AND(=([](tmp_U_12, agentEmail), agentPassword), =([](tmp_Roles_7, agentEmail), AGENT)))
Statement 128: agentEmail11 := input()
Statement 129: agentPassword11 := input()
Statement 130: tmp_T_10 := get_T()
Statement 131: T_old := tmp_T_10
Statement 132: tmp_U_13 := get_U()
Statement 133: tmp_U_14 := get_U()
Statement 134: assume(AND(in(agentEmail, dom(tmp_U_13)), =([](tmp_U_14, agentEmail), agentPassword)))
Statement 135: _result11 := login(agentEmail, agentPassword)
Statement 136: tmp_T_11 := get_T()
Statement 137: assert(=([](tmp_T_11, agentEmail), _result11))
Statement 138: ownerEmail12 := input()
Statement 139: orderId12 := input()
Statement 140: orderStatus12 := input()
Statement 141: tmp_T_12 := get_T()
Statement 142: tmp_Roles_8 := get_Roles()
Statement 143: tmp_O_2 := get_O()
Statement 144: assume(AND(in(ownerEmail, dom(tmp_T_12)), =([](tmp_Roles_8, ownerEmail), OWNER), in(orderId, dom(tmp_O_2))))
Statement 145: _result12 := updateOrderStatusOwner(ownerEmail, orderId, orderStatus)
Statement 146: assert()
Statement 147: ownerEmail13 := input()
Statement 148: orderId13 := input()
Statement 149: orderStatus13 := input()
Statement 150: tmp_T_13 := get_T()
Statement 151: tmp_Roles_9 := get_Roles()
Statement 152: tmp_O_3 := get_O()
Statement 153: assume(AND(in(ownerEmail, dom(tmp_T_13)), =([](tmp_Roles_9, ownerEmail), OWNER), in(orderId, dom(tmp_O_3))))
Statement 154: _result13 := updateOrderStatusOwner(ownerEmail, orderId, orderStatus)
Statement 155: assert()
Statement 156: ownerEmail14 := input()
Statement 157: orderId14 := input()
Statement 158: orderStatus14 := input()
Statement 159: tmp_T_14 := get_T()
Statement 160: tmp_Roles_10 := get_Roles()
Statement 161: tmp_O_4 := get_O()
Statement 162: assume(AND(in(ownerEmail, dom(tmp_T_14)), =([](tmp_Roles_10, ownerEmail), OWNER), in(orderId, dom(tmp_O_4))))
Statement 163: _result14 := updateOrderStatusOwner(ownerEmail, orderId, orderStatus)
Statement 164: assert()
Statement 165: ownerEmail15 := input()
Statement 166: orderId15 := input()
Statement 167: agentEmail15 := input()
Statement 168: tmp_Assignments_0 := get_Assignments()
Statement 169: Assignments_old := tmp_Assignments_0
Statement 170: tmp_T_15 := get_T()
Statement 171: tmp_Roles_11 := get_Roles()
Statement 172: tmp_O_5 := get_O()
Statement 173: tmp_U_15 := get_U()
Statement 174: tmp_Roles_12 := get_Roles()
Statement 175: assume(AND(in(ownerEmail, dom(tmp_T_15)), =([](tmp_Roles_11, ownerEmail), OWNER), in(orderId, dom(tmp_O_5)), in(agentEmail, dom(tmp_U_15)), =([](tmp_Roles_12, agentEmail), AGENT)))
Statement 176: _result15 := assignOrder(ownerEmail, orderId, agentEmail)
Statement 177: tmp_Assignments_1 := get_Assignments()
Statement 178: assert(=([](tmp_Assignments_1, orderId), agentEmail))
Statement 179: agentEmail16 := input()
Statement 180: orderId16 := input()
Statement 181: orderStatus16 := input()
Statement 182: tmp_T_16 := get_T()
Statement 183: tmp_Roles_13 := get_Roles()
Statement 184: tmp_Assignments_2 := get_Assignments()
Statement 185: tmp_Assignments_3 := get_Assignments()
Statement 186: assume(AND(in(agentEmail, dom(tmp_T_16)), =([](tmp_Roles_13, agentEmail), AGENT), in(orderId, dom(tmp_Assignments_2)), =([](tmp_Assignments_3, orderId), agentEmail)))
Statement 187: _result16 := updateOrderStatusAgent(agentEmail, orderId, orderStatus)
Statement 188: assert()
Statement 189: agentEmail17 := input()
Statement 190: orderId17 := input()
Statement 191: orderStatus17 := input()
Statement 192: tmp_T_17 := get_T()
Statement 193: tmp_Roles_14 := get_Roles()
Statement 194: tmp_Assignments_4 := get_Assignments()
Statement 195: tmp_Assignments_5 := get_Assignments()
Statement 196: assume(AND(in(agentEmail, dom(tmp_T_17)), =([](tmp_Roles_14, agentEmail), AGENT), in(orderId, dom(tmp_Assignments_4)), =([](tmp_Assignments_5, orderId), agentEmail)))
Statement 197: _result17 := updateOrderStatusAgent(agentEmail, orderId, orderStatus)
Statement 198: assert()
Statement 199: customerEmail18 := input()
Statement 200: orderId18 := input()
Statement 201: restaurantRating18 := input()
Statement 202: deliveryRating18 := input()
Statement 203: reviewComment18 := input()
Statement 204: tmp_Rev_0 := get_Rev()
Statement 205: Rev_old := tmp_Rev_0
Statement 206: tmp_T_18 := get_T()
Statement 207: tmp_O_6 := get_O()
Statement 208: assume(AND(in(customerEmail, dom(tmp_T_18)), in(orderId, dom(tmp_O_6))))
Statement 209: _result18 := leaveReview(customerEmail, orderId, restaurantRating, deliveryRating, reviewComment)
Statement 210: tmp_Rev_1 := get_Rev()
Statement 211: assert(in(_result18, dom(tmp_Rev_1)))
=== End Program ===

========================================
>>> generateCTC: Starting iteration
========================================
>>> generateCTC: Program needs processing
>>> generateCTC: Concrete values provided: 0
>>> generateCTC: Is abstract: 1
>>> generateCTC: Has placeholders: 0

>>> generateCTC: STEP 1 - Rewriting ATC with concrete values

>>> generateCTC: STEP 2 - Running symbolic execution
[SEE] API call 'reset' ready for actual execution

[ASSIGN] Evaluating: _ := reset()
[API_CALL] Executing API function: reset
  [API_CALL] Getting function from factory...
[Factory] Creating function: reset
  [API_CALL] Executing function...
[ResetFunc] Clearing all collections...
[HttpClient] POST /api/test/reset -> 200
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _
[ASSIGN] Result: _ := 200

[ASSIGN] Evaluating: ownerEmail0 := input()
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X0
[ASSIGN] Result: ownerEmail0 := X0

[ASSIGN] Evaluating: ownerPassword0 := input()
[SEE] Mapping base name 'ownerPassword' -> 'ownerPassword0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X1
[ASSIGN] Result: ownerPassword0 := X1

[ASSIGN] Evaluating: ownerFullName0 := input()
[SEE] Mapping base name 'ownerFullName' -> 'ownerFullName0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X2
[ASSIGN] Result: ownerFullName0 := X2

[ASSIGN] Evaluating: ownerMobile0 := input()
[SEE] Mapping base name 'ownerMobile' -> 'ownerMobile0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X3
[ASSIGN] Result: ownerMobile0 := X3
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_0 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_0'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_0
[ASSIGN] Result: tmp_Roles_0 := {}

[ASSIGN] Evaluating: Roles_old := tmp_Roles_0
  [EVAL] Var lookup: tmp_Roles_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Roles_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_0 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_0'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_0
[ASSIGN] Result: tmp_U_0 := {}

[ASSIGN] Evaluating: U_old := tmp_U_0
  [EVAL] Var lookup: tmp_U_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: U_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_1 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_1'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_1
[ASSIGN] Result: tmp_U_1 := {}

[ASSUME] Evaluating: not_in(ownerEmail, dom(tmp_U_1))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail0'
    [EVAL] Found in sigma: X0
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
[ASSUME] Adding constraint: true
[SEE] API call 'registerOwner' with symbolic arguments - interruption point
[SEE] Interruption at statement 11

[ASSIGN] Evaluating: _result0 := registerOwner(ownerEmail, ownerPassword, ownerFullName, ownerMobile)
[SEE] Mapping base name '_result' -> '_result0'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail0'
    [EVAL] Found in sigma: X0
  [EVAL] Var lookup: ownerPassword
    [EVAL] Resolved base name 'ownerPassword' -> 'ownerPassword0'
    [EVAL] Found in sigma: X1
  [EVAL] Var lookup: ownerFullName
    [EVAL] Resolved base name 'ownerFullName' -> 'ownerFullName0'
    [EVAL] Found in sigma: X2
  [EVAL] Var lookup: ownerMobile
    [EVAL] Resolved base name 'ownerMobile' -> 'ownerMobile0'
    [EVAL] Found in sigma: X3
[API_CALL] registerOwner has symbolic arguments - skipping actual execution
  [API_ARG 0] X0 (symbolic: 1)
  [API_ARG 1] X1 (symbolic: 1)
  [API_ARG 2] X2 (symbolic: 1)
  [API_ARG 3] X3 (symbolic: 1)
[ASSIGN] Result: _result0 := -1 (symbolic placeholder)
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_2 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_2'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_2
[ASSIGN] Result: tmp_U_2 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_1 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_1'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_1
[ASSIGN] Result: tmp_Roles_1 := {}
[SEE] Interruption at statement 14

[ASSERT] Evaluating: AND(=([](tmp_U_2, ownerEmail), ownerPassword), =([](tmp_Roles_1, ownerEmail), OWNER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: =([](tmp_U_2, ownerEmail), ownerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_2
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail0'
    [EVAL] Found in sigma: X0
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X0
    [EVAL] Key not found in map
  [EVAL] Var lookup: ownerPassword
    [EVAL] Resolved base name 'ownerPassword' -> 'ownerPassword0'
    [EVAL] Found in sigma: X1
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[0] result: (= []({}, X0) X1)
    [EVAL] Arg[1]: =([](tmp_Roles_1, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail0'
    [EVAL] Found in sigma: X0
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X0
    [EVAL] Key not found in map
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X0) OWNER)
    [EVAL] FuncCall result: AND((= []({}, X0) X1), (= []({}, X0) OWNER))
[ASSERT] Result: AND((= []({}, X0) X1), (= []({}, X0) OWNER))
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: ownerEmail1 := input()
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail1'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X4
[ASSIGN] Result: ownerEmail1 := X4

[ASSIGN] Evaluating: ownerPassword1 := input()
[SEE] Mapping base name 'ownerPassword' -> 'ownerPassword1'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X5
[ASSIGN] Result: ownerPassword1 := X5
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_0 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_0'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_0
[ASSIGN] Result: tmp_T_0 := {}

[ASSIGN] Evaluating: T_old := tmp_T_0
  [EVAL] Var lookup: tmp_T_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: T_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_3 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_3'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_3
[ASSIGN] Result: tmp_U_3 := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_4 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_4'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_4
[ASSIGN] Result: tmp_U_4 := {}
[SEE] Interruption at statement 21

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_U_3)), =([](tmp_U_4, ownerEmail), ownerPassword))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_U_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail1'
    [EVAL] Found in sigma: X4
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X4
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_U_4, ownerEmail), ownerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_4
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail1'
    [EVAL] Found in sigma: X4
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X4
    [EVAL] Key not found in map
  [EVAL] Var lookup: ownerPassword
    [EVAL] Resolved base name 'ownerPassword' -> 'ownerPassword1'
    [EVAL] Found in sigma: X5
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X4) X5)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'login' with symbolic arguments - interruption point
[SEE] Interruption at statement 22

[ASSIGN] Evaluating: _result1 := login(ownerEmail, ownerPassword)
[SEE] Mapping base name '_result' -> '_result1'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail1'
    [EVAL] Found in sigma: X4
  [EVAL] Var lookup: ownerPassword
    [EVAL] Resolved base name 'ownerPassword' -> 'ownerPassword1'
    [EVAL] Found in sigma: X5
[API_CALL] login has symbolic arguments - skipping actual execution
  [API_ARG 0] X4 (symbolic: 1)
  [API_ARG 1] X5 (symbolic: 1)
[ASSIGN] Result: _result1 := -1 (symbolic placeholder)
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_1 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_1'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_1
[ASSIGN] Result: tmp_T_1 := {}

[ASSERT] Evaluating: =([](tmp_T_1, ownerEmail), _result1)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_T_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail1'
    [EVAL] Found in sigma: X4
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X4
    [EVAL] Key not found in map
  [EVAL] Var lookup: _result1
    [EVAL] Found in sigma: -1
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
[ASSERT] Result: (= []({}, X4) -1)
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: ownerEmail2 := input()
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X6
[ASSIGN] Result: ownerEmail2 := X6

[ASSIGN] Evaluating: restaurantName2 := input()
[SEE] Mapping base name 'restaurantName' -> 'restaurantName2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X7
[ASSIGN] Result: restaurantName2 := X7

[ASSIGN] Evaluating: restaurantAddress2 := input()
[SEE] Mapping base name 'restaurantAddress' -> 'restaurantAddress2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X8
[ASSIGN] Result: restaurantAddress2 := X8

[ASSIGN] Evaluating: restaurantContact2 := input()
[SEE] Mapping base name 'restaurantContact' -> 'restaurantContact2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X9
[ASSIGN] Result: restaurantContact2 := X9
[SEE] API call 'get_Owners' ready for actual execution

[ASSIGN] Evaluating: tmp_Owners_0 := get_Owners()
[SEE] Mapping base name 'tmp_Owners_' -> 'tmp_Owners_0'
[API_CALL] Executing API function: get_Owners
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Owners
  [API_CALL] Executing function...
[GetOwnersFunc] Fetching Owners...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Owners_0
[ASSIGN] Result: tmp_Owners_0 := {}

[ASSIGN] Evaluating: Owners_old := tmp_Owners_0
  [EVAL] Var lookup: tmp_Owners_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Owners_old := {}
[SEE] API call 'get_R' ready for actual execution

[ASSIGN] Evaluating: tmp_R_0 := get_R()
[SEE] Mapping base name 'tmp_R_' -> 'tmp_R_0'
[API_CALL] Executing API function: get_R
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_R
  [API_CALL] Executing function...
[GetRFunc] Fetching R...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_R_0
[ASSIGN] Result: tmp_R_0 := {}

[ASSIGN] Evaluating: R_old := tmp_R_0
  [EVAL] Var lookup: tmp_R_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: R_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_2 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_2'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_2
[ASSIGN] Result: tmp_T_2 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_2 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_2'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_2
[ASSIGN] Result: tmp_Roles_2 := {}
[SEE] Interruption at statement 35

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_2)), =([](tmp_Roles_2, ownerEmail), OWNER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail2'
    [EVAL] Found in sigma: X6
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_2
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X6
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_2, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_2
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail2'
    [EVAL] Found in sigma: X6
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X6
    [EVAL] Key not found in map
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X6) OWNER)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'createRestaurant' with symbolic arguments - interruption point
[SEE] Interruption at statement 36

[ASSIGN] Evaluating: _result2 := createRestaurant(ownerEmail, restaurantName, restaurantAddress, restaurantContact)
[SEE] Mapping base name '_result' -> '_result2'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail2'
    [EVAL] Found in sigma: X6
  [EVAL] Var lookup: restaurantName
    [EVAL] Resolved base name 'restaurantName' -> 'restaurantName2'
    [EVAL] Found in sigma: X7
  [EVAL] Var lookup: restaurantAddress
    [EVAL] Resolved base name 'restaurantAddress' -> 'restaurantAddress2'
    [EVAL] Found in sigma: X8
  [EVAL] Var lookup: restaurantContact
    [EVAL] Resolved base name 'restaurantContact' -> 'restaurantContact2'
    [EVAL] Found in sigma: X9
[API_CALL] createRestaurant has symbolic arguments - skipping actual execution
  [API_ARG 0] X6 (symbolic: 1)
  [API_ARG 1] X7 (symbolic: 1)
  [API_ARG 2] X8 (symbolic: 1)
  [API_ARG 3] X9 (symbolic: 1)
[ASSIGN] Result: _result2 := -1 (symbolic placeholder)
[SEE] API call 'get_R' ready for actual execution

[ASSIGN] Evaluating: tmp_R_1 := get_R()
[SEE] Mapping base name 'tmp_R_' -> 'tmp_R_1'
[API_CALL] Executing API function: get_R
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_R
  [API_CALL] Executing function...
[GetRFunc] Fetching R...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_R_1
[ASSIGN] Result: tmp_R_1 := {}
[SEE] API call 'get_Owners' ready for actual execution

[ASSIGN] Evaluating: tmp_Owners_1 := get_Owners()
[SEE] Mapping base name 'tmp_Owners_' -> 'tmp_Owners_1'
[API_CALL] Executing API function: get_Owners
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Owners
  [API_CALL] Executing function...
[GetOwnersFunc] Fetching Owners...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Owners_1
[ASSIGN] Result: tmp_Owners_1 := {}
[SEE] Interruption at statement 39

[ASSERT] Evaluating: AND(in(_result2, dom(tmp_R_1)), =([](tmp_Owners_1, _result2), ownerEmail))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(_result2, dom(tmp_R_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result2
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_R_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Owners_1, _result2), ownerEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Owners_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: _result2
    [EVAL] Found in sigma: -1
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: -1
    [EVAL] Key not found in map
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail2'
    [EVAL] Found in sigma: X6
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, -1) X6)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: ownerEmail3 := input()
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X10
[ASSIGN] Result: ownerEmail3 := X10

[ASSIGN] Evaluating: restaurantId3 := input()
[SEE] Mapping base name 'restaurantId' -> 'restaurantId3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X11
[ASSIGN] Result: restaurantId3 := X11

[ASSIGN] Evaluating: itemName3 := input()
[SEE] Mapping base name 'itemName' -> 'itemName3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X12
[ASSIGN] Result: itemName3 := X12

[ASSIGN] Evaluating: itemPrice3 := input()
[SEE] Mapping base name 'itemPrice' -> 'itemPrice3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X13
[ASSIGN] Result: itemPrice3 := X13
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_0 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_0'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_M_0
[ASSIGN] Result: tmp_M_0 := {}

[ASSIGN] Evaluating: M_old := tmp_M_0
  [EVAL] Var lookup: tmp_M_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: M_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_3 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_3'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_3
[ASSIGN] Result: tmp_T_3 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_3 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_3'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_3
[ASSIGN] Result: tmp_Roles_3 := {}
[SEE] API call 'get_R' ready for actual execution

[ASSIGN] Evaluating: tmp_R_2 := get_R()
[SEE] Mapping base name 'tmp_R_' -> 'tmp_R_2'
[API_CALL] Executing API function: get_R
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_R
  [API_CALL] Executing function...
[GetRFunc] Fetching R...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_R_2
[ASSIGN] Result: tmp_R_2 := {}
[SEE] Interruption at statement 49

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_3)), =([](tmp_Roles_3, ownerEmail), OWNER), in(restaurantId, dom(tmp_R_2)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail3'
    [EVAL] Found in sigma: X10
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X10
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_3, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_3
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail3'
    [EVAL] Found in sigma: X10
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X10
    [EVAL] Key not found in map
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X10) OWNER)
    [EVAL] Arg[2]: in(restaurantId, dom(tmp_R_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId3'
    [EVAL] Found in sigma: X11
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_R_2
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X11
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'addMenuItem' with symbolic arguments - interruption point
[SEE] Interruption at statement 50

[ASSIGN] Evaluating: _result3 := addMenuItem(ownerEmail, restaurantId, itemName, itemPrice)
[SEE] Mapping base name '_result' -> '_result3'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail3'
    [EVAL] Found in sigma: X10
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId3'
    [EVAL] Found in sigma: X11
  [EVAL] Var lookup: itemName
    [EVAL] Resolved base name 'itemName' -> 'itemName3'
    [EVAL] Found in sigma: X12
  [EVAL] Var lookup: itemPrice
    [EVAL] Resolved base name 'itemPrice' -> 'itemPrice3'
    [EVAL] Found in sigma: X13
[API_CALL] addMenuItem has symbolic arguments - skipping actual execution
  [API_ARG 0] X10 (symbolic: 1)
  [API_ARG 1] X11 (symbolic: 1)
  [API_ARG 2] X12 (symbolic: 1)
  [API_ARG 3] X13 (symbolic: 1)
[ASSIGN] Result: _result3 := -1 (symbolic placeholder)
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_1 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_1'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_M_1
[ASSIGN] Result: tmp_M_1 := {}

[ASSERT] Evaluating: in(_result3, dom(tmp_M_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result3
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_M_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: customerEmail4 := input()
[SEE] Mapping base name 'customerEmail' -> 'customerEmail4'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X14
[ASSIGN] Result: customerEmail4 := X14

[ASSIGN] Evaluating: customerPassword4 := input()
[SEE] Mapping base name 'customerPassword' -> 'customerPassword4'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X15
[ASSIGN] Result: customerPassword4 := X15

[ASSIGN] Evaluating: customerFullName4 := input()
[SEE] Mapping base name 'customerFullName' -> 'customerFullName4'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X16
[ASSIGN] Result: customerFullName4 := X16

[ASSIGN] Evaluating: customerMobile4 := input()
[SEE] Mapping base name 'customerMobile' -> 'customerMobile4'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X17
[ASSIGN] Result: customerMobile4 := X17
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_4 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_4'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_4
[ASSIGN] Result: tmp_Roles_4 := {}

[ASSIGN] Evaluating: Roles_old := tmp_Roles_4
  [EVAL] Var lookup: tmp_Roles_4
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Roles_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_5 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_5'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_5
[ASSIGN] Result: tmp_U_5 := {}

[ASSIGN] Evaluating: U_old := tmp_U_5
  [EVAL] Var lookup: tmp_U_5
    [EVAL] Found in sigma: {}
[ASSIGN] Result: U_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_6 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_6'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_6
[ASSIGN] Result: tmp_U_6 := {}

[ASSUME] Evaluating: not_in(customerEmail, dom(tmp_U_6))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail4'
    [EVAL] Found in sigma: X14
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_6
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
[ASSUME] Adding constraint: true
[SEE] API call 'registerCustomer' with symbolic arguments - interruption point
[SEE] Interruption at statement 63

[ASSIGN] Evaluating: _result4 := registerCustomer(customerEmail, customerPassword, customerFullName, customerMobile)
[SEE] Mapping base name '_result' -> '_result4'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail4'
    [EVAL] Found in sigma: X14
  [EVAL] Var lookup: customerPassword
    [EVAL] Resolved base name 'customerPassword' -> 'customerPassword4'
    [EVAL] Found in sigma: X15
  [EVAL] Var lookup: customerFullName
    [EVAL] Resolved base name 'customerFullName' -> 'customerFullName4'
    [EVAL] Found in sigma: X16
  [EVAL] Var lookup: customerMobile
    [EVAL] Resolved base name 'customerMobile' -> 'customerMobile4'
    [EVAL] Found in sigma: X17
[API_CALL] registerCustomer has symbolic arguments - skipping actual execution
  [API_ARG 0] X14 (symbolic: 1)
  [API_ARG 1] X15 (symbolic: 1)
  [API_ARG 2] X16 (symbolic: 1)
  [API_ARG 3] X17 (symbolic: 1)
[ASSIGN] Result: _result4 := -1 (symbolic placeholder)
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_7 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_7'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_7
[ASSIGN] Result: tmp_U_7 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_5 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_5'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_5
[ASSIGN] Result: tmp_Roles_5 := {}
[SEE] Interruption at statement 66

[ASSERT] Evaluating: AND(=([](tmp_U_7, customerEmail), customerPassword), =([](tmp_Roles_5, customerEmail), CUSTOMER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: =([](tmp_U_7, customerEmail), customerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_7
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail4'
    [EVAL] Found in sigma: X14
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X14
    [EVAL] Key not found in map
  [EVAL] Var lookup: customerPassword
    [EVAL] Resolved base name 'customerPassword' -> 'customerPassword4'
    [EVAL] Found in sigma: X15
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[0] result: (= []({}, X14) X15)
    [EVAL] Arg[1]: =([](tmp_Roles_5, customerEmail), CUSTOMER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_5
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail4'
    [EVAL] Found in sigma: X14
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X14
    [EVAL] Key not found in map
  [EVAL] Var lookup: CUSTOMER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X14) CUSTOMER)
    [EVAL] FuncCall result: AND((= []({}, X14) X15), (= []({}, X14) CUSTOMER))
[ASSERT] Result: AND((= []({}, X14) X15), (= []({}, X14) CUSTOMER))
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: customerEmail5 := input()
[SEE] Mapping base name 'customerEmail' -> 'customerEmail5'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X18
[ASSIGN] Result: customerEmail5 := X18

[ASSIGN] Evaluating: customerPassword5 := input()
[SEE] Mapping base name 'customerPassword' -> 'customerPassword5'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X19
[ASSIGN] Result: customerPassword5 := X19
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_4 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_4'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_4
[ASSIGN] Result: tmp_T_4 := {}

[ASSIGN] Evaluating: T_old := tmp_T_4
  [EVAL] Var lookup: tmp_T_4
    [EVAL] Found in sigma: {}
[ASSIGN] Result: T_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_8 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_8'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_8
[ASSIGN] Result: tmp_U_8 := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_9 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_9'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_9
[ASSIGN] Result: tmp_U_9 := {}
[SEE] Interruption at statement 73

[ASSUME] Evaluating: AND(in(customerEmail, dom(tmp_U_8)), =([](tmp_U_9, customerEmail), customerPassword))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(customerEmail, dom(tmp_U_8))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail5'
    [EVAL] Found in sigma: X18
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_8
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X18
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_U_9, customerEmail), customerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_9
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail5'
    [EVAL] Found in sigma: X18
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X18
    [EVAL] Key not found in map
  [EVAL] Var lookup: customerPassword
    [EVAL] Resolved base name 'customerPassword' -> 'customerPassword5'
    [EVAL] Found in sigma: X19
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X18) X19)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'login' with symbolic arguments - interruption point
[SEE] Interruption at statement 74

[ASSIGN] Evaluating: _result5 := login(customerEmail, customerPassword)
[SEE] Mapping base name '_result' -> '_result5'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail5'
    [EVAL] Found in sigma: X18
  [EVAL] Var lookup: customerPassword
    [EVAL] Resolved base name 'customerPassword' -> 'customerPassword5'
    [EVAL] Found in sigma: X19
[API_CALL] login has symbolic arguments - skipping actual execution
  [API_ARG 0] X18 (symbolic: 1)
  [API_ARG 1] X19 (symbolic: 1)
[ASSIGN] Result: _result5 := -1 (symbolic placeholder)
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_5 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_5'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_5
[ASSIGN] Result: tmp_T_5 := {}

[ASSERT] Evaluating: =([](tmp_T_5, customerEmail), _result5)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_T_5
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail5'
    [EVAL] Found in sigma: X18
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X18
    [EVAL] Key not found in map
  [EVAL] Var lookup: _result5
    [EVAL] Found in sigma: -1
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
[ASSERT] Result: (= []({}, X18) -1)
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: customerEmail6 := input()
[SEE] Mapping base name 'customerEmail' -> 'customerEmail6'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X20
[ASSIGN] Result: customerEmail6 := X20
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_6 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_6'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_6
[ASSIGN] Result: tmp_T_6 := {}

[ASSUME] Evaluating: in(customerEmail, dom(tmp_T_6))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail6'
    [EVAL] Found in sigma: X20
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_6
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X20
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSUME] Adding constraint: false
[SEE] API call 'browseRestaurants' with symbolic arguments - interruption point
[SEE] Interruption at statement 80

[ASSIGN] Evaluating: _result6 := browseRestaurants(customerEmail)
[SEE] Mapping base name '_result' -> '_result6'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail6'
    [EVAL] Found in sigma: X20
[API_CALL] browseRestaurants has symbolic arguments - skipping actual execution
  [API_ARG 0] X20 (symbolic: 1)
[ASSIGN] Result: _result6 := -1 (symbolic placeholder)

[ASSERT] Empty assertion, PASSED

[ASSIGN] Evaluating: customerEmail7 := input()
[SEE] Mapping base name 'customerEmail' -> 'customerEmail7'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X21
[ASSIGN] Result: customerEmail7 := X21

[ASSIGN] Evaluating: restaurantId7 := input()
[SEE] Mapping base name 'restaurantId' -> 'restaurantId7'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X22
[ASSIGN] Result: restaurantId7 := X22
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_7 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_7'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_7
[ASSIGN] Result: tmp_T_7 := {}
[SEE] API call 'get_R' ready for actual execution

[ASSIGN] Evaluating: tmp_R_3 := get_R()
[SEE] Mapping base name 'tmp_R_' -> 'tmp_R_3'
[API_CALL] Executing API function: get_R
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_R
  [API_CALL] Executing function...
[GetRFunc] Fetching R...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_R_3
[ASSIGN] Result: tmp_R_3 := {}
[SEE] Interruption at statement 86

[ASSUME] Evaluating: AND(in(customerEmail, dom(tmp_T_7)), in(restaurantId, dom(tmp_R_3)))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(customerEmail, dom(tmp_T_7))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail7'
    [EVAL] Found in sigma: X21
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_7
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X21
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: in(restaurantId, dom(tmp_R_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId7'
    [EVAL] Found in sigma: X22
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_R_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X22
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[1] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'viewMenu' with symbolic arguments - interruption point
[SEE] Interruption at statement 87

[ASSIGN] Evaluating: _result7 := viewMenu(customerEmail, restaurantId)
[SEE] Mapping base name '_result' -> '_result7'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail7'
    [EVAL] Found in sigma: X21
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId7'
    [EVAL] Found in sigma: X22
[API_CALL] viewMenu has symbolic arguments - skipping actual execution
  [API_ARG 0] X21 (symbolic: 1)
  [API_ARG 1] X22 (symbolic: 1)
[ASSIGN] Result: _result7 := -1 (symbolic placeholder)

[ASSERT] Empty assertion, PASSED

[ASSIGN] Evaluating: customerEmail8 := input()
[SEE] Mapping base name 'customerEmail' -> 'customerEmail8'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X23
[ASSIGN] Result: customerEmail8 := X23

[ASSIGN] Evaluating: menuItemId8 := input()
[SEE] Mapping base name 'menuItemId' -> 'menuItemId8'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X24
[ASSIGN] Result: menuItemId8 := X24

[ASSIGN] Evaluating: quantity8 := input()
[SEE] Mapping base name 'quantity' -> 'quantity8'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X25
[ASSIGN] Result: quantity8 := X25
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_0 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_0'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_0
[ASSIGN] Result: tmp_C_0 := {}

[ASSIGN] Evaluating: C_old := tmp_C_0
  [EVAL] Var lookup: tmp_C_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: C_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_8 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_8'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_8
[ASSIGN] Result: tmp_T_8 := {}
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_2 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_2'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_M_2
[ASSIGN] Result: tmp_M_2 := {}
[SEE] Interruption at statement 96

[ASSUME] Evaluating: AND(in(customerEmail, dom(tmp_T_8)), in(menuItemId, dom(tmp_M_2)))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(customerEmail, dom(tmp_T_8))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail8'
    [EVAL] Found in sigma: X23
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_8
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X23
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: in(menuItemId, dom(tmp_M_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: menuItemId
    [EVAL] Resolved base name 'menuItemId' -> 'menuItemId8'
    [EVAL] Found in sigma: X24
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_M_2
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X24
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[1] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'addToCart' with symbolic arguments - interruption point
[SEE] Interruption at statement 97

[ASSIGN] Evaluating: _result8 := addToCart(customerEmail, menuItemId, quantity)
[SEE] Mapping base name '_result' -> '_result8'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail8'
    [EVAL] Found in sigma: X23
  [EVAL] Var lookup: menuItemId
    [EVAL] Resolved base name 'menuItemId' -> 'menuItemId8'
    [EVAL] Found in sigma: X24
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity8'
    [EVAL] Found in sigma: X25
[API_CALL] addToCart has symbolic arguments - skipping actual execution
  [API_ARG 0] X23 (symbolic: 1)
  [API_ARG 1] X24 (symbolic: 1)
  [API_ARG 2] X25 (symbolic: 1)
[ASSIGN] Result: _result8 := -1 (symbolic placeholder)
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_1 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_1'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_1
[ASSIGN] Result: tmp_C_1 := {}

[ASSERT] Evaluating: in(customerEmail, dom(tmp_C_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail8'
    [EVAL] Found in sigma: X23
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X23
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: customerEmail9 := input()
[SEE] Mapping base name 'customerEmail' -> 'customerEmail9'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X26
[ASSIGN] Result: customerEmail9 := X26

[ASSIGN] Evaluating: deliveryAddress9 := input()
[SEE] Mapping base name 'deliveryAddress' -> 'deliveryAddress9'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X27
[ASSIGN] Result: deliveryAddress9 := X27

[ASSIGN] Evaluating: paymentMethod9 := input()
[SEE] Mapping base name 'paymentMethod' -> 'paymentMethod9'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X28
[ASSIGN] Result: paymentMethod9 := X28
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_2 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_2'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_2
[ASSIGN] Result: tmp_C_2 := {}

[ASSIGN] Evaluating: C_old := tmp_C_2
  [EVAL] Var lookup: tmp_C_2
    [EVAL] Found in sigma: {}
[ASSIGN] Result: C_old := {}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_0 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_0'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_0
[ASSIGN] Result: tmp_O_0 := {}

[ASSIGN] Evaluating: O_old := tmp_O_0
  [EVAL] Var lookup: tmp_O_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: O_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_9 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_9'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_9
[ASSIGN] Result: tmp_T_9 := {}
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_3 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_3'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_3
[ASSIGN] Result: tmp_C_3 := {}
[SEE] Interruption at statement 109

[ASSUME] Evaluating: AND(in(customerEmail, dom(tmp_T_9)), in(customerEmail, dom(tmp_C_3)))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(customerEmail, dom(tmp_T_9))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail9'
    [EVAL] Found in sigma: X26
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_9
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X26
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: in(customerEmail, dom(tmp_C_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail9'
    [EVAL] Found in sigma: X26
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X26
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[1] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'placeOrder' with symbolic arguments - interruption point
[SEE] Interruption at statement 110

[ASSIGN] Evaluating: _result9 := placeOrder(customerEmail, deliveryAddress, paymentMethod)
[SEE] Mapping base name '_result' -> '_result9'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail9'
    [EVAL] Found in sigma: X26
  [EVAL] Var lookup: deliveryAddress
    [EVAL] Resolved base name 'deliveryAddress' -> 'deliveryAddress9'
    [EVAL] Found in sigma: X27
  [EVAL] Var lookup: paymentMethod
    [EVAL] Resolved base name 'paymentMethod' -> 'paymentMethod9'
    [EVAL] Found in sigma: X28
[API_CALL] placeOrder has symbolic arguments - skipping actual execution
  [API_ARG 0] X26 (symbolic: 1)
  [API_ARG 1] X27 (symbolic: 1)
  [API_ARG 2] X28 (symbolic: 1)
[ASSIGN] Result: _result9 := -1 (symbolic placeholder)
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_1 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_1'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_1
[ASSIGN] Result: tmp_O_1 := {}
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_4 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_4'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_4
[ASSIGN] Result: tmp_C_4 := {}
[SEE] Interruption at statement 113

[ASSERT] Evaluating: AND(in(_result9, dom(tmp_O_1)), not_in(customerEmail, dom(tmp_C_4)))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(_result9, dom(tmp_O_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result9
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: not_in(customerEmail, dom(tmp_C_4))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail9'
    [EVAL] Found in sigma: X26
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_4
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
    [EVAL] Arg[1] result: true
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: agentEmail10 := input()
[SEE] Mapping base name 'agentEmail' -> 'agentEmail10'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X29
[ASSIGN] Result: agentEmail10 := X29

[ASSIGN] Evaluating: agentPassword10 := input()
[SEE] Mapping base name 'agentPassword' -> 'agentPassword10'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X30
[ASSIGN] Result: agentPassword10 := X30

[ASSIGN] Evaluating: agentFullName10 := input()
[SEE] Mapping base name 'agentFullName' -> 'agentFullName10'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X31
[ASSIGN] Result: agentFullName10 := X31

[ASSIGN] Evaluating: agentMobile10 := input()
[SEE] Mapping base name 'agentMobile' -> 'agentMobile10'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X32
[ASSIGN] Result: agentMobile10 := X32
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_6 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_6'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_6
[ASSIGN] Result: tmp_Roles_6 := {}

[ASSIGN] Evaluating: Roles_old := tmp_Roles_6
  [EVAL] Var lookup: tmp_Roles_6
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Roles_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_10 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_10'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_10
[ASSIGN] Result: tmp_U_10 := {}

[ASSIGN] Evaluating: U_old := tmp_U_10
  [EVAL] Var lookup: tmp_U_10
    [EVAL] Found in sigma: {}
[ASSIGN] Result: U_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_11 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_11'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_11
[ASSIGN] Result: tmp_U_11 := {}

[ASSUME] Evaluating: not_in(agentEmail, dom(tmp_U_11))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail10'
    [EVAL] Found in sigma: X29
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_11
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
[ASSUME] Adding constraint: true
[SEE] API call 'registerAgent' with symbolic arguments - interruption point
[SEE] Interruption at statement 124

[ASSIGN] Evaluating: _result10 := registerAgent(agentEmail, agentPassword, agentFullName, agentMobile)
[SEE] Mapping base name '_result' -> '_result10'
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail10'
    [EVAL] Found in sigma: X29
  [EVAL] Var lookup: agentPassword
    [EVAL] Resolved base name 'agentPassword' -> 'agentPassword10'
    [EVAL] Found in sigma: X30
  [EVAL] Var lookup: agentFullName
    [EVAL] Resolved base name 'agentFullName' -> 'agentFullName10'
    [EVAL] Found in sigma: X31
  [EVAL] Var lookup: agentMobile
    [EVAL] Resolved base name 'agentMobile' -> 'agentMobile10'
    [EVAL] Found in sigma: X32
[API_CALL] registerAgent has symbolic arguments - skipping actual execution
  [API_ARG 0] X29 (symbolic: 1)
  [API_ARG 1] X30 (symbolic: 1)
  [API_ARG 2] X31 (symbolic: 1)
  [API_ARG 3] X32 (symbolic: 1)
[ASSIGN] Result: _result10 := -1 (symbolic placeholder)
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_12 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_12'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_12
[ASSIGN] Result: tmp_U_12 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_7 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_7'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_7
[ASSIGN] Result: tmp_Roles_7 := {}
[SEE] Interruption at statement 127

[ASSERT] Evaluating: AND(=([](tmp_U_12, agentEmail), agentPassword), =([](tmp_Roles_7, agentEmail), AGENT))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: =([](tmp_U_12, agentEmail), agentPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_12
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail10'
    [EVAL] Found in sigma: X29
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X29
    [EVAL] Key not found in map
  [EVAL] Var lookup: agentPassword
    [EVAL] Resolved base name 'agentPassword' -> 'agentPassword10'
    [EVAL] Found in sigma: X30
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[0] result: (= []({}, X29) X30)
    [EVAL] Arg[1]: =([](tmp_Roles_7, agentEmail), AGENT)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_7
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail10'
    [EVAL] Found in sigma: X29
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X29
    [EVAL] Key not found in map
  [EVAL] Var lookup: AGENT
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X29) AGENT)
    [EVAL] FuncCall result: AND((= []({}, X29) X30), (= []({}, X29) AGENT))
[ASSERT] Result: AND((= []({}, X29) X30), (= []({}, X29) AGENT))
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: agentEmail11 := input()
[SEE] Mapping base name 'agentEmail' -> 'agentEmail11'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X33
[ASSIGN] Result: agentEmail11 := X33

[ASSIGN] Evaluating: agentPassword11 := input()
[SEE] Mapping base name 'agentPassword' -> 'agentPassword11'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X34
[ASSIGN] Result: agentPassword11 := X34
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_10 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_10'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_10
[ASSIGN] Result: tmp_T_10 := {}

[ASSIGN] Evaluating: T_old := tmp_T_10
  [EVAL] Var lookup: tmp_T_10
    [EVAL] Found in sigma: {}
[ASSIGN] Result: T_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_13 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_13'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_13
[ASSIGN] Result: tmp_U_13 := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_14 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_14'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_14
[ASSIGN] Result: tmp_U_14 := {}
[SEE] Interruption at statement 134

[ASSUME] Evaluating: AND(in(agentEmail, dom(tmp_U_13)), =([](tmp_U_14, agentEmail), agentPassword))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(agentEmail, dom(tmp_U_13))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail11'
    [EVAL] Found in sigma: X33
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_13
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X33
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_U_14, agentEmail), agentPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_14
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail11'
    [EVAL] Found in sigma: X33
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X33
    [EVAL] Key not found in map
  [EVAL] Var lookup: agentPassword
    [EVAL] Resolved base name 'agentPassword' -> 'agentPassword11'
    [EVAL] Found in sigma: X34
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X33) X34)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'login' with symbolic arguments - interruption point
[SEE] Interruption at statement 135

[ASSIGN] Evaluating: _result11 := login(agentEmail, agentPassword)
[SEE] Mapping base name '_result' -> '_result11'
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail11'
    [EVAL] Found in sigma: X33
  [EVAL] Var lookup: agentPassword
    [EVAL] Resolved base name 'agentPassword' -> 'agentPassword11'
    [EVAL] Found in sigma: X34
[API_CALL] login has symbolic arguments - skipping actual execution
  [API_ARG 0] X33 (symbolic: 1)
  [API_ARG 1] X34 (symbolic: 1)
[ASSIGN] Result: _result11 := -1 (symbolic placeholder)
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_11 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_11'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_11
[ASSIGN] Result: tmp_T_11 := {}

[ASSERT] Evaluating: =([](tmp_T_11, agentEmail), _result11)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_T_11
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail11'
    [EVAL] Found in sigma: X33
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X33
    [EVAL] Key not found in map
  [EVAL] Var lookup: _result11
    [EVAL] Found in sigma: -1
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
[ASSERT] Result: (= []({}, X33) -1)
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: ownerEmail12 := input()
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail12'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X35
[ASSIGN] Result: ownerEmail12 := X35

[ASSIGN] Evaluating: orderId12 := input()
[SEE] Mapping base name 'orderId' -> 'orderId12'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X36
[ASSIGN] Result: orderId12 := X36

[ASSIGN] Evaluating: orderStatus12 := input()
[SEE] Mapping base name 'orderStatus' -> 'orderStatus12'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X37
[ASSIGN] Result: orderStatus12 := X37
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_12 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_12'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_12
[ASSIGN] Result: tmp_T_12 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_8 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_8'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_8
[ASSIGN] Result: tmp_Roles_8 := {}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_2 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_2'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_2
[ASSIGN] Result: tmp_O_2 := {}
[SEE] Interruption at statement 144

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_12)), =([](tmp_Roles_8, ownerEmail), OWNER), in(orderId, dom(tmp_O_2)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_12))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail12'
    [EVAL] Found in sigma: X35
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_12
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X35
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_8, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_8
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail12'
    [EVAL] Found in sigma: X35
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X35
    [EVAL] Key not found in map
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X35) OWNER)
    [EVAL] Arg[2]: in(orderId, dom(tmp_O_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId12'
    [EVAL] Found in sigma: X36
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_2
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X36
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'updateOrderStatusOwner' with symbolic arguments - interruption point
[SEE] Interruption at statement 145

[ASSIGN] Evaluating: _result12 := updateOrderStatusOwner(ownerEmail, orderId, orderStatus)
[SEE] Mapping base name '_result' -> '_result12'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail12'
    [EVAL] Found in sigma: X35
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId12'
    [EVAL] Found in sigma: X36
  [EVAL] Var lookup: orderStatus
    [EVAL] Resolved base name 'orderStatus' -> 'orderStatus12'
    [EVAL] Found in sigma: X37
[API_CALL] updateOrderStatusOwner has symbolic arguments - skipping actual execution
  [API_ARG 0] X35 (symbolic: 1)
  [API_ARG 1] X36 (symbolic: 1)
  [API_ARG 2] X37 (symbolic: 1)
[ASSIGN] Result: _result12 := -1 (symbolic placeholder)

[ASSERT] Empty assertion, PASSED

[ASSIGN] Evaluating: ownerEmail13 := input()
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail13'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X38
[ASSIGN] Result: ownerEmail13 := X38

[ASSIGN] Evaluating: orderId13 := input()
[SEE] Mapping base name 'orderId' -> 'orderId13'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X39
[ASSIGN] Result: orderId13 := X39

[ASSIGN] Evaluating: orderStatus13 := input()
[SEE] Mapping base name 'orderStatus' -> 'orderStatus13'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X40
[ASSIGN] Result: orderStatus13 := X40
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_13 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_13'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_13
[ASSIGN] Result: tmp_T_13 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_9 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_9'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_9
[ASSIGN] Result: tmp_Roles_9 := {}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_3 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_3'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_3
[ASSIGN] Result: tmp_O_3 := {}
[SEE] Interruption at statement 153

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_13)), =([](tmp_Roles_9, ownerEmail), OWNER), in(orderId, dom(tmp_O_3)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_13))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail13'
    [EVAL] Found in sigma: X38
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_13
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X38
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_9, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_9
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail13'
    [EVAL] Found in sigma: X38
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X38
    [EVAL] Key not found in map
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X38) OWNER)
    [EVAL] Arg[2]: in(orderId, dom(tmp_O_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId13'
    [EVAL] Found in sigma: X39
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X39
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'updateOrderStatusOwner' with symbolic arguments - interruption point
[SEE] Interruption at statement 154

[ASSIGN] Evaluating: _result13 := updateOrderStatusOwner(ownerEmail, orderId, orderStatus)
[SEE] Mapping base name '_result' -> '_result13'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail13'
    [EVAL] Found in sigma: X38
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId13'
    [EVAL] Found in sigma: X39
  [EVAL] Var lookup: orderStatus
    [EVAL] Resolved base name 'orderStatus' -> 'orderStatus13'
    [EVAL] Found in sigma: X40
[API_CALL] updateOrderStatusOwner has symbolic arguments - skipping actual execution
  [API_ARG 0] X38 (symbolic: 1)
  [API_ARG 1] X39 (symbolic: 1)
  [API_ARG 2] X40 (symbolic: 1)
[ASSIGN] Result: _result13 := -1 (symbolic placeholder)

[ASSERT] Empty assertion, PASSED

[ASSIGN] Evaluating: ownerEmail14 := input()
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail14'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X41
[ASSIGN] Result: ownerEmail14 := X41

[ASSIGN] Evaluating: orderId14 := input()
[SEE] Mapping base name 'orderId' -> 'orderId14'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X42
[ASSIGN] Result: orderId14 := X42

[ASSIGN] Evaluating: orderStatus14 := input()
[SEE] Mapping base name 'orderStatus' -> 'orderStatus14'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X43
[ASSIGN] Result: orderStatus14 := X43
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_14 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_14'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_14
[ASSIGN] Result: tmp_T_14 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_10 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_10'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_10
[ASSIGN] Result: tmp_Roles_10 := {}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_4 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_4'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_4
[ASSIGN] Result: tmp_O_4 := {}
[SEE] Interruption at statement 162

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_14)), =([](tmp_Roles_10, ownerEmail), OWNER), in(orderId, dom(tmp_O_4)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_14))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail14'
    [EVAL] Found in sigma: X41
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_14
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X41
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_10, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_10
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail14'
    [EVAL] Found in sigma: X41
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X41
    [EVAL] Key not found in map
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X41) OWNER)
    [EVAL] Arg[2]: in(orderId, dom(tmp_O_4))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId14'
    [EVAL] Found in sigma: X42
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_4
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X42
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'updateOrderStatusOwner' with symbolic arguments - interruption point
[SEE] Interruption at statement 163

[ASSIGN] Evaluating: _result14 := updateOrderStatusOwner(ownerEmail, orderId, orderStatus)
[SEE] Mapping base name '_result' -> '_result14'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail14'
    [EVAL] Found in sigma: X41
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId14'
    [EVAL] Found in sigma: X42
  [EVAL] Var lookup: orderStatus
    [EVAL] Resolved base name 'orderStatus' -> 'orderStatus14'
    [EVAL] Found in sigma: X43
[API_CALL] updateOrderStatusOwner has symbolic arguments - skipping actual execution
  [API_ARG 0] X41 (symbolic: 1)
  [API_ARG 1] X42 (symbolic: 1)
  [API_ARG 2] X43 (symbolic: 1)
[ASSIGN] Result: _result14 := -1 (symbolic placeholder)

[ASSERT] Empty assertion, PASSED

[ASSIGN] Evaluating: ownerEmail15 := input()
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail15'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X44
[ASSIGN] Result: ownerEmail15 := X44

[ASSIGN] Evaluating: orderId15 := input()
[SEE] Mapping base name 'orderId' -> 'orderId15'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X45
[ASSIGN] Result: orderId15 := X45

[ASSIGN] Evaluating: agentEmail15 := input()
[SEE] Mapping base name 'agentEmail' -> 'agentEmail15'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X46
[ASSIGN] Result: agentEmail15 := X46
[SEE] API call 'get_Assignments' ready for actual execution

[ASSIGN] Evaluating: tmp_Assignments_0 := get_Assignments()
[SEE] Mapping base name 'tmp_Assignments_' -> 'tmp_Assignments_0'
[API_CALL] Executing API function: get_Assignments
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Assignments
  [API_CALL] Executing function...
[GetAssignmentsFunc] Fetching Assignments...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Assignments_0
[ASSIGN] Result: tmp_Assignments_0 := {}

[ASSIGN] Evaluating: Assignments_old := tmp_Assignments_0
  [EVAL] Var lookup: tmp_Assignments_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Assignments_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_15 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_15'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_15
[ASSIGN] Result: tmp_T_15 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_11 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_11'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_11
[ASSIGN] Result: tmp_Roles_11 := {}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_5 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_5'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_5
[ASSIGN] Result: tmp_O_5 := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_15 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_15'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_15
[ASSIGN] Result: tmp_U_15 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_12 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_12'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_12
[ASSIGN] Result: tmp_Roles_12 := {}
[SEE] Interruption at statement 175

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_15)), =([](tmp_Roles_11, ownerEmail), OWNER), in(orderId, dom(tmp_O_5)), in(agentEmail, dom(tmp_U_15)), =([](tmp_Roles_12, agentEmail), AGENT))
  [EVAL] FuncCall: AND with 5 args
    [EVAL] N-ary AND with 5 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_15))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail15'
    [EVAL] Found in sigma: X44
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_15
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X44
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_11, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_11
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail15'
    [EVAL] Found in sigma: X44
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X44
    [EVAL] Key not found in map
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X44) OWNER)
    [EVAL] Arg[2]: in(orderId, dom(tmp_O_5))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId15'
    [EVAL] Found in sigma: X45
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_5
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X45
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] Arg[3]: in(agentEmail, dom(tmp_U_15))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail15'
    [EVAL] Found in sigma: X46
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_15
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X46
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[3] result: false
    [EVAL] Arg[4]: =([](tmp_Roles_12, agentEmail), AGENT)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_12
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail15'
    [EVAL] Found in sigma: X46
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X46
    [EVAL] Key not found in map
  [EVAL] Var lookup: AGENT
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[4] result: (= []({}, X46) AGENT)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'assignOrder' with symbolic arguments - interruption point
[SEE] Interruption at statement 176

[ASSIGN] Evaluating: _result15 := assignOrder(ownerEmail, orderId, agentEmail)
[SEE] Mapping base name '_result' -> '_result15'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail15'
    [EVAL] Found in sigma: X44
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId15'
    [EVAL] Found in sigma: X45
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail15'
    [EVAL] Found in sigma: X46
[API_CALL] assignOrder has symbolic arguments - skipping actual execution
  [API_ARG 0] X44 (symbolic: 1)
  [API_ARG 1] X45 (symbolic: 1)
  [API_ARG 2] X46 (symbolic: 1)
[ASSIGN] Result: _result15 := -1 (symbolic placeholder)
[SEE] API call 'get_Assignments' ready for actual execution

[ASSIGN] Evaluating: tmp_Assignments_1 := get_Assignments()
[SEE] Mapping base name 'tmp_Assignments_' -> 'tmp_Assignments_1'
[API_CALL] Executing API function: get_Assignments
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Assignments
  [API_CALL] Executing function...
[GetAssignmentsFunc] Fetching Assignments...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Assignments_1
[ASSIGN] Result: tmp_Assignments_1 := {}

[ASSERT] Evaluating: =([](tmp_Assignments_1, orderId), agentEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Assignments_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId15'
    [EVAL] Found in sigma: X45
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X45
    [EVAL] Key not found in map
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail15'
    [EVAL] Found in sigma: X46
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
[ASSERT] Result: (= []({}, X45) X46)
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: agentEmail16 := input()
[SEE] Mapping base name 'agentEmail' -> 'agentEmail16'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X47
[ASSIGN] Result: agentEmail16 := X47

[ASSIGN] Evaluating: orderId16 := input()
[SEE] Mapping base name 'orderId' -> 'orderId16'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X48
[ASSIGN] Result: orderId16 := X48

[ASSIGN] Evaluating: orderStatus16 := input()
[SEE] Mapping base name 'orderStatus' -> 'orderStatus16'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X49
[ASSIGN] Result: orderStatus16 := X49
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_16 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_16'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_16
[ASSIGN] Result: tmp_T_16 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_13 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_13'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_13
[ASSIGN] Result: tmp_Roles_13 := {}
[SEE] API call 'get_Assignments' ready for actual execution

[ASSIGN] Evaluating: tmp_Assignments_2 := get_Assignments()
[SEE] Mapping base name 'tmp_Assignments_' -> 'tmp_Assignments_2'
[API_CALL] Executing API function: get_Assignments
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Assignments
  [API_CALL] Executing function...
[GetAssignmentsFunc] Fetching Assignments...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Assignments_2
[ASSIGN] Result: tmp_Assignments_2 := {}
[SEE] API call 'get_Assignments' ready for actual execution

[ASSIGN] Evaluating: tmp_Assignments_3 := get_Assignments()
[SEE] Mapping base name 'tmp_Assignments_' -> 'tmp_Assignments_3'
[API_CALL] Executing API function: get_Assignments
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Assignments
  [API_CALL] Executing function...
[GetAssignmentsFunc] Fetching Assignments...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Assignments_3
[ASSIGN] Result: tmp_Assignments_3 := {}
[SEE] Interruption at statement 186

[ASSUME] Evaluating: AND(in(agentEmail, dom(tmp_T_16)), =([](tmp_Roles_13, agentEmail), AGENT), in(orderId, dom(tmp_Assignments_2)), =([](tmp_Assignments_3, orderId), agentEmail))
  [EVAL] FuncCall: AND with 4 args
    [EVAL] N-ary AND with 4 args
    [EVAL] Arg[0]: in(agentEmail, dom(tmp_T_16))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail16'
    [EVAL] Found in sigma: X47
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_16
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X47
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_13, agentEmail), AGENT)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_13
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail16'
    [EVAL] Found in sigma: X47
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X47
    [EVAL] Key not found in map
  [EVAL] Var lookup: AGENT
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X47) AGENT)
    [EVAL] Arg[2]: in(orderId, dom(tmp_Assignments_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId16'
    [EVAL] Found in sigma: X48
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_Assignments_2
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X48
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] Arg[3]: =([](tmp_Assignments_3, orderId), agentEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Assignments_3
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId16'
    [EVAL] Found in sigma: X48
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X48
    [EVAL] Key not found in map
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail16'
    [EVAL] Found in sigma: X47
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[3] result: (= []({}, X48) X47)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'updateOrderStatusAgent' with symbolic arguments - interruption point
[SEE] Interruption at statement 187

[ASSIGN] Evaluating: _result16 := updateOrderStatusAgent(agentEmail, orderId, orderStatus)
[SEE] Mapping base name '_result' -> '_result16'
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail16'
    [EVAL] Found in sigma: X47
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId16'
    [EVAL] Found in sigma: X48
  [EVAL] Var lookup: orderStatus
    [EVAL] Resolved base name 'orderStatus' -> 'orderStatus16'
    [EVAL] Found in sigma: X49
[API_CALL] updateOrderStatusAgent has symbolic arguments - skipping actual execution
  [API_ARG 0] X47 (symbolic: 1)
  [API_ARG 1] X48 (symbolic: 1)
  [API_ARG 2] X49 (symbolic: 1)
[ASSIGN] Result: _result16 := -1 (symbolic placeholder)

[ASSERT] Empty assertion, PASSED

[ASSIGN] Evaluating: agentEmail17 := input()
[SEE] Mapping base name 'agentEmail' -> 'agentEmail17'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X50
[ASSIGN] Result: agentEmail17 := X50

[ASSIGN] Evaluating: orderId17 := input()
[SEE] Mapping base name 'orderId' -> 'orderId17'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X51
[ASSIGN] Result: orderId17 := X51

[ASSIGN] Evaluating: orderStatus17 := input()
[SEE] Mapping base name 'orderStatus' -> 'orderStatus17'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X52
[ASSIGN] Result: orderStatus17 := X52
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_17 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_17'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_17
[ASSIGN] Result: tmp_T_17 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_14 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_14'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_14
[ASSIGN] Result: tmp_Roles_14 := {}
[SEE] API call 'get_Assignments' ready for actual execution

[ASSIGN] Evaluating: tmp_Assignments_4 := get_Assignments()
[SEE] Mapping base name 'tmp_Assignments_' -> 'tmp_Assignments_4'
[API_CALL] Executing API function: get_Assignments
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Assignments
  [API_CALL] Executing function...
[GetAssignmentsFunc] Fetching Assignments...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Assignments_4
[ASSIGN] Result: tmp_Assignments_4 := {}
[SEE] API call 'get_Assignments' ready for actual execution

[ASSIGN] Evaluating: tmp_Assignments_5 := get_Assignments()
[SEE] Mapping base name 'tmp_Assignments_' -> 'tmp_Assignments_5'
[API_CALL] Executing API function: get_Assignments
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Assignments
  [API_CALL] Executing function...
[GetAssignmentsFunc] Fetching Assignments...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Assignments_5
[ASSIGN] Result: tmp_Assignments_5 := {}
[SEE] Interruption at statement 196

[ASSUME] Evaluating: AND(in(agentEmail, dom(tmp_T_17)), =([](tmp_Roles_14, agentEmail), AGENT), in(orderId, dom(tmp_Assignments_4)), =([](tmp_Assignments_5, orderId), agentEmail))
  [EVAL] FuncCall: AND with 4 args
    [EVAL] N-ary AND with 4 args
    [EVAL] Arg[0]: in(agentEmail, dom(tmp_T_17))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail17'
    [EVAL] Found in sigma: X50
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_17
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X50
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_14, agentEmail), AGENT)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_14
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail17'
    [EVAL] Found in sigma: X50
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X50
    [EVAL] Key not found in map
  [EVAL] Var lookup: AGENT
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X50) AGENT)
    [EVAL] Arg[2]: in(orderId, dom(tmp_Assignments_4))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId17'
    [EVAL] Found in sigma: X51
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_Assignments_4
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X51
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] Arg[3]: =([](tmp_Assignments_5, orderId), agentEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Assignments_5
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId17'
    [EVAL] Found in sigma: X51
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X51
    [EVAL] Key not found in map
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail17'
    [EVAL] Found in sigma: X50
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[3] result: (= []({}, X51) X50)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'updateOrderStatusAgent' with symbolic arguments - interruption point
[SEE] Interruption at statement 197

[ASSIGN] Evaluating: _result17 := updateOrderStatusAgent(agentEmail, orderId, orderStatus)
[SEE] Mapping base name '_result' -> '_result17'
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail17'
    [EVAL] Found in sigma: X50
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId17'
    [EVAL] Found in sigma: X51
  [EVAL] Var lookup: orderStatus
    [EVAL] Resolved base name 'orderStatus' -> 'orderStatus17'
    [EVAL] Found in sigma: X52
[API_CALL] updateOrderStatusAgent has symbolic arguments - skipping actual execution
  [API_ARG 0] X50 (symbolic: 1)
  [API_ARG 1] X51 (symbolic: 1)
  [API_ARG 2] X52 (symbolic: 1)
[ASSIGN] Result: _result17 := -1 (symbolic placeholder)

[ASSERT] Empty assertion, PASSED

[ASSIGN] Evaluating: customerEmail18 := input()
[SEE] Mapping base name 'customerEmail' -> 'customerEmail18'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X53
[ASSIGN] Result: customerEmail18 := X53

[ASSIGN] Evaluating: orderId18 := input()
[SEE] Mapping base name 'orderId' -> 'orderId18'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X54
[ASSIGN] Result: orderId18 := X54

[ASSIGN] Evaluating: restaurantRating18 := input()
[SEE] Mapping base name 'restaurantRating' -> 'restaurantRating18'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X55
[ASSIGN] Result: restaurantRating18 := X55

[ASSIGN] Evaluating: deliveryRating18 := input()
[SEE] Mapping base name 'deliveryRating' -> 'deliveryRating18'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X56
[ASSIGN] Result: deliveryRating18 := X56

[ASSIGN] Evaluating: reviewComment18 := input()
[SEE] Mapping base name 'reviewComment' -> 'reviewComment18'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X57
[ASSIGN] Result: reviewComment18 := X57
[SEE] API call 'get_Rev' ready for actual execution

[ASSIGN] Evaluating: tmp_Rev_0 := get_Rev()
[SEE] Mapping base name 'tmp_Rev_' -> 'tmp_Rev_0'
[API_CALL] Executing API function: get_Rev
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Rev
  [API_CALL] Executing function...
[GetRevFunc] Fetching Rev...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Rev_0
[ASSIGN] Result: tmp_Rev_0 := {}

[ASSIGN] Evaluating: Rev_old := tmp_Rev_0
  [EVAL] Var lookup: tmp_Rev_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Rev_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_18 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_18'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_18
[ASSIGN] Result: tmp_T_18 := {}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_6 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_6'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_6
[ASSIGN] Result: tmp_O_6 := {}
[SEE] Interruption at statement 208

[ASSUME] Evaluating: AND(in(customerEmail, dom(tmp_T_18)), in(orderId, dom(tmp_O_6)))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(customerEmail, dom(tmp_T_18))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail18'
    [EVAL] Found in sigma: X53
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_18
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X53
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: in(orderId, dom(tmp_O_6))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId18'
    [EVAL] Found in sigma: X54
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_6
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X54
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[1] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'leaveReview' with symbolic arguments - interruption point
[SEE] Interruption at statement 209

[ASSIGN] Evaluating: _result18 := leaveReview(customerEmail, orderId, restaurantRating, deliveryRating, reviewComment)
[SEE] Mapping base name '_result' -> '_result18'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail18'
    [EVAL] Found in sigma: X53
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId18'
    [EVAL] Found in sigma: X54
  [EVAL] Var lookup: restaurantRating
    [EVAL] Resolved base name 'restaurantRating' -> 'restaurantRating18'
    [EVAL] Found in sigma: X55
  [EVAL] Var lookup: deliveryRating
    [EVAL] Resolved base name 'deliveryRating' -> 'deliveryRating18'
    [EVAL] Found in sigma: X56
  [EVAL] Var lookup: reviewComment
    [EVAL] Resolved base name 'reviewComment' -> 'reviewComment18'
    [EVAL] Found in sigma: X57
[API_CALL] leaveReview has symbolic arguments - skipping actual execution
  [API_ARG 0] X53 (symbolic: 1)
  [API_ARG 1] X54 (symbolic: 1)
  [API_ARG 2] X55 (symbolic: 1)
  [API_ARG 3] X56 (symbolic: 1)
  [API_ARG 4] X57 (symbolic: 1)
[ASSIGN] Result: _result18 := -1 (symbolic placeholder)
[SEE] API call 'get_Rev' ready for actual execution

[ASSIGN] Evaluating: tmp_Rev_1 := get_Rev()
[SEE] Mapping base name 'tmp_Rev_' -> 'tmp_Rev_1'
[API_CALL] Executing API function: get_Rev
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Rev
  [API_CALL] Executing function...
[GetRevFunc] Fetching Rev...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Rev_1
[ASSIGN] Result: tmp_Rev_1 := {}

[ASSERT] Evaluating: in(_result18, dom(tmp_Rev_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result18
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_Rev_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[SEE] Path Constraint: And(true, And(true, And(AND((= []({}, X0) X1), (= []({}, X0) OWNER)), And(false, And((= []({}, X4) -1), And(false, And(false, And(true, And(AND((= []({}, X14) X15), (= []({}, X14) CUSTOMER)), And(false, And((= []({}, X18) -1), And(false, And(false, And(false, And(false, And(true, And(AND((= []({}, X29) X30), (= []({}, X29) AGENT)), And(false, And((= []({}, X33) -1), And(false, And(false, And(false, And(false, And((= []({}, X45) X46), And(false, And(false, false))))))))))))))))))))))))))
>>> generateCTC: After symex - Is abstract: 1, Has placeholders: 0

>>> generateCTC: STEP 3 - Generating values with sigma lookup
    [Found existing] _ -> _
    [Found existing] tmp_Roles_ -> tmp_Roles_0
    [Found existing] Roles_old -> Roles_old
    [Found existing] tmp_U_ -> tmp_U_0
    [Found existing] U_old -> U_old
    [Found existing] _result -> _result0
    [Found existing] tmp_T_ -> tmp_T_0
    [Found existing] T_old -> T_old
    [Found existing] tmp_Owners_ -> tmp_Owners_0
    [Found existing] Owners_old -> Owners_old
    [Found existing] tmp_R_ -> tmp_R_0
    [Found existing] R_old -> R_old
    [Found existing] tmp_M_ -> tmp_M_0
    [Found existing] M_old -> M_old
    [Found existing] tmp_C_ -> tmp_C_0
    [Found existing] C_old -> C_old
    [Found existing] tmp_O_ -> tmp_O_0
    [Found existing] O_old -> O_old
    [Found existing] tmp_Assignments_ -> tmp_Assignments_0
    [Found existing] Assignments_old -> Assignments_old
    [Found existing] tmp_Rev_ -> tmp_Rev_0
    [Found existing] Rev_old -> Rev_old
    ownerEmail0 = "owner@example.com"
    ownerPassword0 = "OwnerPass1!"
    ownerFullName0 = "Test Owner"
    ownerMobile0 = "5550000001"
    ownerEmail1 = (reusing ownerEmail) "owner@example.com"
    ownerPassword1 = (reusing ownerPassword) "OwnerPass1!"
    ownerEmail2 = (reusing ownerEmail) "owner@example.com"
    restaurantName2 = "Test Restaurant"
    restaurantAddress2 = "123 Restaurant Street"
    restaurantContact2 = "restaurant@test.com"
    ownerEmail3 = (reusing ownerEmail) "owner@example.com"
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] tmp_R_3 is empty map
    [findKeyFromMapInSigma] tmp_R_2 is empty map
    [findKeyFromMapInSigma] tmp_R_1 is empty map
    [findKeyFromMapInSigma] tmp_R_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_R_
    [DEFERRED] restaurantId - no restaurant in sigma yet
    restaurantId3 = "__NEEDS_RESTAURANT_ID__"
    itemName3 = "Delicious Dish"
    itemPrice3 = 150
    customerEmail4 = "customer@example.com"
    customerPassword4 = "CustomerPass1!"
    customerFullName4 = "Test Customer"
    customerMobile4 = "5550000002"
    customerEmail5 = (reusing customerEmail) "customer@example.com"
    customerPassword5 = (reusing customerPassword) "CustomerPass1!"
    customerEmail6 = (reusing customerEmail) "customer@example.com"
    customerEmail7 = (reusing customerEmail) "customer@example.com"
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] tmp_R_3 is empty map
    [findKeyFromMapInSigma] tmp_R_2 is empty map
    [findKeyFromMapInSigma] tmp_R_1 is empty map
    [findKeyFromMapInSigma] tmp_R_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_R_
    [DEFERRED] restaurantId - no restaurant in sigma yet
    restaurantId7 = "__NEEDS_RESTAURANT_ID__"
    customerEmail8 = (reusing customerEmail) "customer@example.com"
    [findKeyFromMapInSigma] Searching for prefix: tmp_M_
    [findKeyFromMapInSigma] tmp_M_2 is empty map
    [findKeyFromMapInSigma] tmp_M_1 is empty map
    [findKeyFromMapInSigma] tmp_M_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_M_
    [DEFERRED] menuItemId - no menu item in sigma yet
    menuItemId8 = "__NEEDS_MENUITEM_ID__"
    quantity8 = 2
    customerEmail9 = (reusing customerEmail) "customer@example.com"
    deliveryAddress9 = "456 Customer Lane, Apt 7"
    paymentMethod9 = "card"
    agentEmail10 = "agent@example.com"
    agentPassword10 = "AgentPass1!"
    agentFullName10 = "Test Agent"
    agentMobile10 = "5550000003"
    agentEmail11 = (reusing agentEmail) "agent@example.com"
    agentPassword11 = (reusing agentPassword) "AgentPass1!"
    ownerEmail12 = (reusing ownerEmail) "owner@example.com"
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [DEFERRED] orderId - no order in sigma yet
    orderId12 = "__NEEDS_ORDER_ID__"
    [ORDER STATUS] Call #1 (index=37) -> status = "accepted"
    orderStatus12 = "accepted"
    ownerEmail13 = (reusing ownerEmail) "owner@example.com"
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [DEFERRED] orderId - no order in sigma yet
    orderId13 = "__NEEDS_ORDER_ID__"
    [ORDER STATUS] Call #2 (index=40) -> status = "preparing"
    orderStatus13 = "preparing"
    ownerEmail14 = (reusing ownerEmail) "owner@example.com"
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [DEFERRED] orderId - no order in sigma yet
    orderId14 = "__NEEDS_ORDER_ID__"
    [ORDER STATUS] Call #3 (index=43) -> status = "ready"
    orderStatus14 = "ready"
    ownerEmail15 = (reusing ownerEmail) "owner@example.com"
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [DEFERRED] orderId - no order in sigma yet
    orderId15 = "__NEEDS_ORDER_ID__"
    agentEmail15 = (reusing agentEmail) "agent@example.com"
    agentEmail16 = (reusing agentEmail) "agent@example.com"
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [DEFERRED] orderId - no order in sigma yet
    orderId16 = "__NEEDS_ORDER_ID__"
    [ORDER STATUS] Call #4 (index=49) -> status = "picked_up"
    orderStatus16 = "picked_up"
    agentEmail17 = (reusing agentEmail) "agent@example.com"
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [DEFERRED] orderId - no order in sigma yet
    orderId17 = "__NEEDS_ORDER_ID__"
    [ORDER STATUS] Call #5 (index=52) -> status = "delivered"
    orderStatus17 = "delivered"
    customerEmail18 = (reusing customerEmail) "customer@example.com"
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [DEFERRED] orderId - no order in sigma yet
    orderId18 = "__NEEDS_ORDER_ID__"
    restaurantRating18 = 5
    deliveryRating18 = 4
    reviewComment18 = "Great food and fast delivery!"

>>> generateCTC: STEP 4 - Resolving placeholders from sigma
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] tmp_R_3 is empty map
    [findKeyFromMapInSigma] tmp_R_2 is empty map
    [findKeyFromMapInSigma] tmp_R_1 is empty map
    [findKeyFromMapInSigma] tmp_R_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_R_
    [STILL PENDING] restaurantId3 - keeping placeholder for next iteration
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] tmp_R_3 is empty map
    [findKeyFromMapInSigma] tmp_R_2 is empty map
    [findKeyFromMapInSigma] tmp_R_1 is empty map
    [findKeyFromMapInSigma] tmp_R_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_R_
    [STILL PENDING] restaurantId7 - keeping placeholder for next iteration
    [findKeyFromMapInSigma] Searching for prefix: tmp_M_
    [findKeyFromMapInSigma] tmp_M_2 is empty map
    [findKeyFromMapInSigma] tmp_M_1 is empty map
    [findKeyFromMapInSigma] tmp_M_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_M_
    [STILL PENDING] menuItemId8 - keeping placeholder for next iteration
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [STILL PENDING] orderId12 - keeping placeholder for next iteration
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [STILL PENDING] orderId13 - keeping placeholder for next iteration
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [STILL PENDING] orderId14 - keeping placeholder for next iteration
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [STILL PENDING] orderId15 - keeping placeholder for next iteration
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [STILL PENDING] orderId16 - keeping placeholder for next iteration
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [STILL PENDING] orderId17 - keeping placeholder for next iteration
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [STILL PENDING] orderId18 - keeping placeholder for next iteration

>>> generateCTC: STEP 5 - Recursing with 58 concrete values

========================================
>>> generateCTC: Starting iteration
========================================
>>> generateCTC: Program needs processing
>>> generateCTC: Concrete values provided: 58
>>> generateCTC: Is abstract: 1
>>> generateCTC: Has placeholders: 0

>>> generateCTC: STEP 1 - Rewriting ATC with concrete values

>>> generateCTC: STEP 2 - Running symbolic execution
[SEE] API call 'reset' ready for actual execution

[ASSIGN] Evaluating: _ := reset()
[API_CALL] Executing API function: reset
  [API_CALL] Getting function from factory...
[Factory] Creating function: reset
  [API_CALL] Executing function...
[ResetFunc] Clearing all collections...
[HttpClient] POST /api/test/reset -> 200
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _
[ASSIGN] Result: _ := 200

[ASSIGN] Evaluating: ownerEmail0 := "owner@example.com"
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail0'
  [EVAL] String: "owner@example.com"
[ASSIGN] Result: ownerEmail0 := "owner@example.com"

[ASSIGN] Evaluating: ownerPassword0 := "OwnerPass1!"
[SEE] Mapping base name 'ownerPassword' -> 'ownerPassword0'
  [EVAL] String: "OwnerPass1!"
[ASSIGN] Result: ownerPassword0 := "OwnerPass1!"

[ASSIGN] Evaluating: ownerFullName0 := "Test Owner"
[SEE] Mapping base name 'ownerFullName' -> 'ownerFullName0'
  [EVAL] String: "Test Owner"
[ASSIGN] Result: ownerFullName0 := "Test Owner"

[ASSIGN] Evaluating: ownerMobile0 := "5550000001"
[SEE] Mapping base name 'ownerMobile' -> 'ownerMobile0'
  [EVAL] String: "5550000001"
[ASSIGN] Result: ownerMobile0 := "5550000001"
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_0 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_0'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_0
[ASSIGN] Result: tmp_Roles_0 := {}

[ASSIGN] Evaluating: Roles_old := tmp_Roles_0
  [EVAL] Var lookup: tmp_Roles_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Roles_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_0 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_0'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_0
[ASSIGN] Result: tmp_U_0 := {}

[ASSIGN] Evaluating: U_old := tmp_U_0
  [EVAL] Var lookup: tmp_U_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: U_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_1 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_1'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_1
[ASSIGN] Result: tmp_U_1 := {}

[ASSUME] Evaluating: not_in(ownerEmail, dom(tmp_U_1))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail0'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
[ASSUME] Adding constraint: true
[SEE] API call 'registerOwner' ready for actual execution

[ASSIGN] Evaluating: _result0 := registerOwner(ownerEmail, ownerPassword, ownerFullName, ownerMobile)
[SEE] Mapping base name '_result' -> '_result0'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail0'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] Var lookup: ownerPassword
    [EVAL] Resolved base name 'ownerPassword' -> 'ownerPassword0'
    [EVAL] Found in sigma: "OwnerPass1!"
  [EVAL] Var lookup: ownerFullName
    [EVAL] Resolved base name 'ownerFullName' -> 'ownerFullName0'
    [EVAL] Found in sigma: "Test Owner"
  [EVAL] Var lookup: ownerMobile
    [EVAL] Resolved base name 'ownerMobile' -> 'ownerMobile0'
    [EVAL] Found in sigma: "5550000001"
[API_CALL] Executing API function: registerOwner
  [API_ARG] "owner@example.com"
  [API_ARG] "OwnerPass1!"
  [API_ARG] "Test Owner"
  [API_ARG] "5550000001"
  [API_CALL] Getting function from factory...
[Factory] Creating function: registerOwner
  [API_CALL] Executing function...
[RegisterOwnerFunc] Registering owner: owner@example.com
[HttpClient] POST /api/auth/register -> 201
  [API_CALL] Function returned: 201
  [API_CALL] Storing result in variable: _result0
[ASSIGN] Result: _result0 := 201
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_2 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_2'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {owner@example.com -> "OwnerPass1!"}
  [API_CALL] Storing result in variable: tmp_U_2
[ASSIGN] Result: tmp_U_2 := {owner@example.com -> "OwnerPass1!"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_1 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_1'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {owner@example.com -> "restaurant_owner"}
  [API_CALL] Storing result in variable: tmp_Roles_1
[ASSIGN] Result: tmp_Roles_1 := {owner@example.com -> "restaurant_owner"}

[ASSERT] Evaluating: AND(=([](tmp_U_2, ownerEmail), ownerPassword), =([](tmp_Roles_1, ownerEmail), OWNER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: =([](tmp_U_2, ownerEmail), ownerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_2
    [EVAL] Found in sigma: {owner@example.com -> "OwnerPass1!"}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail0'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Map expr evaluated: {owner@example.com -> "OwnerPass1!"}
    [EVAL] Key expr evaluated: "owner@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "OwnerPass1!"
  [EVAL] Var lookup: ownerPassword
    [EVAL] Resolved base name 'ownerPassword' -> 'ownerPassword0'
    [EVAL] Found in sigma: "OwnerPass1!"
    [EVAL] Eq result: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_1, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_1
    [EVAL] Found in sigma: {owner@example.com -> "restaurant_owner"}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail0'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Map expr evaluated: {owner@example.com -> "restaurant_owner"}
    [EVAL] Key expr evaluated: "owner@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "restaurant_owner"
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "restaurant_owner" OWNER)
    [EVAL] FuncCall result: AND(true, (= "restaurant_owner" OWNER))
[ASSERT] Result: AND(true, (= "restaurant_owner" OWNER))
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: ownerEmail1 := "owner@example.com"
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail1'
  [EVAL] String: "owner@example.com"
[ASSIGN] Result: ownerEmail1 := "owner@example.com"

[ASSIGN] Evaluating: ownerPassword1 := "OwnerPass1!"
[SEE] Mapping base name 'ownerPassword' -> 'ownerPassword1'
  [EVAL] String: "OwnerPass1!"
[ASSIGN] Result: ownerPassword1 := "OwnerPass1!"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_0 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_0'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [API_CALL] Storing result in variable: tmp_T_0
[ASSIGN] Result: tmp_T_0 := {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}

[ASSIGN] Evaluating: T_old := tmp_T_0
  [EVAL] Var lookup: tmp_T_0
    [EVAL] Found in sigma: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
[ASSIGN] Result: T_old := {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_3 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_3'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {owner@example.com -> "OwnerPass1!"}
  [API_CALL] Storing result in variable: tmp_U_3
[ASSIGN] Result: tmp_U_3 := {owner@example.com -> "OwnerPass1!"}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_4 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_4'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {owner@example.com -> "OwnerPass1!"}
  [API_CALL] Storing result in variable: tmp_U_4
[ASSIGN] Result: tmp_U_4 := {owner@example.com -> "OwnerPass1!"}

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_U_3)), =([](tmp_U_4, ownerEmail), ownerPassword))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_U_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail1'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_3
    [EVAL] Found in sigma: {owner@example.com -> "OwnerPass1!"}
    [EVAL] Map expr evaluated: {owner@example.com -> "OwnerPass1!"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"owner@example.com"}
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_U_4, ownerEmail), ownerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_4
    [EVAL] Found in sigma: {owner@example.com -> "OwnerPass1!"}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail1'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Map expr evaluated: {owner@example.com -> "OwnerPass1!"}
    [EVAL] Key expr evaluated: "owner@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "OwnerPass1!"
  [EVAL] Var lookup: ownerPassword
    [EVAL] Resolved base name 'ownerPassword' -> 'ownerPassword1'
    [EVAL] Found in sigma: "OwnerPass1!"
    [EVAL] Eq result: true
    [EVAL] Arg[1] result: true
    [EVAL] FuncCall result: AND(...) = true
[ASSUME] Adding constraint: true
[SEE] API call 'login' ready for actual execution

[ASSIGN] Evaluating: _result1 := login(ownerEmail, ownerPassword)
[SEE] Mapping base name '_result' -> '_result1'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail1'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] Var lookup: ownerPassword
    [EVAL] Resolved base name 'ownerPassword' -> 'ownerPassword1'
    [EVAL] Found in sigma: "OwnerPass1!"
[API_CALL] Executing API function: login
  [API_ARG] "owner@example.com"
  [API_ARG] "OwnerPass1!"
  [API_CALL] Getting function from factory...
[Factory] Creating function: login
  [API_CALL] Executing function...
[LoginFunc] Logging in: owner@example.com
[HttpClient] POST /api/auth/login -> 200
[LoginFunc] Token received for: owner@example.com
  [API_CALL] Function returned: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"
  [API_CALL] Storing result in variable: _result1
[ASSIGN] Result: _result1 := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_1 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_1'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [API_CALL] Storing result in variable: tmp_T_1
[ASSIGN] Result: tmp_T_1 := {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}

[ASSERT] Evaluating: =([](tmp_T_1, ownerEmail), _result1)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_T_1
    [EVAL] Found in sigma: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail1'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Map expr evaluated: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Key expr evaluated: "owner@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"
  [EVAL] Var lookup: _result1
    [EVAL] Found in sigma: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"
    [EVAL] Eq result: true
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[ASSIGN] Evaluating: ownerEmail2 := "owner@example.com"
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail2'
  [EVAL] String: "owner@example.com"
[ASSIGN] Result: ownerEmail2 := "owner@example.com"

[ASSIGN] Evaluating: restaurantName2 := "Test Restaurant"
[SEE] Mapping base name 'restaurantName' -> 'restaurantName2'
  [EVAL] String: "Test Restaurant"
[ASSIGN] Result: restaurantName2 := "Test Restaurant"

[ASSIGN] Evaluating: restaurantAddress2 := "123 Restaurant Street"
[SEE] Mapping base name 'restaurantAddress' -> 'restaurantAddress2'
  [EVAL] String: "123 Restaurant Street"
[ASSIGN] Result: restaurantAddress2 := "123 Restaurant Street"

[ASSIGN] Evaluating: restaurantContact2 := "restaurant@test.com"
[SEE] Mapping base name 'restaurantContact' -> 'restaurantContact2'
  [EVAL] String: "restaurant@test.com"
[ASSIGN] Result: restaurantContact2 := "restaurant@test.com"
[SEE] API call 'get_Owners' ready for actual execution

[ASSIGN] Evaluating: tmp_Owners_0 := get_Owners()
[SEE] Mapping base name 'tmp_Owners_' -> 'tmp_Owners_0'
[API_CALL] Executing API function: get_Owners
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Owners
  [API_CALL] Executing function...
[GetOwnersFunc] Fetching Owners...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Owners_0
[ASSIGN] Result: tmp_Owners_0 := {}

[ASSIGN] Evaluating: Owners_old := tmp_Owners_0
  [EVAL] Var lookup: tmp_Owners_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Owners_old := {}
[SEE] API call 'get_R' ready for actual execution

[ASSIGN] Evaluating: tmp_R_0 := get_R()
[SEE] Mapping base name 'tmp_R_' -> 'tmp_R_0'
[API_CALL] Executing API function: get_R
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_R
  [API_CALL] Executing function...
[GetRFunc] Fetching R...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_R_0
[ASSIGN] Result: tmp_R_0 := {}

[ASSIGN] Evaluating: R_old := tmp_R_0
  [EVAL] Var lookup: tmp_R_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: R_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_2 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_2'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [API_CALL] Storing result in variable: tmp_T_2
[ASSIGN] Result: tmp_T_2 := {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_2 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_2'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {owner@example.com -> "restaurant_owner"}
  [API_CALL] Storing result in variable: tmp_Roles_2
[ASSIGN] Result: tmp_Roles_2 := {owner@example.com -> "restaurant_owner"}

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_2)), =([](tmp_Roles_2, ownerEmail), OWNER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail2'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_2
    [EVAL] Found in sigma: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Map expr evaluated: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"owner@example.com"}
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_2, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_2
    [EVAL] Found in sigma: {owner@example.com -> "restaurant_owner"}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail2'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Map expr evaluated: {owner@example.com -> "restaurant_owner"}
    [EVAL] Key expr evaluated: "owner@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "restaurant_owner"
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "restaurant_owner" OWNER)
    [EVAL] FuncCall result: AND(true, (= "restaurant_owner" OWNER))
[ASSUME] Adding constraint: AND(true, (= "restaurant_owner" OWNER))
[SEE] API call 'createRestaurant' ready for actual execution

[ASSIGN] Evaluating: _result2 := createRestaurant(ownerEmail, restaurantName, restaurantAddress, restaurantContact)
[SEE] Mapping base name '_result' -> '_result2'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail2'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] Var lookup: restaurantName
    [EVAL] Resolved base name 'restaurantName' -> 'restaurantName2'
    [EVAL] Found in sigma: "Test Restaurant"
  [EVAL] Var lookup: restaurantAddress
    [EVAL] Resolved base name 'restaurantAddress' -> 'restaurantAddress2'
    [EVAL] Found in sigma: "123 Restaurant Street"
  [EVAL] Var lookup: restaurantContact
    [EVAL] Resolved base name 'restaurantContact' -> 'restaurantContact2'
    [EVAL] Found in sigma: "restaurant@test.com"
[API_CALL] Executing API function: createRestaurant
  [API_ARG] "owner@example.com"
  [API_ARG] "Test Restaurant"
  [API_ARG] "123 Restaurant Street"
  [API_ARG] "restaurant@test.com"
  [API_CALL] Getting function from factory...
[Factory] Creating function: createRestaurant
  [API_CALL] Executing function...
[CreateRestaurantFunc] owner@example.com creating restaurant: Test Restaurant
[CreateRestaurantFunc] Request body: {
  "address": {
    "city": "TestCity",
    "state": "TestState",
    "street": "123 Restaurant Street",
    "zipCode": "12345"
  },
  "contact": {
    "email": "restaurant@test.com",
    "phone": "1234567890"
  },
  "cuisineTypes": [
    "Indian",
    "Continental"
  ],
  "hours": {
    "closing": "22:00",
    "opening": "09:00"
  },
  "name": "Test Restaurant"
}
[HttpClient] POST /api/restaurants -> 201
[CreateRestaurantFunc] Response status: 201
[CreateRestaurantFunc] Restaurant created: 696a632bc1e2b9273264cc09
  [API_CALL] Function returned: "696a632bc1e2b9273264cc09"
  [API_CALL] Storing result in variable: _result2
[ASSIGN] Result: _result2 := "696a632bc1e2b9273264cc09"
[SEE] API call 'get_R' ready for actual execution

[ASSIGN] Evaluating: tmp_R_1 := get_R()
[SEE] Mapping base name 'tmp_R_' -> 'tmp_R_1'
[API_CALL] Executing API function: get_R
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_R
  [API_CALL] Executing function...
[GetRFunc] Fetching R...
  [API_CALL] Function returned: {696a632bc1e2b9273264cc09 -> ""Test Restaurant""}
  [API_CALL] Storing result in variable: tmp_R_1
[ASSIGN] Result: tmp_R_1 := {696a632bc1e2b9273264cc09 -> ""Test Restaurant""}
[SEE] API call 'get_Owners' ready for actual execution

[ASSIGN] Evaluating: tmp_Owners_1 := get_Owners()
[SEE] Mapping base name 'tmp_Owners_' -> 'tmp_Owners_1'
[API_CALL] Executing API function: get_Owners
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Owners
  [API_CALL] Executing function...
[GetOwnersFunc] Fetching Owners...
  [API_CALL] Function returned: {696a632bc1e2b9273264cc09 -> "owner@example.com"}
  [API_CALL] Storing result in variable: tmp_Owners_1
[ASSIGN] Result: tmp_Owners_1 := {696a632bc1e2b9273264cc09 -> "owner@example.com"}

[ASSERT] Evaluating: AND(in(_result2, dom(tmp_R_1)), =([](tmp_Owners_1, _result2), ownerEmail))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(_result2, dom(tmp_R_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result2
    [EVAL] Found in sigma: "696a632bc1e2b9273264cc09"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_R_1
    [EVAL] Found in sigma: {696a632bc1e2b9273264cc09 -> ""Test Restaurant""}
    [EVAL] Map expr evaluated: {696a632bc1e2b9273264cc09 -> ""Test Restaurant""}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696a632bc1e2b9273264cc09"
    [EVAL] Set: {"696a632bc1e2b9273264cc09"}
    [EVAL] Element: "696a632bc1e2b9273264cc09"
    [EVAL] Set: {"696a632bc1e2b9273264cc09"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Owners_1, _result2), ownerEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Owners_1
    [EVAL] Found in sigma: {696a632bc1e2b9273264cc09 -> "owner@example.com"}
  [EVAL] Var lookup: _result2
    [EVAL] Found in sigma: "696a632bc1e2b9273264cc09"
    [EVAL] Map expr evaluated: {696a632bc1e2b9273264cc09 -> "owner@example.com"}
    [EVAL] Key expr evaluated: "696a632bc1e2b9273264cc09"
    [EVAL] Key found in map, returning value
  [EVAL] String: "owner@example.com"
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail2'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Eq result: true
    [EVAL] Arg[1] result: true
    [EVAL] FuncCall result: AND(...) = true
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[ASSIGN] Evaluating: ownerEmail3 := "owner@example.com"
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail3'
  [EVAL] String: "owner@example.com"
[ASSIGN] Result: ownerEmail3 := "owner@example.com"

[ASSIGN] Evaluating: restaurantId3 := "__NEEDS_RESTAURANT_ID__"
[SEE] Mapping base name 'restaurantId' -> 'restaurantId3'
  [EVAL] String: "__NEEDS_RESTAURANT_ID__"
[ASSIGN] Result: restaurantId3 := "__NEEDS_RESTAURANT_ID__"

[ASSIGN] Evaluating: itemName3 := "Delicious Dish"
[SEE] Mapping base name 'itemName' -> 'itemName3'
  [EVAL] String: "Delicious Dish"
[ASSIGN] Result: itemName3 := "Delicious Dish"

[ASSIGN] Evaluating: itemPrice3 := 150
[SEE] Mapping base name 'itemPrice' -> 'itemPrice3'
  [EVAL] Num: 150
[ASSIGN] Result: itemPrice3 := 150
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_0 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_0'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_M_0
[ASSIGN] Result: tmp_M_0 := {}

[ASSIGN] Evaluating: M_old := tmp_M_0
  [EVAL] Var lookup: tmp_M_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: M_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_3 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_3'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [API_CALL] Storing result in variable: tmp_T_3
[ASSIGN] Result: tmp_T_3 := {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_3 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_3'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {owner@example.com -> "restaurant_owner"}
  [API_CALL] Storing result in variable: tmp_Roles_3
[ASSIGN] Result: tmp_Roles_3 := {owner@example.com -> "restaurant_owner"}
[SEE] API call 'get_R' ready for actual execution

[ASSIGN] Evaluating: tmp_R_2 := get_R()
[SEE] Mapping base name 'tmp_R_' -> 'tmp_R_2'
[API_CALL] Executing API function: get_R
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_R
  [API_CALL] Executing function...
[GetRFunc] Fetching R...
  [API_CALL] Function returned: {696a632bc1e2b9273264cc09 -> ""Test Restaurant""}
  [API_CALL] Storing result in variable: tmp_R_2
[ASSIGN] Result: tmp_R_2 := {696a632bc1e2b9273264cc09 -> ""Test Restaurant""}

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_3)), =([](tmp_Roles_3, ownerEmail), OWNER), in(restaurantId, dom(tmp_R_2)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail3'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_3
    [EVAL] Found in sigma: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Map expr evaluated: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"owner@example.com"}
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_3, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_3
    [EVAL] Found in sigma: {owner@example.com -> "restaurant_owner"}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail3'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Map expr evaluated: {owner@example.com -> "restaurant_owner"}
    [EVAL] Key expr evaluated: "owner@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "restaurant_owner"
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "restaurant_owner" OWNER)
    [EVAL] Arg[2]: in(restaurantId, dom(tmp_R_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId3'
    [EVAL] Found placeholder __NEEDS_RESTAURANT_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] tmp_R_0 is empty map
    [findKeyFromMapInSigma] Found tmp_R_1 with 1 entries, key: 696a632bc1e2b9273264cc09
    [findKeyFromMapInSigma] Found tmp_R_2 with 1 entries, key: 696a632bc1e2b9273264cc09
    [findKeyFromMapInSigma] tmp_R_3 is empty map
    [EVAL] Resolved to: 696a632bc1e2b9273264cc09
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_R_2
    [EVAL] Found in sigma: {696a632bc1e2b9273264cc09 -> ""Test Restaurant""}
    [EVAL] Map expr evaluated: {696a632bc1e2b9273264cc09 -> ""Test Restaurant""}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696a632bc1e2b9273264cc09"
    [EVAL] Set: {"696a632bc1e2b9273264cc09"}
    [EVAL] Element: "696a632bc1e2b9273264cc09"
    [EVAL] Set: {"696a632bc1e2b9273264cc09"}
    [EVAL] Element found in set: true
    [EVAL] Arg[2] result: true
    [EVAL] FuncCall result: AND(true, (= "restaurant_owner" OWNER), true)
[ASSUME] Adding constraint: AND(true, (= "restaurant_owner" OWNER), true)
[SEE] API call 'addMenuItem' ready for actual execution

[ASSIGN] Evaluating: _result3 := addMenuItem(ownerEmail, restaurantId, itemName, itemPrice)
[SEE] Mapping base name '_result' -> '_result3'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail3'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId3'
    [EVAL] Found in sigma: "696a632bc1e2b9273264cc09"
  [EVAL] Var lookup: itemName
    [EVAL] Resolved base name 'itemName' -> 'itemName3'
    [EVAL] Found in sigma: "Delicious Dish"
  [EVAL] Var lookup: itemPrice
    [EVAL] Resolved base name 'itemPrice' -> 'itemPrice3'
    [EVAL] Found in sigma: 150
[API_CALL] Executing API function: addMenuItem
  [API_ARG] "owner@example.com"
  [API_ARG] "696a632bc1e2b9273264cc09"
  [API_ARG] "Delicious Dish"
  [API_ARG] 150
  [API_CALL] Getting function from factory...
[Factory] Creating function: addMenuItem
  [API_CALL] Executing function...
[AddMenuItemFunc] owner@example.com adding menu item: Delicious Dish to restaurant 696a632bc1e2b9273264cc09
[HttpClient] POST /api/menu -> 201
[AddMenuItemFunc] Menu item created: 696a632bc1e2b9273264cc15
  [API_CALL] Function returned: 201
  [API_CALL] Storing result in variable: _result3
[ASSIGN] Result: _result3 := 201
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_1 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_1'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
[GetMFunc] Menu item: 696a632bc1e2b9273264cc15 -> restaurant: 696a632bc1e2b9273264cc09
  [API_CALL] Function returned: {696a632bc1e2b9273264cc15 -> "696a632bc1e2b9273264cc09"}
  [API_CALL] Storing result in variable: tmp_M_1
[ASSIGN] Result: tmp_M_1 := {696a632bc1e2b9273264cc15 -> "696a632bc1e2b9273264cc09"}

[ASSERT] Evaluating: in(_result3, dom(tmp_M_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result3
    [EVAL] Found in sigma: 201
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_M_1
    [EVAL] Found in sigma: {696a632bc1e2b9273264cc15 -> "696a632bc1e2b9273264cc09"}
    [EVAL] Map expr evaluated: {696a632bc1e2b9273264cc15 -> "696a632bc1e2b9273264cc09"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696a632bc1e2b9273264cc15"
    [EVAL] Set: {"696a632bc1e2b9273264cc15"}
    [EVAL] Element: 201
    [EVAL] Set: {"696a632bc1e2b9273264cc15"}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: customerEmail4 := "customer@example.com"
[SEE] Mapping base name 'customerEmail' -> 'customerEmail4'
  [EVAL] String: "customer@example.com"
[ASSIGN] Result: customerEmail4 := "customer@example.com"

[ASSIGN] Evaluating: customerPassword4 := "CustomerPass1!"
[SEE] Mapping base name 'customerPassword' -> 'customerPassword4'
  [EVAL] String: "CustomerPass1!"
[ASSIGN] Result: customerPassword4 := "CustomerPass1!"

[ASSIGN] Evaluating: customerFullName4 := "Test Customer"
[SEE] Mapping base name 'customerFullName' -> 'customerFullName4'
  [EVAL] String: "Test Customer"
[ASSIGN] Result: customerFullName4 := "Test Customer"

[ASSIGN] Evaluating: customerMobile4 := "5550000002"
[SEE] Mapping base name 'customerMobile' -> 'customerMobile4'
  [EVAL] String: "5550000002"
[ASSIGN] Result: customerMobile4 := "5550000002"
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_4 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_4'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {owner@example.com -> "restaurant_owner"}
  [API_CALL] Storing result in variable: tmp_Roles_4
[ASSIGN] Result: tmp_Roles_4 := {owner@example.com -> "restaurant_owner"}

[ASSIGN] Evaluating: Roles_old := tmp_Roles_4
  [EVAL] Var lookup: tmp_Roles_4
    [EVAL] Found in sigma: {owner@example.com -> "restaurant_owner"}
[ASSIGN] Result: Roles_old := {owner@example.com -> "restaurant_owner"}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_5 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_5'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {owner@example.com -> "OwnerPass1!"}
  [API_CALL] Storing result in variable: tmp_U_5
[ASSIGN] Result: tmp_U_5 := {owner@example.com -> "OwnerPass1!"}

[ASSIGN] Evaluating: U_old := tmp_U_5
  [EVAL] Var lookup: tmp_U_5
    [EVAL] Found in sigma: {owner@example.com -> "OwnerPass1!"}
[ASSIGN] Result: U_old := {owner@example.com -> "OwnerPass1!"}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_6 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_6'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {owner@example.com -> "OwnerPass1!"}
  [API_CALL] Storing result in variable: tmp_U_6
[ASSIGN] Result: tmp_U_6 := {owner@example.com -> "OwnerPass1!"}

[ASSUME] Evaluating: not_in(customerEmail, dom(tmp_U_6))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail4'
    [EVAL] Found in sigma: "customer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_6
    [EVAL] Found in sigma: {owner@example.com -> "OwnerPass1!"}
    [EVAL] Map expr evaluated: {owner@example.com -> "OwnerPass1!"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"owner@example.com"}
    [EVAL] not_in result: true (element not found)
[ASSUME] Adding constraint: true
[SEE] API call 'registerCustomer' ready for actual execution

[ASSIGN] Evaluating: _result4 := registerCustomer(customerEmail, customerPassword, customerFullName, customerMobile)
[SEE] Mapping base name '_result' -> '_result4'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail4'
    [EVAL] Found in sigma: "customer@example.com"
  [EVAL] Var lookup: customerPassword
    [EVAL] Resolved base name 'customerPassword' -> 'customerPassword4'
    [EVAL] Found in sigma: "CustomerPass1!"
  [EVAL] Var lookup: customerFullName
    [EVAL] Resolved base name 'customerFullName' -> 'customerFullName4'
    [EVAL] Found in sigma: "Test Customer"
  [EVAL] Var lookup: customerMobile
    [EVAL] Resolved base name 'customerMobile' -> 'customerMobile4'
    [EVAL] Found in sigma: "5550000002"
[API_CALL] Executing API function: registerCustomer
  [API_ARG] "customer@example.com"
  [API_ARG] "CustomerPass1!"
  [API_ARG] "Test Customer"
  [API_ARG] "5550000002"
  [API_CALL] Getting function from factory...
[Factory] Creating function: registerCustomer
  [API_CALL] Executing function...
[RegisterCustomerFunc] Registering customer: customer@example.com
[HttpClient] POST /api/auth/register -> 201
  [API_CALL] Function returned: 201
  [API_CALL] Storing result in variable: _result4
[ASSIGN] Result: _result4 := 201
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_7 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_7'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
  [API_CALL] Storing result in variable: tmp_U_7
[ASSIGN] Result: tmp_U_7 := {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_5 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_5'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
  [API_CALL] Storing result in variable: tmp_Roles_5
[ASSIGN] Result: tmp_Roles_5 := {customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}

[ASSERT] Evaluating: AND(=([](tmp_U_7, customerEmail), customerPassword), =([](tmp_Roles_5, customerEmail), CUSTOMER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: =([](tmp_U_7, customerEmail), customerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_7
    [EVAL] Found in sigma: {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail4'
    [EVAL] Found in sigma: "customer@example.com"
    [EVAL] Map expr evaluated: {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
    [EVAL] Key expr evaluated: "customer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "CustomerPass1!"
  [EVAL] Var lookup: customerPassword
    [EVAL] Resolved base name 'customerPassword' -> 'customerPassword4'
    [EVAL] Found in sigma: "CustomerPass1!"
    [EVAL] Eq result: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_5, customerEmail), CUSTOMER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_5
    [EVAL] Found in sigma: {customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail4'
    [EVAL] Found in sigma: "customer@example.com"
    [EVAL] Map expr evaluated: {customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
    [EVAL] Key expr evaluated: "customer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "customer"
  [EVAL] Var lookup: CUSTOMER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "customer" CUSTOMER)
    [EVAL] FuncCall result: AND(true, (= "customer" CUSTOMER))
[ASSERT] Result: AND(true, (= "customer" CUSTOMER))
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: customerEmail5 := "customer@example.com"
[SEE] Mapping base name 'customerEmail' -> 'customerEmail5'
  [EVAL] String: "customer@example.com"
[ASSIGN] Result: customerEmail5 := "customer@example.com"

[ASSIGN] Evaluating: customerPassword5 := "CustomerPass1!"
[SEE] Mapping base name 'customerPassword' -> 'customerPassword5'
  [EVAL] String: "CustomerPass1!"
[ASSIGN] Result: customerPassword5 := "CustomerPass1!"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_4 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_4'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [API_CALL] Storing result in variable: tmp_T_4
[ASSIGN] Result: tmp_T_4 := {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}

[ASSIGN] Evaluating: T_old := tmp_T_4
  [EVAL] Var lookup: tmp_T_4
    [EVAL] Found in sigma: {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
[ASSIGN] Result: T_old := {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_8 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_8'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
  [API_CALL] Storing result in variable: tmp_U_8
[ASSIGN] Result: tmp_U_8 := {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_9 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_9'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
  [API_CALL] Storing result in variable: tmp_U_9
[ASSIGN] Result: tmp_U_9 := {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}

[ASSUME] Evaluating: AND(in(customerEmail, dom(tmp_U_8)), =([](tmp_U_9, customerEmail), customerPassword))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(customerEmail, dom(tmp_U_8))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail5'
    [EVAL] Found in sigma: "customer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_8
    [EVAL] Found in sigma: {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
    [EVAL] Map expr evaluated: {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
    [EVAL] Domain has 2 keys
    [EVAL] Element: "customer@example.com"
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"customer@example.com", "owner@example.com"}
    [EVAL] Element: "customer@example.com"
    [EVAL] Set: {"customer@example.com", "owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_U_9, customerEmail), customerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_9
    [EVAL] Found in sigma: {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail5'
    [EVAL] Found in sigma: "customer@example.com"
    [EVAL] Map expr evaluated: {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
    [EVAL] Key expr evaluated: "customer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "CustomerPass1!"
  [EVAL] Var lookup: customerPassword
    [EVAL] Resolved base name 'customerPassword' -> 'customerPassword5'
    [EVAL] Found in sigma: "CustomerPass1!"
    [EVAL] Eq result: true
    [EVAL] Arg[1] result: true
    [EVAL] FuncCall result: AND(...) = true
[ASSUME] Adding constraint: true
[SEE] API call 'login' ready for actual execution

[ASSIGN] Evaluating: _result5 := login(customerEmail, customerPassword)
[SEE] Mapping base name '_result' -> '_result5'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail5'
    [EVAL] Found in sigma: "customer@example.com"
  [EVAL] Var lookup: customerPassword
    [EVAL] Resolved base name 'customerPassword' -> 'customerPassword5'
    [EVAL] Found in sigma: "CustomerPass1!"
[API_CALL] Executing API function: login
  [API_ARG] "customer@example.com"
  [API_ARG] "CustomerPass1!"
  [API_CALL] Getting function from factory...
[Factory] Creating function: login
  [API_CALL] Executing function...
[LoginFunc] Logging in: customer@example.com
[HttpClient] POST /api/auth/login -> 200
[LoginFunc] Token received for: customer@example.com
  [API_CALL] Function returned: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4"
  [API_CALL] Storing result in variable: _result5
[ASSIGN] Result: _result5 := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_5 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_5'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [API_CALL] Storing result in variable: tmp_T_5
[ASSIGN] Result: tmp_T_5 := {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}

[ASSERT] Evaluating: =([](tmp_T_5, customerEmail), _result5)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_T_5
    [EVAL] Found in sigma: {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail5'
    [EVAL] Found in sigma: "customer@example.com"
    [EVAL] Map expr evaluated: {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Key expr evaluated: "customer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4"
  [EVAL] Var lookup: _result5
    [EVAL] Found in sigma: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4"
    [EVAL] Eq result: true
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[ASSIGN] Evaluating: customerEmail6 := "customer@example.com"
[SEE] Mapping base name 'customerEmail' -> 'customerEmail6'
  [EVAL] String: "customer@example.com"
[ASSIGN] Result: customerEmail6 := "customer@example.com"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_6 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_6'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [API_CALL] Storing result in variable: tmp_T_6
[ASSIGN] Result: tmp_T_6 := {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}

[ASSUME] Evaluating: in(customerEmail, dom(tmp_T_6))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail6'
    [EVAL] Found in sigma: "customer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_6
    [EVAL] Found in sigma: {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Map expr evaluated: {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Domain has 2 keys
    [EVAL] Element: "customer@example.com"
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"customer@example.com", "owner@example.com"}
    [EVAL] Element: "customer@example.com"
    [EVAL] Set: {"customer@example.com", "owner@example.com"}
    [EVAL] Element found in set: true
[ASSUME] Adding constraint: true
[SEE] API call 'browseRestaurants' ready for actual execution

[ASSIGN] Evaluating: _result6 := browseRestaurants(customerEmail)
[SEE] Mapping base name '_result' -> '_result6'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail6'
    [EVAL] Found in sigma: "customer@example.com"
[API_CALL] Executing API function: browseRestaurants
  [API_ARG] "customer@example.com"
  [API_CALL] Getting function from factory...
[Factory] Creating function: browseRestaurants
  [API_CALL] Executing function...
[BrowseRestaurantsFunc] Fetching restaurants for customer@example.com
[BrowseRestaurantsFunc] Found 1 restaurants
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _result6
[ASSIGN] Result: _result6 := 200

[ASSERT] Empty assertion, PASSED

[ASSIGN] Evaluating: customerEmail7 := "customer@example.com"
[SEE] Mapping base name 'customerEmail' -> 'customerEmail7'
  [EVAL] String: "customer@example.com"
[ASSIGN] Result: customerEmail7 := "customer@example.com"

[ASSIGN] Evaluating: restaurantId7 := "__NEEDS_RESTAURANT_ID__"
[SEE] Mapping base name 'restaurantId' -> 'restaurantId7'
  [EVAL] String: "__NEEDS_RESTAURANT_ID__"
[ASSIGN] Result: restaurantId7 := "__NEEDS_RESTAURANT_ID__"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_7 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_7'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [API_CALL] Storing result in variable: tmp_T_7
[ASSIGN] Result: tmp_T_7 := {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
[SEE] API call 'get_R' ready for actual execution

[ASSIGN] Evaluating: tmp_R_3 := get_R()
[SEE] Mapping base name 'tmp_R_' -> 'tmp_R_3'
[API_CALL] Executing API function: get_R
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_R
  [API_CALL] Executing function...
[GetRFunc] Fetching R...
  [API_CALL] Function returned: {696a632bc1e2b9273264cc09 -> ""Test Restaurant""}
  [API_CALL] Storing result in variable: tmp_R_3
[ASSIGN] Result: tmp_R_3 := {696a632bc1e2b9273264cc09 -> ""Test Restaurant""}

[ASSUME] Evaluating: AND(in(customerEmail, dom(tmp_T_7)), in(restaurantId, dom(tmp_R_3)))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(customerEmail, dom(tmp_T_7))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail7'
    [EVAL] Found in sigma: "customer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_7
    [EVAL] Found in sigma: {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Map expr evaluated: {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Domain has 2 keys
    [EVAL] Element: "customer@example.com"
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"customer@example.com", "owner@example.com"}
    [EVAL] Element: "customer@example.com"
    [EVAL] Set: {"customer@example.com", "owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: in(restaurantId, dom(tmp_R_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId7'
    [EVAL] Found placeholder __NEEDS_RESTAURANT_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] tmp_R_0 is empty map
    [findKeyFromMapInSigma] Found tmp_R_1 with 1 entries, key: 696a632bc1e2b9273264cc09
    [findKeyFromMapInSigma] Found tmp_R_2 with 1 entries, key: 696a632bc1e2b9273264cc09
    [findKeyFromMapInSigma] Found tmp_R_3 with 1 entries, key: 696a632bc1e2b9273264cc09
    [EVAL] Resolved to: 696a632bc1e2b9273264cc09
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_R_3
    [EVAL] Found in sigma: {696a632bc1e2b9273264cc09 -> ""Test Restaurant""}
    [EVAL] Map expr evaluated: {696a632bc1e2b9273264cc09 -> ""Test Restaurant""}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696a632bc1e2b9273264cc09"
    [EVAL] Set: {"696a632bc1e2b9273264cc09"}
    [EVAL] Element: "696a632bc1e2b9273264cc09"
    [EVAL] Set: {"696a632bc1e2b9273264cc09"}
    [EVAL] Element found in set: true
    [EVAL] Arg[1] result: true
    [EVAL] FuncCall result: AND(...) = true
[ASSUME] Adding constraint: true
[SEE] API call 'viewMenu' ready for actual execution

[ASSIGN] Evaluating: _result7 := viewMenu(customerEmail, restaurantId)
[SEE] Mapping base name '_result' -> '_result7'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail7'
    [EVAL] Found in sigma: "customer@example.com"
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId7'
    [EVAL] Found in sigma: "696a632bc1e2b9273264cc09"
[API_CALL] Executing API function: viewMenu
  [API_ARG] "customer@example.com"
  [API_ARG] "696a632bc1e2b9273264cc09"
  [API_CALL] Getting function from factory...
[Factory] Creating function: viewMenu
  [API_CALL] Executing function...
[ViewMenuFunc] customer@example.com viewing menu for restaurant: 696a632bc1e2b9273264cc09
[ViewMenuFunc] Found 1 menu items
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _result7
[ASSIGN] Result: _result7 := 200

[ASSERT] Empty assertion, PASSED

[ASSIGN] Evaluating: customerEmail8 := "customer@example.com"
[SEE] Mapping base name 'customerEmail' -> 'customerEmail8'
  [EVAL] String: "customer@example.com"
[ASSIGN] Result: customerEmail8 := "customer@example.com"

[ASSIGN] Evaluating: menuItemId8 := "__NEEDS_MENUITEM_ID__"
[SEE] Mapping base name 'menuItemId' -> 'menuItemId8'
  [EVAL] String: "__NEEDS_MENUITEM_ID__"
[ASSIGN] Result: menuItemId8 := "__NEEDS_MENUITEM_ID__"

[ASSIGN] Evaluating: quantity8 := 2
[SEE] Mapping base name 'quantity' -> 'quantity8'
  [EVAL] Num: 2
[ASSIGN] Result: quantity8 := 2
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_0 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_0'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_0
[ASSIGN] Result: tmp_C_0 := {}

[ASSIGN] Evaluating: C_old := tmp_C_0
  [EVAL] Var lookup: tmp_C_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: C_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_8 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_8'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [API_CALL] Storing result in variable: tmp_T_8
[ASSIGN] Result: tmp_T_8 := {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_2 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_2'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
[GetMFunc] Menu item: 696a632bc1e2b9273264cc15 -> restaurant: 696a632bc1e2b9273264cc09
  [API_CALL] Function returned: {696a632bc1e2b9273264cc15 -> "696a632bc1e2b9273264cc09"}
  [API_CALL] Storing result in variable: tmp_M_2
[ASSIGN] Result: tmp_M_2 := {696a632bc1e2b9273264cc15 -> "696a632bc1e2b9273264cc09"}

[ASSUME] Evaluating: AND(in(customerEmail, dom(tmp_T_8)), in(menuItemId, dom(tmp_M_2)))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(customerEmail, dom(tmp_T_8))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail8'
    [EVAL] Found in sigma: "customer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_8
    [EVAL] Found in sigma: {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Map expr evaluated: {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Domain has 2 keys
    [EVAL] Element: "customer@example.com"
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"customer@example.com", "owner@example.com"}
    [EVAL] Element: "customer@example.com"
    [EVAL] Set: {"customer@example.com", "owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: in(menuItemId, dom(tmp_M_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: menuItemId
    [EVAL] Resolved base name 'menuItemId' -> 'menuItemId8'
    [EVAL] Found placeholder __NEEDS_MENUITEM_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_M_
    [findKeyFromMapInSigma] tmp_M_0 is empty map
    [findKeyFromMapInSigma] Found tmp_M_1 with 1 entries, key: 696a632bc1e2b9273264cc15
    [findKeyFromMapInSigma] Found tmp_M_2 with 1 entries, key: 696a632bc1e2b9273264cc15
    [EVAL] Resolved to: 696a632bc1e2b9273264cc15
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_M_2
    [EVAL] Found in sigma: {696a632bc1e2b9273264cc15 -> "696a632bc1e2b9273264cc09"}
    [EVAL] Map expr evaluated: {696a632bc1e2b9273264cc15 -> "696a632bc1e2b9273264cc09"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696a632bc1e2b9273264cc15"
    [EVAL] Set: {"696a632bc1e2b9273264cc15"}
    [EVAL] Element: "696a632bc1e2b9273264cc15"
    [EVAL] Set: {"696a632bc1e2b9273264cc15"}
    [EVAL] Element found in set: true
    [EVAL] Arg[1] result: true
    [EVAL] FuncCall result: AND(...) = true
[ASSUME] Adding constraint: true
[SEE] API call 'addToCart' ready for actual execution

[ASSIGN] Evaluating: _result8 := addToCart(customerEmail, menuItemId, quantity)
[SEE] Mapping base name '_result' -> '_result8'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail8'
    [EVAL] Found in sigma: "customer@example.com"
  [EVAL] Var lookup: menuItemId
    [EVAL] Resolved base name 'menuItemId' -> 'menuItemId8'
    [EVAL] Found in sigma: "696a632bc1e2b9273264cc15"
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity8'
    [EVAL] Found in sigma: 2
[API_CALL] Executing API function: addToCart
  [API_ARG] "customer@example.com"
  [API_ARG] "696a632bc1e2b9273264cc15"
  [API_ARG] 2
  [API_CALL] Getting function from factory...
[Factory] Creating function: addToCart
  [API_CALL] Executing function...
[AddToCartFunc] customer@example.com adding item 696a632bc1e2b9273264cc15 (qty: 2)
[HttpClient] POST /api/cart -> 200
[AddToCartFunc] Item added to cart
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _result8
[ASSIGN] Result: _result8 := 200
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_1 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_1'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C...
  [API_CALL] Function returned: {customer@example.com -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurantId":"696a632bc1e2b9273264cc09","totalAmount":300}"}
  [API_CALL] Storing result in variable: tmp_C_1
[ASSIGN] Result: tmp_C_1 := {customer@example.com -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurantId":"696a632bc1e2b9273264cc09","totalAmount":300}"}

[ASSERT] Evaluating: in(customerEmail, dom(tmp_C_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail8'
    [EVAL] Found in sigma: "customer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_1
    [EVAL] Found in sigma: {customer@example.com -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurantId":"696a632bc1e2b9273264cc09","totalAmount":300}"}
    [EVAL] Map expr evaluated: {customer@example.com -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurantId":"696a632bc1e2b9273264cc09","totalAmount":300}"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "customer@example.com"
    [EVAL] Set: {"customer@example.com"}
    [EVAL] Element: "customer@example.com"
    [EVAL] Set: {"customer@example.com"}
    [EVAL] Element found in set: true
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[ASSIGN] Evaluating: customerEmail9 := "customer@example.com"
[SEE] Mapping base name 'customerEmail' -> 'customerEmail9'
  [EVAL] String: "customer@example.com"
[ASSIGN] Result: customerEmail9 := "customer@example.com"

[ASSIGN] Evaluating: deliveryAddress9 := "456 Customer Lane, Apt 7"
[SEE] Mapping base name 'deliveryAddress' -> 'deliveryAddress9'
  [EVAL] String: "456 Customer Lane, Apt 7"
[ASSIGN] Result: deliveryAddress9 := "456 Customer Lane, Apt 7"

[ASSIGN] Evaluating: paymentMethod9 := "card"
[SEE] Mapping base name 'paymentMethod' -> 'paymentMethod9'
  [EVAL] String: "card"
[ASSIGN] Result: paymentMethod9 := "card"
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_2 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_2'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C...
  [API_CALL] Function returned: {customer@example.com -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurantId":"696a632bc1e2b9273264cc09","totalAmount":300}"}
  [API_CALL] Storing result in variable: tmp_C_2
[ASSIGN] Result: tmp_C_2 := {customer@example.com -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurantId":"696a632bc1e2b9273264cc09","totalAmount":300}"}

[ASSIGN] Evaluating: C_old := tmp_C_2
  [EVAL] Var lookup: tmp_C_2
    [EVAL] Found in sigma: {customer@example.com -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurantId":"696a632bc1e2b9273264cc09","totalAmount":300}"}
[ASSIGN] Result: C_old := {customer@example.com -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurantId":"696a632bc1e2b9273264cc09","totalAmount":300}"}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_0 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_0'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_0
[ASSIGN] Result: tmp_O_0 := {}

[ASSIGN] Evaluating: O_old := tmp_O_0
  [EVAL] Var lookup: tmp_O_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: O_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_9 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_9'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [API_CALL] Storing result in variable: tmp_T_9
[ASSIGN] Result: tmp_T_9 := {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_3 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_3'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C...
  [API_CALL] Function returned: {customer@example.com -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurantId":"696a632bc1e2b9273264cc09","totalAmount":300}"}
  [API_CALL] Storing result in variable: tmp_C_3
[ASSIGN] Result: tmp_C_3 := {customer@example.com -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurantId":"696a632bc1e2b9273264cc09","totalAmount":300}"}

[ASSUME] Evaluating: AND(in(customerEmail, dom(tmp_T_9)), in(customerEmail, dom(tmp_C_3)))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(customerEmail, dom(tmp_T_9))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail9'
    [EVAL] Found in sigma: "customer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_9
    [EVAL] Found in sigma: {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Map expr evaluated: {customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Domain has 2 keys
    [EVAL] Element: "customer@example.com"
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"customer@example.com", "owner@example.com"}
    [EVAL] Element: "customer@example.com"
    [EVAL] Set: {"customer@example.com", "owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: in(customerEmail, dom(tmp_C_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail9'
    [EVAL] Found in sigma: "customer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_3
    [EVAL] Found in sigma: {customer@example.com -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurantId":"696a632bc1e2b9273264cc09","totalAmount":300}"}
    [EVAL] Map expr evaluated: {customer@example.com -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurantId":"696a632bc1e2b9273264cc09","totalAmount":300}"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "customer@example.com"
    [EVAL] Set: {"customer@example.com"}
    [EVAL] Element: "customer@example.com"
    [EVAL] Set: {"customer@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[1] result: true
    [EVAL] FuncCall result: AND(...) = true
[ASSUME] Adding constraint: true
[SEE] API call 'placeOrder' ready for actual execution

[ASSIGN] Evaluating: _result9 := placeOrder(customerEmail, deliveryAddress, paymentMethod)
[SEE] Mapping base name '_result' -> '_result9'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail9'
    [EVAL] Found in sigma: "customer@example.com"
  [EVAL] Var lookup: deliveryAddress
    [EVAL] Resolved base name 'deliveryAddress' -> 'deliveryAddress9'
    [EVAL] Found in sigma: "456 Customer Lane, Apt 7"
  [EVAL] Var lookup: paymentMethod
    [EVAL] Resolved base name 'paymentMethod' -> 'paymentMethod9'
    [EVAL] Found in sigma: "card"
[API_CALL] Executing API function: placeOrder
  [API_ARG] "customer@example.com"
  [API_ARG] "456 Customer Lane, Apt 7"
  [API_ARG] "card"
  [API_CALL] Getting function from factory...
[Factory] Creating function: placeOrder
  [API_CALL] Executing function...
[PlaceOrderFunc] customer@example.com placing order...
[HttpClient] POST /api/orders -> 201
[PlaceOrderFunc] Order placed: 696a632bc1e2b9273264cc4d
  [API_CALL] Function returned: "696a632bc1e2b9273264cc4d"
  [API_CALL] Storing result in variable: _result9
[ASSIGN] Result: _result9 := "696a632bc1e2b9273264cc4d"
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_1 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_1'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O...
  [API_CALL] Function returned: {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"placed","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
  [API_CALL] Storing result in variable: tmp_O_1
[ASSIGN] Result: tmp_O_1 := {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"placed","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_4 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_4'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_4
[ASSIGN] Result: tmp_C_4 := {}

[ASSERT] Evaluating: AND(in(_result9, dom(tmp_O_1)), not_in(customerEmail, dom(tmp_C_4)))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(_result9, dom(tmp_O_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result9
    [EVAL] Found in sigma: "696a632bc1e2b9273264cc4d"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_1
    [EVAL] Found in sigma: {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"placed","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
    [EVAL] Map expr evaluated: {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"placed","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696a632bc1e2b9273264cc4d"
    [EVAL] Set: {"696a632bc1e2b9273264cc4d"}
    [EVAL] Element: "696a632bc1e2b9273264cc4d"
    [EVAL] Set: {"696a632bc1e2b9273264cc4d"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: not_in(customerEmail, dom(tmp_C_4))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail9'
    [EVAL] Found in sigma: "customer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_4
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
    [EVAL] Arg[1] result: true
    [EVAL] FuncCall result: AND(...) = true
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[ASSIGN] Evaluating: agentEmail10 := "agent@example.com"
[SEE] Mapping base name 'agentEmail' -> 'agentEmail10'
  [EVAL] String: "agent@example.com"
[ASSIGN] Result: agentEmail10 := "agent@example.com"

[ASSIGN] Evaluating: agentPassword10 := "AgentPass1!"
[SEE] Mapping base name 'agentPassword' -> 'agentPassword10'
  [EVAL] String: "AgentPass1!"
[ASSIGN] Result: agentPassword10 := "AgentPass1!"

[ASSIGN] Evaluating: agentFullName10 := "Test Agent"
[SEE] Mapping base name 'agentFullName' -> 'agentFullName10'
  [EVAL] String: "Test Agent"
[ASSIGN] Result: agentFullName10 := "Test Agent"

[ASSIGN] Evaluating: agentMobile10 := "5550000003"
[SEE] Mapping base name 'agentMobile' -> 'agentMobile10'
  [EVAL] String: "5550000003"
[ASSIGN] Result: agentMobile10 := "5550000003"
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_6 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_6'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
  [API_CALL] Storing result in variable: tmp_Roles_6
[ASSIGN] Result: tmp_Roles_6 := {customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}

[ASSIGN] Evaluating: Roles_old := tmp_Roles_6
  [EVAL] Var lookup: tmp_Roles_6
    [EVAL] Found in sigma: {customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
[ASSIGN] Result: Roles_old := {customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_10 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_10'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
  [API_CALL] Storing result in variable: tmp_U_10
[ASSIGN] Result: tmp_U_10 := {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}

[ASSIGN] Evaluating: U_old := tmp_U_10
  [EVAL] Var lookup: tmp_U_10
    [EVAL] Found in sigma: {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
[ASSIGN] Result: U_old := {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_11 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_11'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
  [API_CALL] Storing result in variable: tmp_U_11
[ASSIGN] Result: tmp_U_11 := {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}

[ASSUME] Evaluating: not_in(agentEmail, dom(tmp_U_11))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail10'
    [EVAL] Found in sigma: "agent@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_11
    [EVAL] Found in sigma: {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
    [EVAL] Map expr evaluated: {customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
    [EVAL] Domain has 2 keys
    [EVAL] Element: "customer@example.com"
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"customer@example.com", "owner@example.com"}
    [EVAL] not_in result: true (element not found)
[ASSUME] Adding constraint: true
[SEE] API call 'registerAgent' ready for actual execution

[ASSIGN] Evaluating: _result10 := registerAgent(agentEmail, agentPassword, agentFullName, agentMobile)
[SEE] Mapping base name '_result' -> '_result10'
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail10'
    [EVAL] Found in sigma: "agent@example.com"
  [EVAL] Var lookup: agentPassword
    [EVAL] Resolved base name 'agentPassword' -> 'agentPassword10'
    [EVAL] Found in sigma: "AgentPass1!"
  [EVAL] Var lookup: agentFullName
    [EVAL] Resolved base name 'agentFullName' -> 'agentFullName10'
    [EVAL] Found in sigma: "Test Agent"
  [EVAL] Var lookup: agentMobile
    [EVAL] Resolved base name 'agentMobile' -> 'agentMobile10'
    [EVAL] Found in sigma: "5550000003"
[API_CALL] Executing API function: registerAgent
  [API_ARG] "agent@example.com"
  [API_ARG] "AgentPass1!"
  [API_ARG] "Test Agent"
  [API_ARG] "5550000003"
  [API_CALL] Getting function from factory...
[Factory] Creating function: registerAgent
  [API_CALL] Executing function...
[RegisterAgentFunc] Registering agent: agent@example.com
[HttpClient] POST /api/auth/register -> 201
  [API_CALL] Function returned: 201
  [API_CALL] Storing result in variable: _result10
[ASSIGN] Result: _result10 := 201
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_12 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_12'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {agent@example.com -> "AgentPass1!", customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
  [API_CALL] Storing result in variable: tmp_U_12
[ASSIGN] Result: tmp_U_12 := {agent@example.com -> "AgentPass1!", customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_7 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_7'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
  [API_CALL] Storing result in variable: tmp_Roles_7
[ASSIGN] Result: tmp_Roles_7 := {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}

[ASSERT] Evaluating: AND(=([](tmp_U_12, agentEmail), agentPassword), =([](tmp_Roles_7, agentEmail), AGENT))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: =([](tmp_U_12, agentEmail), agentPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_12
    [EVAL] Found in sigma: {agent@example.com -> "AgentPass1!", customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail10'
    [EVAL] Found in sigma: "agent@example.com"
    [EVAL] Map expr evaluated: {agent@example.com -> "AgentPass1!", customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
    [EVAL] Key expr evaluated: "agent@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "AgentPass1!"
  [EVAL] Var lookup: agentPassword
    [EVAL] Resolved base name 'agentPassword' -> 'agentPassword10'
    [EVAL] Found in sigma: "AgentPass1!"
    [EVAL] Eq result: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_7, agentEmail), AGENT)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_7
    [EVAL] Found in sigma: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail10'
    [EVAL] Found in sigma: "agent@example.com"
    [EVAL] Map expr evaluated: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
    [EVAL] Key expr evaluated: "agent@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "delivery_agent"
  [EVAL] Var lookup: AGENT
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "delivery_agent" AGENT)
    [EVAL] FuncCall result: AND(true, (= "delivery_agent" AGENT))
[ASSERT] Result: AND(true, (= "delivery_agent" AGENT))
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: agentEmail11 := "agent@example.com"
[SEE] Mapping base name 'agentEmail' -> 'agentEmail11'
  [EVAL] String: "agent@example.com"
[ASSIGN] Result: agentEmail11 := "agent@example.com"

[ASSIGN] Evaluating: agentPassword11 := "AgentPass1!"
[SEE] Mapping base name 'agentPassword' -> 'agentPassword11'
  [EVAL] String: "AgentPass1!"
[ASSIGN] Result: agentPassword11 := "AgentPass1!"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_10 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_10'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [API_CALL] Storing result in variable: tmp_T_10
[ASSIGN] Result: tmp_T_10 := {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}

[ASSIGN] Evaluating: T_old := tmp_T_10
  [EVAL] Var lookup: tmp_T_10
    [EVAL] Found in sigma: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
[ASSIGN] Result: T_old := {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_13 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_13'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {agent@example.com -> "AgentPass1!", customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
  [API_CALL] Storing result in variable: tmp_U_13
[ASSIGN] Result: tmp_U_13 := {agent@example.com -> "AgentPass1!", customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_14 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_14'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {agent@example.com -> "AgentPass1!", customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
  [API_CALL] Storing result in variable: tmp_U_14
[ASSIGN] Result: tmp_U_14 := {agent@example.com -> "AgentPass1!", customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}

[ASSUME] Evaluating: AND(in(agentEmail, dom(tmp_U_13)), =([](tmp_U_14, agentEmail), agentPassword))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(agentEmail, dom(tmp_U_13))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail11'
    [EVAL] Found in sigma: "agent@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_13
    [EVAL] Found in sigma: {agent@example.com -> "AgentPass1!", customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
    [EVAL] Map expr evaluated: {agent@example.com -> "AgentPass1!", customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
    [EVAL] Domain has 3 keys
    [EVAL] Element: "agent@example.com"
    [EVAL] Element: "customer@example.com"
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"agent@example.com", "customer@example.com", "owner@example.com"}
    [EVAL] Element: "agent@example.com"
    [EVAL] Set: {"agent@example.com", "customer@example.com", "owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_U_14, agentEmail), agentPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_14
    [EVAL] Found in sigma: {agent@example.com -> "AgentPass1!", customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail11'
    [EVAL] Found in sigma: "agent@example.com"
    [EVAL] Map expr evaluated: {agent@example.com -> "AgentPass1!", customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
    [EVAL] Key expr evaluated: "agent@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "AgentPass1!"
  [EVAL] Var lookup: agentPassword
    [EVAL] Resolved base name 'agentPassword' -> 'agentPassword11'
    [EVAL] Found in sigma: "AgentPass1!"
    [EVAL] Eq result: true
    [EVAL] Arg[1] result: true
    [EVAL] FuncCall result: AND(...) = true
[ASSUME] Adding constraint: true
[SEE] API call 'login' ready for actual execution

[ASSIGN] Evaluating: _result11 := login(agentEmail, agentPassword)
[SEE] Mapping base name '_result' -> '_result11'
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail11'
    [EVAL] Found in sigma: "agent@example.com"
  [EVAL] Var lookup: agentPassword
    [EVAL] Resolved base name 'agentPassword' -> 'agentPassword11'
    [EVAL] Found in sigma: "AgentPass1!"
[API_CALL] Executing API function: login
  [API_ARG] "agent@example.com"
  [API_ARG] "AgentPass1!"
  [API_CALL] Getting function from factory...
[Factory] Creating function: login
  [API_CALL] Executing function...
[LoginFunc] Logging in: agent@example.com
[HttpClient] POST /api/auth/login -> 200
[LoginFunc] Token received for: agent@example.com
  [API_CALL] Function returned: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY"
  [API_CALL] Storing result in variable: _result11
[ASSIGN] Result: _result11 := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_11 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_11'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [API_CALL] Storing result in variable: tmp_T_11
[ASSIGN] Result: tmp_T_11 := {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}

[ASSERT] Evaluating: =([](tmp_T_11, agentEmail), _result11)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_T_11
    [EVAL] Found in sigma: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail11'
    [EVAL] Found in sigma: "agent@example.com"
    [EVAL] Map expr evaluated: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Key expr evaluated: "agent@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY"
  [EVAL] Var lookup: _result11
    [EVAL] Found in sigma: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY"
    [EVAL] Eq result: true
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[ASSIGN] Evaluating: ownerEmail12 := "owner@example.com"
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail12'
  [EVAL] String: "owner@example.com"
[ASSIGN] Result: ownerEmail12 := "owner@example.com"

[ASSIGN] Evaluating: orderId12 := "__NEEDS_ORDER_ID__"
[SEE] Mapping base name 'orderId' -> 'orderId12'
  [EVAL] String: "__NEEDS_ORDER_ID__"
[ASSIGN] Result: orderId12 := "__NEEDS_ORDER_ID__"

[ASSIGN] Evaluating: orderStatus12 := "accepted"
[SEE] Mapping base name 'orderStatus' -> 'orderStatus12'
  [EVAL] String: "accepted"
[ASSIGN] Result: orderStatus12 := "accepted"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_12 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_12'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [API_CALL] Storing result in variable: tmp_T_12
[ASSIGN] Result: tmp_T_12 := {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_8 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_8'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
  [API_CALL] Storing result in variable: tmp_Roles_8
[ASSIGN] Result: tmp_Roles_8 := {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_2 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_2'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O...
  [API_CALL] Function returned: {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"placed","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
  [API_CALL] Storing result in variable: tmp_O_2
[ASSIGN] Result: tmp_O_2 := {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"placed","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_12)), =([](tmp_Roles_8, ownerEmail), OWNER), in(orderId, dom(tmp_O_2)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_12))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail12'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_12
    [EVAL] Found in sigma: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Map expr evaluated: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Domain has 3 keys
    [EVAL] Element: "agent@example.com"
    [EVAL] Element: "customer@example.com"
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"agent@example.com", "customer@example.com", "owner@example.com"}
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"agent@example.com", "customer@example.com", "owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_8, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_8
    [EVAL] Found in sigma: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail12'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Map expr evaluated: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
    [EVAL] Key expr evaluated: "owner@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "restaurant_owner"
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "restaurant_owner" OWNER)
    [EVAL] Arg[2]: in(orderId, dom(tmp_O_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId12'
    [EVAL] Found placeholder __NEEDS_ORDER_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] Found tmp_O_1 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_2 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [EVAL] Resolved to: 696a632bc1e2b9273264cc4d
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_2
    [EVAL] Found in sigma: {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"placed","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
    [EVAL] Map expr evaluated: {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"placed","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696a632bc1e2b9273264cc4d"
    [EVAL] Set: {"696a632bc1e2b9273264cc4d"}
    [EVAL] Element: "696a632bc1e2b9273264cc4d"
    [EVAL] Set: {"696a632bc1e2b9273264cc4d"}
    [EVAL] Element found in set: true
    [EVAL] Arg[2] result: true
    [EVAL] FuncCall result: AND(true, (= "restaurant_owner" OWNER), true)
[ASSUME] Adding constraint: AND(true, (= "restaurant_owner" OWNER), true)
[SEE] API call 'updateOrderStatusOwner' ready for actual execution

[ASSIGN] Evaluating: _result12 := updateOrderStatusOwner(ownerEmail, orderId, orderStatus)
[SEE] Mapping base name '_result' -> '_result12'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail12'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId12'
    [EVAL] Found in sigma: "696a632bc1e2b9273264cc4d"
  [EVAL] Var lookup: orderStatus
    [EVAL] Resolved base name 'orderStatus' -> 'orderStatus12'
    [EVAL] Found in sigma: "accepted"
[API_CALL] Executing API function: updateOrderStatusOwner
  [API_ARG] "owner@example.com"
  [API_ARG] "696a632bc1e2b9273264cc4d"
  [API_ARG] "accepted"
  [API_CALL] Getting function from factory...
[Factory] Creating function: updateOrderStatusOwner
  [API_CALL] Executing function...
[UpdateOrderStatusOwnerFunc] owner@example.com updating order 696a632bc1e2b9273264cc4d to accepted
[UpdateOrderStatusOwnerFunc] Order status updated
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _result12
[ASSIGN] Result: _result12 := 200

[ASSERT] Empty assertion, PASSED

[ASSIGN] Evaluating: ownerEmail13 := "owner@example.com"
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail13'
  [EVAL] String: "owner@example.com"
[ASSIGN] Result: ownerEmail13 := "owner@example.com"

[ASSIGN] Evaluating: orderId13 := "__NEEDS_ORDER_ID__"
[SEE] Mapping base name 'orderId' -> 'orderId13'
  [EVAL] String: "__NEEDS_ORDER_ID__"
[ASSIGN] Result: orderId13 := "__NEEDS_ORDER_ID__"

[ASSIGN] Evaluating: orderStatus13 := "preparing"
[SEE] Mapping base name 'orderStatus' -> 'orderStatus13'
  [EVAL] String: "preparing"
[ASSIGN] Result: orderStatus13 := "preparing"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_13 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_13'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [API_CALL] Storing result in variable: tmp_T_13
[ASSIGN] Result: tmp_T_13 := {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_9 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_9'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
  [API_CALL] Storing result in variable: tmp_Roles_9
[ASSIGN] Result: tmp_Roles_9 := {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_3 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_3'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O...
  [API_CALL] Function returned: {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"accepted","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
  [API_CALL] Storing result in variable: tmp_O_3
[ASSIGN] Result: tmp_O_3 := {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"accepted","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_13)), =([](tmp_Roles_9, ownerEmail), OWNER), in(orderId, dom(tmp_O_3)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_13))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail13'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_13
    [EVAL] Found in sigma: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Map expr evaluated: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Domain has 3 keys
    [EVAL] Element: "agent@example.com"
    [EVAL] Element: "customer@example.com"
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"agent@example.com", "customer@example.com", "owner@example.com"}
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"agent@example.com", "customer@example.com", "owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_9, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_9
    [EVAL] Found in sigma: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail13'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Map expr evaluated: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
    [EVAL] Key expr evaluated: "owner@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "restaurant_owner"
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "restaurant_owner" OWNER)
    [EVAL] Arg[2]: in(orderId, dom(tmp_O_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId13'
    [EVAL] Found placeholder __NEEDS_ORDER_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] Found tmp_O_1 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_2 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_3 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [EVAL] Resolved to: 696a632bc1e2b9273264cc4d
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_3
    [EVAL] Found in sigma: {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"accepted","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
    [EVAL] Map expr evaluated: {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"accepted","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696a632bc1e2b9273264cc4d"
    [EVAL] Set: {"696a632bc1e2b9273264cc4d"}
    [EVAL] Element: "696a632bc1e2b9273264cc4d"
    [EVAL] Set: {"696a632bc1e2b9273264cc4d"}
    [EVAL] Element found in set: true
    [EVAL] Arg[2] result: true
    [EVAL] FuncCall result: AND(true, (= "restaurant_owner" OWNER), true)
[ASSUME] Adding constraint: AND(true, (= "restaurant_owner" OWNER), true)
[SEE] API call 'updateOrderStatusOwner' ready for actual execution

[ASSIGN] Evaluating: _result13 := updateOrderStatusOwner(ownerEmail, orderId, orderStatus)
[SEE] Mapping base name '_result' -> '_result13'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail13'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId13'
    [EVAL] Found in sigma: "696a632bc1e2b9273264cc4d"
  [EVAL] Var lookup: orderStatus
    [EVAL] Resolved base name 'orderStatus' -> 'orderStatus13'
    [EVAL] Found in sigma: "preparing"
[API_CALL] Executing API function: updateOrderStatusOwner
  [API_ARG] "owner@example.com"
  [API_ARG] "696a632bc1e2b9273264cc4d"
  [API_ARG] "preparing"
  [API_CALL] Getting function from factory...
[Factory] Creating function: updateOrderStatusOwner
  [API_CALL] Executing function...
[UpdateOrderStatusOwnerFunc] owner@example.com updating order 696a632bc1e2b9273264cc4d to preparing
[UpdateOrderStatusOwnerFunc] Order status updated
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _result13
[ASSIGN] Result: _result13 := 200

[ASSERT] Empty assertion, PASSED

[ASSIGN] Evaluating: ownerEmail14 := "owner@example.com"
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail14'
  [EVAL] String: "owner@example.com"
[ASSIGN] Result: ownerEmail14 := "owner@example.com"

[ASSIGN] Evaluating: orderId14 := "__NEEDS_ORDER_ID__"
[SEE] Mapping base name 'orderId' -> 'orderId14'
  [EVAL] String: "__NEEDS_ORDER_ID__"
[ASSIGN] Result: orderId14 := "__NEEDS_ORDER_ID__"

[ASSIGN] Evaluating: orderStatus14 := "ready"
[SEE] Mapping base name 'orderStatus' -> 'orderStatus14'
  [EVAL] String: "ready"
[ASSIGN] Result: orderStatus14 := "ready"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_14 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_14'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [API_CALL] Storing result in variable: tmp_T_14
[ASSIGN] Result: tmp_T_14 := {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_10 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_10'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
  [API_CALL] Storing result in variable: tmp_Roles_10
[ASSIGN] Result: tmp_Roles_10 := {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_4 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_4'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O...
  [API_CALL] Function returned: {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"preparing","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
  [API_CALL] Storing result in variable: tmp_O_4
[ASSIGN] Result: tmp_O_4 := {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"preparing","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_14)), =([](tmp_Roles_10, ownerEmail), OWNER), in(orderId, dom(tmp_O_4)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_14))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail14'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_14
    [EVAL] Found in sigma: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Map expr evaluated: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Domain has 3 keys
    [EVAL] Element: "agent@example.com"
    [EVAL] Element: "customer@example.com"
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"agent@example.com", "customer@example.com", "owner@example.com"}
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"agent@example.com", "customer@example.com", "owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_10, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_10
    [EVAL] Found in sigma: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail14'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Map expr evaluated: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
    [EVAL] Key expr evaluated: "owner@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "restaurant_owner"
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "restaurant_owner" OWNER)
    [EVAL] Arg[2]: in(orderId, dom(tmp_O_4))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId14'
    [EVAL] Found placeholder __NEEDS_ORDER_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] Found tmp_O_1 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_2 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_3 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_4 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [EVAL] Resolved to: 696a632bc1e2b9273264cc4d
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_4
    [EVAL] Found in sigma: {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"preparing","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
    [EVAL] Map expr evaluated: {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"preparing","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696a632bc1e2b9273264cc4d"
    [EVAL] Set: {"696a632bc1e2b9273264cc4d"}
    [EVAL] Element: "696a632bc1e2b9273264cc4d"
    [EVAL] Set: {"696a632bc1e2b9273264cc4d"}
    [EVAL] Element found in set: true
    [EVAL] Arg[2] result: true
    [EVAL] FuncCall result: AND(true, (= "restaurant_owner" OWNER), true)
[ASSUME] Adding constraint: AND(true, (= "restaurant_owner" OWNER), true)
[SEE] API call 'updateOrderStatusOwner' ready for actual execution

[ASSIGN] Evaluating: _result14 := updateOrderStatusOwner(ownerEmail, orderId, orderStatus)
[SEE] Mapping base name '_result' -> '_result14'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail14'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId14'
    [EVAL] Found in sigma: "696a632bc1e2b9273264cc4d"
  [EVAL] Var lookup: orderStatus
    [EVAL] Resolved base name 'orderStatus' -> 'orderStatus14'
    [EVAL] Found in sigma: "ready"
[API_CALL] Executing API function: updateOrderStatusOwner
  [API_ARG] "owner@example.com"
  [API_ARG] "696a632bc1e2b9273264cc4d"
  [API_ARG] "ready"
  [API_CALL] Getting function from factory...
[Factory] Creating function: updateOrderStatusOwner
  [API_CALL] Executing function...
[UpdateOrderStatusOwnerFunc] owner@example.com updating order 696a632bc1e2b9273264cc4d to ready
[UpdateOrderStatusOwnerFunc] Order status updated
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _result14
[ASSIGN] Result: _result14 := 200

[ASSERT] Empty assertion, PASSED

[ASSIGN] Evaluating: ownerEmail15 := "owner@example.com"
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail15'
  [EVAL] String: "owner@example.com"
[ASSIGN] Result: ownerEmail15 := "owner@example.com"

[ASSIGN] Evaluating: orderId15 := "__NEEDS_ORDER_ID__"
[SEE] Mapping base name 'orderId' -> 'orderId15'
  [EVAL] String: "__NEEDS_ORDER_ID__"
[ASSIGN] Result: orderId15 := "__NEEDS_ORDER_ID__"

[ASSIGN] Evaluating: agentEmail15 := "agent@example.com"
[SEE] Mapping base name 'agentEmail' -> 'agentEmail15'
  [EVAL] String: "agent@example.com"
[ASSIGN] Result: agentEmail15 := "agent@example.com"
[SEE] API call 'get_Assignments' ready for actual execution

[ASSIGN] Evaluating: tmp_Assignments_0 := get_Assignments()
[SEE] Mapping base name 'tmp_Assignments_' -> 'tmp_Assignments_0'
[API_CALL] Executing API function: get_Assignments
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Assignments
  [API_CALL] Executing function...
[GetAssignmentsFunc] Fetching Assignments...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Assignments_0
[ASSIGN] Result: tmp_Assignments_0 := {}

[ASSIGN] Evaluating: Assignments_old := tmp_Assignments_0
  [EVAL] Var lookup: tmp_Assignments_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Assignments_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_15 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_15'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [API_CALL] Storing result in variable: tmp_T_15
[ASSIGN] Result: tmp_T_15 := {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_11 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_11'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
  [API_CALL] Storing result in variable: tmp_Roles_11
[ASSIGN] Result: tmp_Roles_11 := {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_5 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_5'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O...
  [API_CALL] Function returned: {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"ready","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
  [API_CALL] Storing result in variable: tmp_O_5
[ASSIGN] Result: tmp_O_5 := {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"ready","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_15 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_15'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {agent@example.com -> "AgentPass1!", customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
  [API_CALL] Storing result in variable: tmp_U_15
[ASSIGN] Result: tmp_U_15 := {agent@example.com -> "AgentPass1!", customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_12 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_12'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
  [API_CALL] Storing result in variable: tmp_Roles_12
[ASSIGN] Result: tmp_Roles_12 := {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_15)), =([](tmp_Roles_11, ownerEmail), OWNER), in(orderId, dom(tmp_O_5)), in(agentEmail, dom(tmp_U_15)), =([](tmp_Roles_12, agentEmail), AGENT))
  [EVAL] FuncCall: AND with 5 args
    [EVAL] N-ary AND with 5 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_15))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail15'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_15
    [EVAL] Found in sigma: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Map expr evaluated: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Domain has 3 keys
    [EVAL] Element: "agent@example.com"
    [EVAL] Element: "customer@example.com"
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"agent@example.com", "customer@example.com", "owner@example.com"}
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"agent@example.com", "customer@example.com", "owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_11, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_11
    [EVAL] Found in sigma: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail15'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Map expr evaluated: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
    [EVAL] Key expr evaluated: "owner@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "restaurant_owner"
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "restaurant_owner" OWNER)
    [EVAL] Arg[2]: in(orderId, dom(tmp_O_5))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId15'
    [EVAL] Found placeholder __NEEDS_ORDER_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] Found tmp_O_1 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_2 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_3 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_4 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_5 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [EVAL] Resolved to: 696a632bc1e2b9273264cc4d
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_5
    [EVAL] Found in sigma: {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"ready","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
    [EVAL] Map expr evaluated: {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"ready","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696a632bc1e2b9273264cc4d"
    [EVAL] Set: {"696a632bc1e2b9273264cc4d"}
    [EVAL] Element: "696a632bc1e2b9273264cc4d"
    [EVAL] Set: {"696a632bc1e2b9273264cc4d"}
    [EVAL] Element found in set: true
    [EVAL] Arg[2] result: true
    [EVAL] Arg[3]: in(agentEmail, dom(tmp_U_15))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail15'
    [EVAL] Found in sigma: "agent@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_15
    [EVAL] Found in sigma: {agent@example.com -> "AgentPass1!", customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
    [EVAL] Map expr evaluated: {agent@example.com -> "AgentPass1!", customer@example.com -> "CustomerPass1!", owner@example.com -> "OwnerPass1!"}
    [EVAL] Domain has 3 keys
    [EVAL] Element: "agent@example.com"
    [EVAL] Element: "customer@example.com"
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"agent@example.com", "customer@example.com", "owner@example.com"}
    [EVAL] Element: "agent@example.com"
    [EVAL] Set: {"agent@example.com", "customer@example.com", "owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[3] result: true
    [EVAL] Arg[4]: =([](tmp_Roles_12, agentEmail), AGENT)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_12
    [EVAL] Found in sigma: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail15'
    [EVAL] Found in sigma: "agent@example.com"
    [EVAL] Map expr evaluated: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
    [EVAL] Key expr evaluated: "agent@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "delivery_agent"
  [EVAL] Var lookup: AGENT
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[4] result: (= "delivery_agent" AGENT)
    [EVAL] FuncCall result: AND(true, (= "restaurant_owner" OWNER), true, true, (= "delivery_agent" AGENT))
[ASSUME] Adding constraint: AND(true, (= "restaurant_owner" OWNER), true, true, (= "delivery_agent" AGENT))
[SEE] API call 'assignOrder' ready for actual execution

[ASSIGN] Evaluating: _result15 := assignOrder(ownerEmail, orderId, agentEmail)
[SEE] Mapping base name '_result' -> '_result15'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail15'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId15'
    [EVAL] Found in sigma: "696a632bc1e2b9273264cc4d"
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail15'
    [EVAL] Found in sigma: "agent@example.com"
[API_CALL] Executing API function: assignOrder
  [API_ARG] "owner@example.com"
  [API_ARG] "696a632bc1e2b9273264cc4d"
  [API_ARG] "agent@example.com"
  [API_CALL] Getting function from factory...
[Factory] Creating function: assignOrder
  [API_CALL] Executing function...
[AssignOrderFunc] owner@example.com assigning order 696a632bc1e2b9273264cc4d to agent agent@example.com
[AssignOrderFunc] Found agent ID: 696a632bc1e2b9273264cc5d for email: agent@example.com
[AssignOrderFunc] Order assigned successfully
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _result15
[ASSIGN] Result: _result15 := 200
[SEE] API call 'get_Assignments' ready for actual execution

[ASSIGN] Evaluating: tmp_Assignments_1 := get_Assignments()
[SEE] Mapping base name 'tmp_Assignments_' -> 'tmp_Assignments_1'
[API_CALL] Executing API function: get_Assignments
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Assignments
  [API_CALL] Executing function...
[GetAssignmentsFunc] Fetching Assignments...
  [API_CALL] Function returned: {696a632bc1e2b9273264cc4d -> "agent@example.com"}
  [API_CALL] Storing result in variable: tmp_Assignments_1
[ASSIGN] Result: tmp_Assignments_1 := {696a632bc1e2b9273264cc4d -> "agent@example.com"}

[ASSERT] Evaluating: =([](tmp_Assignments_1, orderId), agentEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Assignments_1
    [EVAL] Found in sigma: {696a632bc1e2b9273264cc4d -> "agent@example.com"}
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId15'
    [EVAL] Found in sigma: "696a632bc1e2b9273264cc4d"
    [EVAL] Map expr evaluated: {696a632bc1e2b9273264cc4d -> "agent@example.com"}
    [EVAL] Key expr evaluated: "696a632bc1e2b9273264cc4d"
    [EVAL] Key found in map, returning value
  [EVAL] String: "agent@example.com"
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail15'
    [EVAL] Found in sigma: "agent@example.com"
    [EVAL] Eq result: true
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[ASSIGN] Evaluating: agentEmail16 := "agent@example.com"
[SEE] Mapping base name 'agentEmail' -> 'agentEmail16'
  [EVAL] String: "agent@example.com"
[ASSIGN] Result: agentEmail16 := "agent@example.com"

[ASSIGN] Evaluating: orderId16 := "__NEEDS_ORDER_ID__"
[SEE] Mapping base name 'orderId' -> 'orderId16'
  [EVAL] String: "__NEEDS_ORDER_ID__"
[ASSIGN] Result: orderId16 := "__NEEDS_ORDER_ID__"

[ASSIGN] Evaluating: orderStatus16 := "picked_up"
[SEE] Mapping base name 'orderStatus' -> 'orderStatus16'
  [EVAL] String: "picked_up"
[ASSIGN] Result: orderStatus16 := "picked_up"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_16 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_16'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [API_CALL] Storing result in variable: tmp_T_16
[ASSIGN] Result: tmp_T_16 := {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_13 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_13'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
  [API_CALL] Storing result in variable: tmp_Roles_13
[ASSIGN] Result: tmp_Roles_13 := {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
[SEE] API call 'get_Assignments' ready for actual execution

[ASSIGN] Evaluating: tmp_Assignments_2 := get_Assignments()
[SEE] Mapping base name 'tmp_Assignments_' -> 'tmp_Assignments_2'
[API_CALL] Executing API function: get_Assignments
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Assignments
  [API_CALL] Executing function...
[GetAssignmentsFunc] Fetching Assignments...
  [API_CALL] Function returned: {696a632bc1e2b9273264cc4d -> "agent@example.com"}
  [API_CALL] Storing result in variable: tmp_Assignments_2
[ASSIGN] Result: tmp_Assignments_2 := {696a632bc1e2b9273264cc4d -> "agent@example.com"}
[SEE] API call 'get_Assignments' ready for actual execution

[ASSIGN] Evaluating: tmp_Assignments_3 := get_Assignments()
[SEE] Mapping base name 'tmp_Assignments_' -> 'tmp_Assignments_3'
[API_CALL] Executing API function: get_Assignments
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Assignments
  [API_CALL] Executing function...
[GetAssignmentsFunc] Fetching Assignments...
  [API_CALL] Function returned: {696a632bc1e2b9273264cc4d -> "agent@example.com"}
  [API_CALL] Storing result in variable: tmp_Assignments_3
[ASSIGN] Result: tmp_Assignments_3 := {696a632bc1e2b9273264cc4d -> "agent@example.com"}

[ASSUME] Evaluating: AND(in(agentEmail, dom(tmp_T_16)), =([](tmp_Roles_13, agentEmail), AGENT), in(orderId, dom(tmp_Assignments_2)), =([](tmp_Assignments_3, orderId), agentEmail))
  [EVAL] FuncCall: AND with 4 args
    [EVAL] N-ary AND with 4 args
    [EVAL] Arg[0]: in(agentEmail, dom(tmp_T_16))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail16'
    [EVAL] Found in sigma: "agent@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_16
    [EVAL] Found in sigma: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Map expr evaluated: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Domain has 3 keys
    [EVAL] Element: "agent@example.com"
    [EVAL] Element: "customer@example.com"
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"agent@example.com", "customer@example.com", "owner@example.com"}
    [EVAL] Element: "agent@example.com"
    [EVAL] Set: {"agent@example.com", "customer@example.com", "owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_13, agentEmail), AGENT)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_13
    [EVAL] Found in sigma: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail16'
    [EVAL] Found in sigma: "agent@example.com"
    [EVAL] Map expr evaluated: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
    [EVAL] Key expr evaluated: "agent@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "delivery_agent"
  [EVAL] Var lookup: AGENT
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "delivery_agent" AGENT)
    [EVAL] Arg[2]: in(orderId, dom(tmp_Assignments_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId16'
    [EVAL] Found placeholder __NEEDS_ORDER_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] Found tmp_O_1 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_2 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_3 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_4 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_5 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [EVAL] Resolved to: 696a632bc1e2b9273264cc4d
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_Assignments_2
    [EVAL] Found in sigma: {696a632bc1e2b9273264cc4d -> "agent@example.com"}
    [EVAL] Map expr evaluated: {696a632bc1e2b9273264cc4d -> "agent@example.com"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696a632bc1e2b9273264cc4d"
    [EVAL] Set: {"696a632bc1e2b9273264cc4d"}
    [EVAL] Element: "696a632bc1e2b9273264cc4d"
    [EVAL] Set: {"696a632bc1e2b9273264cc4d"}
    [EVAL] Element found in set: true
    [EVAL] Arg[2] result: true
    [EVAL] Arg[3]: =([](tmp_Assignments_3, orderId), agentEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Assignments_3
    [EVAL] Found in sigma: {696a632bc1e2b9273264cc4d -> "agent@example.com"}
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId16'
    [EVAL] Found in sigma: "696a632bc1e2b9273264cc4d"
    [EVAL] Map expr evaluated: {696a632bc1e2b9273264cc4d -> "agent@example.com"}
    [EVAL] Key expr evaluated: "696a632bc1e2b9273264cc4d"
    [EVAL] Key found in map, returning value
  [EVAL] String: "agent@example.com"
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail16'
    [EVAL] Found in sigma: "agent@example.com"
    [EVAL] Eq result: true
    [EVAL] Arg[3] result: true
    [EVAL] FuncCall result: AND(true, (= "delivery_agent" AGENT), true, true)
[ASSUME] Adding constraint: AND(true, (= "delivery_agent" AGENT), true, true)
[SEE] API call 'updateOrderStatusAgent' ready for actual execution

[ASSIGN] Evaluating: _result16 := updateOrderStatusAgent(agentEmail, orderId, orderStatus)
[SEE] Mapping base name '_result' -> '_result16'
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail16'
    [EVAL] Found in sigma: "agent@example.com"
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId16'
    [EVAL] Found in sigma: "696a632bc1e2b9273264cc4d"
  [EVAL] Var lookup: orderStatus
    [EVAL] Resolved base name 'orderStatus' -> 'orderStatus16'
    [EVAL] Found in sigma: "picked_up"
[API_CALL] Executing API function: updateOrderStatusAgent
  [API_ARG] "agent@example.com"
  [API_ARG] "696a632bc1e2b9273264cc4d"
  [API_ARG] "picked_up"
  [API_CALL] Getting function from factory...
[Factory] Creating function: updateOrderStatusAgent
  [API_CALL] Executing function...
[UpdateOrderStatusAgentFunc] agent@example.com updating order 696a632bc1e2b9273264cc4d to picked_up
[UpdateOrderStatusAgentFunc] Order status updated
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _result16
[ASSIGN] Result: _result16 := 200

[ASSERT] Empty assertion, PASSED

[ASSIGN] Evaluating: agentEmail17 := "agent@example.com"
[SEE] Mapping base name 'agentEmail' -> 'agentEmail17'
  [EVAL] String: "agent@example.com"
[ASSIGN] Result: agentEmail17 := "agent@example.com"

[ASSIGN] Evaluating: orderId17 := "__NEEDS_ORDER_ID__"
[SEE] Mapping base name 'orderId' -> 'orderId17'
  [EVAL] String: "__NEEDS_ORDER_ID__"
[ASSIGN] Result: orderId17 := "__NEEDS_ORDER_ID__"

[ASSIGN] Evaluating: orderStatus17 := "delivered"
[SEE] Mapping base name 'orderStatus' -> 'orderStatus17'
  [EVAL] String: "delivered"
[ASSIGN] Result: orderStatus17 := "delivered"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_17 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_17'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [API_CALL] Storing result in variable: tmp_T_17
[ASSIGN] Result: tmp_T_17 := {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_14 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_14'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
  [API_CALL] Storing result in variable: tmp_Roles_14
[ASSIGN] Result: tmp_Roles_14 := {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
[SEE] API call 'get_Assignments' ready for actual execution

[ASSIGN] Evaluating: tmp_Assignments_4 := get_Assignments()
[SEE] Mapping base name 'tmp_Assignments_' -> 'tmp_Assignments_4'
[API_CALL] Executing API function: get_Assignments
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Assignments
  [API_CALL] Executing function...
[GetAssignmentsFunc] Fetching Assignments...
  [API_CALL] Function returned: {696a632bc1e2b9273264cc4d -> "agent@example.com"}
  [API_CALL] Storing result in variable: tmp_Assignments_4
[ASSIGN] Result: tmp_Assignments_4 := {696a632bc1e2b9273264cc4d -> "agent@example.com"}
[SEE] API call 'get_Assignments' ready for actual execution

[ASSIGN] Evaluating: tmp_Assignments_5 := get_Assignments()
[SEE] Mapping base name 'tmp_Assignments_' -> 'tmp_Assignments_5'
[API_CALL] Executing API function: get_Assignments
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Assignments
  [API_CALL] Executing function...
[GetAssignmentsFunc] Fetching Assignments...
  [API_CALL] Function returned: {696a632bc1e2b9273264cc4d -> "agent@example.com"}
  [API_CALL] Storing result in variable: tmp_Assignments_5
[ASSIGN] Result: tmp_Assignments_5 := {696a632bc1e2b9273264cc4d -> "agent@example.com"}

[ASSUME] Evaluating: AND(in(agentEmail, dom(tmp_T_17)), =([](tmp_Roles_14, agentEmail), AGENT), in(orderId, dom(tmp_Assignments_4)), =([](tmp_Assignments_5, orderId), agentEmail))
  [EVAL] FuncCall: AND with 4 args
    [EVAL] N-ary AND with 4 args
    [EVAL] Arg[0]: in(agentEmail, dom(tmp_T_17))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail17'
    [EVAL] Found in sigma: "agent@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_17
    [EVAL] Found in sigma: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Map expr evaluated: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Domain has 3 keys
    [EVAL] Element: "agent@example.com"
    [EVAL] Element: "customer@example.com"
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"agent@example.com", "customer@example.com", "owner@example.com"}
    [EVAL] Element: "agent@example.com"
    [EVAL] Set: {"agent@example.com", "customer@example.com", "owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_14, agentEmail), AGENT)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_14
    [EVAL] Found in sigma: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail17'
    [EVAL] Found in sigma: "agent@example.com"
    [EVAL] Map expr evaluated: {agent@example.com -> "delivery_agent", customer@example.com -> "customer", owner@example.com -> "restaurant_owner"}
    [EVAL] Key expr evaluated: "agent@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "delivery_agent"
  [EVAL] Var lookup: AGENT
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "delivery_agent" AGENT)
    [EVAL] Arg[2]: in(orderId, dom(tmp_Assignments_4))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId17'
    [EVAL] Found placeholder __NEEDS_ORDER_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] Found tmp_O_1 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_2 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_3 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_4 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_5 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [EVAL] Resolved to: 696a632bc1e2b9273264cc4d
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_Assignments_4
    [EVAL] Found in sigma: {696a632bc1e2b9273264cc4d -> "agent@example.com"}
    [EVAL] Map expr evaluated: {696a632bc1e2b9273264cc4d -> "agent@example.com"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696a632bc1e2b9273264cc4d"
    [EVAL] Set: {"696a632bc1e2b9273264cc4d"}
    [EVAL] Element: "696a632bc1e2b9273264cc4d"
    [EVAL] Set: {"696a632bc1e2b9273264cc4d"}
    [EVAL] Element found in set: true
    [EVAL] Arg[2] result: true
    [EVAL] Arg[3]: =([](tmp_Assignments_5, orderId), agentEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Assignments_5
    [EVAL] Found in sigma: {696a632bc1e2b9273264cc4d -> "agent@example.com"}
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId17'
    [EVAL] Found in sigma: "696a632bc1e2b9273264cc4d"
    [EVAL] Map expr evaluated: {696a632bc1e2b9273264cc4d -> "agent@example.com"}
    [EVAL] Key expr evaluated: "696a632bc1e2b9273264cc4d"
    [EVAL] Key found in map, returning value
  [EVAL] String: "agent@example.com"
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail17'
    [EVAL] Found in sigma: "agent@example.com"
    [EVAL] Eq result: true
    [EVAL] Arg[3] result: true
    [EVAL] FuncCall result: AND(true, (= "delivery_agent" AGENT), true, true)
[ASSUME] Adding constraint: AND(true, (= "delivery_agent" AGENT), true, true)
[SEE] API call 'updateOrderStatusAgent' ready for actual execution

[ASSIGN] Evaluating: _result17 := updateOrderStatusAgent(agentEmail, orderId, orderStatus)
[SEE] Mapping base name '_result' -> '_result17'
  [EVAL] Var lookup: agentEmail
    [EVAL] Resolved base name 'agentEmail' -> 'agentEmail17'
    [EVAL] Found in sigma: "agent@example.com"
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId17'
    [EVAL] Found in sigma: "696a632bc1e2b9273264cc4d"
  [EVAL] Var lookup: orderStatus
    [EVAL] Resolved base name 'orderStatus' -> 'orderStatus17'
    [EVAL] Found in sigma: "delivered"
[API_CALL] Executing API function: updateOrderStatusAgent
  [API_ARG] "agent@example.com"
  [API_ARG] "696a632bc1e2b9273264cc4d"
  [API_ARG] "delivered"
  [API_CALL] Getting function from factory...
[Factory] Creating function: updateOrderStatusAgent
  [API_CALL] Executing function...
[UpdateOrderStatusAgentFunc] agent@example.com updating order 696a632bc1e2b9273264cc4d to delivered
[UpdateOrderStatusAgentFunc] Order status updated
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _result17
[ASSIGN] Result: _result17 := 200

[ASSERT] Empty assertion, PASSED

[ASSIGN] Evaluating: customerEmail18 := "customer@example.com"
[SEE] Mapping base name 'customerEmail' -> 'customerEmail18'
  [EVAL] String: "customer@example.com"
[ASSIGN] Result: customerEmail18 := "customer@example.com"

[ASSIGN] Evaluating: orderId18 := "__NEEDS_ORDER_ID__"
[SEE] Mapping base name 'orderId' -> 'orderId18'
  [EVAL] String: "__NEEDS_ORDER_ID__"
[ASSIGN] Result: orderId18 := "__NEEDS_ORDER_ID__"

[ASSIGN] Evaluating: restaurantRating18 := 5
[SEE] Mapping base name 'restaurantRating' -> 'restaurantRating18'
  [EVAL] Num: 5
[ASSIGN] Result: restaurantRating18 := 5

[ASSIGN] Evaluating: deliveryRating18 := 4
[SEE] Mapping base name 'deliveryRating' -> 'deliveryRating18'
  [EVAL] Num: 4
[ASSIGN] Result: deliveryRating18 := 4

[ASSIGN] Evaluating: reviewComment18 := "Great food and fast delivery!"
[SEE] Mapping base name 'reviewComment' -> 'reviewComment18'
  [EVAL] String: "Great food and fast delivery!"
[ASSIGN] Result: reviewComment18 := "Great food and fast delivery!"
[SEE] API call 'get_Rev' ready for actual execution

[ASSIGN] Evaluating: tmp_Rev_0 := get_Rev()
[SEE] Mapping base name 'tmp_Rev_' -> 'tmp_Rev_0'
[API_CALL] Executing API function: get_Rev
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Rev
  [API_CALL] Executing function...
[GetRevFunc] Fetching Rev...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Rev_0
[ASSIGN] Result: tmp_Rev_0 := {}

[ASSIGN] Evaluating: Rev_old := tmp_Rev_0
  [EVAL] Var lookup: tmp_Rev_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Rev_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_18 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_18'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
  [API_CALL] Storing result in variable: tmp_T_18
[ASSIGN] Result: tmp_T_18 := {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_6 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_6'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O...
  [API_CALL] Function returned: {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"delivered","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
  [API_CALL] Storing result in variable: tmp_O_6
[ASSIGN] Result: tmp_O_6 := {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"delivered","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}

[ASSUME] Evaluating: AND(in(customerEmail, dom(tmp_T_18)), in(orderId, dom(tmp_O_6)))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(customerEmail, dom(tmp_T_18))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail18'
    [EVAL] Found in sigma: "customer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_18
    [EVAL] Found in sigma: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Map expr evaluated: {agent@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjNWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.TYlOoRCqDz0nP_WJtz6dmL3uNh__mJp7jmu5qagY2BY", customer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNjMWQiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.1ecABLAiXXVC7RefzTPHVmWfykZYlRGMjzu86H5f3T4", owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZhNjMyYmMxZTJiOTI3MzI2NGNiZjkiLCJpYXQiOjE3Njg1Nzk4ODMsImV4cCI6MTc2OTE4NDY4M30.BOqCDmW2iR1lnxDUJWfz94-kur3yCkM7VSnCmEc_Qg0"}
    [EVAL] Domain has 3 keys
    [EVAL] Element: "agent@example.com"
    [EVAL] Element: "customer@example.com"
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"agent@example.com", "customer@example.com", "owner@example.com"}
    [EVAL] Element: "customer@example.com"
    [EVAL] Set: {"agent@example.com", "customer@example.com", "owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: in(orderId, dom(tmp_O_6))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId18'
    [EVAL] Found placeholder __NEEDS_ORDER_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] Found tmp_O_1 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_2 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_3 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_4 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_5 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [findKeyFromMapInSigma] Found tmp_O_6 with 1 entries, key: 696a632bc1e2b9273264cc4d
    [EVAL] Resolved to: 696a632bc1e2b9273264cc4d
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_6
    [EVAL] Found in sigma: {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"delivered","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
    [EVAL] Map expr evaluated: {696a632bc1e2b9273264cc4d -> "{"items":[{"menuItem":"696a632bc1e2b9273264cc15","price":150,"quantity":2}],"restaurant":"696a632bc1e2b9273264cc09","status":"delivered","totalAmount":300,"user":"696a632bc1e2b9273264cc1d"}"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696a632bc1e2b9273264cc4d"
    [EVAL] Set: {"696a632bc1e2b9273264cc4d"}
    [EVAL] Element: "696a632bc1e2b9273264cc4d"
    [EVAL] Set: {"696a632bc1e2b9273264cc4d"}
    [EVAL] Element found in set: true
    [EVAL] Arg[1] result: true
    [EVAL] FuncCall result: AND(...) = true
[ASSUME] Adding constraint: true
[SEE] API call 'leaveReview' ready for actual execution

[ASSIGN] Evaluating: _result18 := leaveReview(customerEmail, orderId, restaurantRating, deliveryRating, reviewComment)
[SEE] Mapping base name '_result' -> '_result18'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail18'
    [EVAL] Found in sigma: "customer@example.com"
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId18'
    [EVAL] Found in sigma: "696a632bc1e2b9273264cc4d"
  [EVAL] Var lookup: restaurantRating
    [EVAL] Resolved base name 'restaurantRating' -> 'restaurantRating18'
    [EVAL] Found in sigma: 5
  [EVAL] Var lookup: deliveryRating
    [EVAL] Resolved base name 'deliveryRating' -> 'deliveryRating18'
    [EVAL] Found in sigma: 4
  [EVAL] Var lookup: reviewComment
    [EVAL] Resolved base name 'reviewComment' -> 'reviewComment18'
    [EVAL] Found in sigma: "Great food and fast delivery!"
[API_CALL] Executing API function: leaveReview
  [API_ARG] "customer@example.com"
  [API_ARG] "696a632bc1e2b9273264cc4d"
  [API_ARG] 5
  [API_ARG] 4
  [API_ARG] "Great food and fast delivery!"
  [API_CALL] Getting function from factory...
[Factory] Creating function: leaveReview
  [API_CALL] Executing function...
[LeaveReviewFunc] customer@example.com leaving review for order: 696a632bc1e2b9273264cc4d
[HttpClient] POST /api/reviews -> 201
[LeaveReviewFunc] Review created: 696a632bc1e2b9273264ccc4
  [API_CALL] Function returned: "696a632bc1e2b9273264ccc4"
  [API_CALL] Storing result in variable: _result18
[ASSIGN] Result: _result18 := "696a632bc1e2b9273264ccc4"
[SEE] API call 'get_Rev' ready for actual execution

[ASSIGN] Evaluating: tmp_Rev_1 := get_Rev()
[SEE] Mapping base name 'tmp_Rev_' -> 'tmp_Rev_1'
[API_CALL] Executing API function: get_Rev
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Rev
  [API_CALL] Executing function...
[GetRevFunc] Fetching Rev...
  [API_CALL] Function returned: {696a632bc1e2b9273264ccc4 -> "{"comment":"Great food and fast delivery!","rating":5,"restaurant":"696a632bc1e2b9273264cc09","user":"696a632bc1e2b9273264cc1d"}"}
  [API_CALL] Storing result in variable: tmp_Rev_1
[ASSIGN] Result: tmp_Rev_1 := {696a632bc1e2b9273264ccc4 -> "{"comment":"Great food and fast delivery!","rating":5,"restaurant":"696a632bc1e2b9273264cc09","user":"696a632bc1e2b9273264cc1d"}"}

[ASSERT] Evaluating: in(_result18, dom(tmp_Rev_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result18
    [EVAL] Found in sigma: "696a632bc1e2b9273264ccc4"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_Rev_1
    [EVAL] Found in sigma: {696a632bc1e2b9273264ccc4 -> "{"comment":"Great food and fast delivery!","rating":5,"restaurant":"696a632bc1e2b9273264cc09","user":"696a632bc1e2b9273264cc1d"}"}
    [EVAL] Map expr evaluated: {696a632bc1e2b9273264ccc4 -> "{"comment":"Great food and fast delivery!","rating":5,"restaurant":"696a632bc1e2b9273264cc09","user":"696a632bc1e2b9273264cc1d"}"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696a632bc1e2b9273264ccc4"
    [EVAL] Set: {"696a632bc1e2b9273264ccc4"}
    [EVAL] Element: "696a632bc1e2b9273264ccc4"
    [EVAL] Set: {"696a632bc1e2b9273264ccc4"}
    [EVAL] Element found in set: true
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[SEE] Path Constraint: And(true, And(true, And(AND(true, (= "restaurant_owner" OWNER)), And(true, And(AND(true, (= "restaurant_owner" OWNER)), And(AND(true, (= "restaurant_owner" OWNER), true), And(true, And(AND(true, (= "customer" CUSTOMER)), And(true, And(true, And(true, And(true, And(true, And(true, And(AND(true, (= "delivery_agent" AGENT)), And(true, And(AND(true, (= "restaurant_owner" OWNER), true), And(AND(true, (= "restaurant_owner" OWNER), true), And(AND(true, (= "restaurant_owner" OWNER), true), And(AND(true, (= "restaurant_owner" OWNER), true, true, (= "delivery_agent" AGENT)), And(AND(true, (= "delivery_agent" AGENT), true, true), And(AND(true, (= "delivery_agent" AGENT), true, true), true))))))))))))))))))))))
>>> generateCTC: After symex - Is abstract: 0, Has placeholders: 1

>>> generateCTC: STEP 3a - Resolving placeholders in AST

>>> Resolving placeholders in program AST
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] Found tmp_R_3 with 1 entries, returning key: 696a632bc1e2b9273264cc09
    [AST RESOLVED] restaurantId3 = "696a632bc1e2b9273264cc09"
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] Found tmp_R_3 with 1 entries, returning key: 696a632bc1e2b9273264cc09
    [AST RESOLVED] restaurantId7 = "696a632bc1e2b9273264cc09"
    [findKeyFromMapInSigma] Searching for prefix: tmp_M_
    [findKeyFromMapInSigma] Found tmp_M_2 with 1 entries, returning key: 696a632bc1e2b9273264cc15
    [AST RESOLVED] menuItemId8 = "696a632bc1e2b9273264cc15"
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] Found tmp_O_6 with 1 entries, returning key: 696a632bc1e2b9273264cc4d
    [AST RESOLVED] orderId12 = "696a632bc1e2b9273264cc4d"
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] Found tmp_O_6 with 1 entries, returning key: 696a632bc1e2b9273264cc4d
    [AST RESOLVED] orderId13 = "696a632bc1e2b9273264cc4d"
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] Found tmp_O_6 with 1 entries, returning key: 696a632bc1e2b9273264cc4d
    [AST RESOLVED] orderId14 = "696a632bc1e2b9273264cc4d"
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] Found tmp_O_6 with 1 entries, returning key: 696a632bc1e2b9273264cc4d
    [AST RESOLVED] orderId15 = "696a632bc1e2b9273264cc4d"
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] Found tmp_O_6 with 1 entries, returning key: 696a632bc1e2b9273264cc4d
    [AST RESOLVED] orderId16 = "696a632bc1e2b9273264cc4d"
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] Found tmp_O_6 with 1 entries, returning key: 696a632bc1e2b9273264cc4d
    [AST RESOLVED] orderId17 = "696a632bc1e2b9273264cc4d"
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] Found tmp_O_6 with 1 entries, returning key: 696a632bc1e2b9273264cc4d
    [AST RESOLVED] orderId18 = "696a632bc1e2b9273264cc4d"
>>> generateCTC: All placeholders resolved, program is fully concrete

[FINAL CTC]
=== Program ===
Statement 0: _ := reset()
Statement 1: ownerEmail0 := "owner@example.com"
Statement 2: ownerPassword0 := "OwnerPass1!"
Statement 3: ownerFullName0 := "Test Owner"
Statement 4: ownerMobile0 := "5550000001"
Statement 5: tmp_Roles_0 := get_Roles()
Statement 6: Roles_old := tmp_Roles_0
Statement 7: tmp_U_0 := get_U()
Statement 8: U_old := tmp_U_0
Statement 9: tmp_U_1 := get_U()
Statement 10: assume(not_in(ownerEmail, dom(tmp_U_1)))
Statement 11: _result0 := registerOwner(ownerEmail, ownerPassword, ownerFullName, ownerMobile)
Statement 12: tmp_U_2 := get_U()
Statement 13: tmp_Roles_1 := get_Roles()
Statement 14: assert(AND(=([](tmp_U_2, ownerEmail), ownerPassword), =([](tmp_Roles_1, ownerEmail), OWNER)))
Statement 15: ownerEmail1 := "owner@example.com"
Statement 16: ownerPassword1 := "OwnerPass1!"
Statement 17: tmp_T_0 := get_T()
Statement 18: T_old := tmp_T_0
Statement 19: tmp_U_3 := get_U()
Statement 20: tmp_U_4 := get_U()
Statement 21: assume(AND(in(ownerEmail, dom(tmp_U_3)), =([](tmp_U_4, ownerEmail), ownerPassword)))
Statement 22: _result1 := login(ownerEmail, ownerPassword)
Statement 23: tmp_T_1 := get_T()
Statement 24: assert(=([](tmp_T_1, ownerEmail), _result1))
Statement 25: ownerEmail2 := "owner@example.com"
Statement 26: restaurantName2 := "Test Restaurant"
Statement 27: restaurantAddress2 := "123 Restaurant Street"
Statement 28: restaurantContact2 := "restaurant@test.com"
Statement 29: tmp_Owners_0 := get_Owners()
Statement 30: Owners_old := tmp_Owners_0
Statement 31: tmp_R_0 := get_R()
Statement 32: R_old := tmp_R_0
Statement 33: tmp_T_2 := get_T()
Statement 34: tmp_Roles_2 := get_Roles()
Statement 35: assume(AND(in(ownerEmail, dom(tmp_T_2)), =([](tmp_Roles_2, ownerEmail), OWNER)))
Statement 36: _result2 := createRestaurant(ownerEmail, restaurantName, restaurantAddress, restaurantContact)
Statement 37: tmp_R_1 := get_R()
Statement 38: tmp_Owners_1 := get_Owners()
Statement 39: assert(AND(in(_result2, dom(tmp_R_1)), =([](tmp_Owners_1, _result2), ownerEmail)))
Statement 40: ownerEmail3 := "owner@example.com"
Statement 41: restaurantId3 := "696a632bc1e2b9273264cc09"
Statement 42: itemName3 := "Delicious Dish"
Statement 43: itemPrice3 := 150
Statement 44: tmp_M_0 := get_M()
Statement 45: M_old := tmp_M_0
Statement 46: tmp_T_3 := get_T()
Statement 47: tmp_Roles_3 := get_Roles()
Statement 48: tmp_R_2 := get_R()
Statement 49: assume(AND(in(ownerEmail, dom(tmp_T_3)), =([](tmp_Roles_3, ownerEmail), OWNER), in(restaurantId, dom(tmp_R_2))))
Statement 50: _result3 := addMenuItem(ownerEmail, restaurantId, itemName, itemPrice)
Statement 51: tmp_M_1 := get_M()
Statement 52: assert(in(_result3, dom(tmp_M_1)))
Statement 53: customerEmail4 := "customer@example.com"
Statement 54: customerPassword4 := "CustomerPass1!"
Statement 55: customerFullName4 := "Test Customer"
Statement 56: customerMobile4 := "5550000002"
Statement 57: tmp_Roles_4 := get_Roles()
Statement 58: Roles_old := tmp_Roles_4
Statement 59: tmp_U_5 := get_U()
Statement 60: U_old := tmp_U_5
Statement 61: tmp_U_6 := get_U()
Statement 62: assume(not_in(customerEmail, dom(tmp_U_6)))
Statement 63: _result4 := registerCustomer(customerEmail, customerPassword, customerFullName, customerMobile)
Statement 64: tmp_U_7 := get_U()
Statement 65: tmp_Roles_5 := get_Roles()
Statement 66: assert(AND(=([](tmp_U_7, customerEmail), customerPassword), =([](tmp_Roles_5, customerEmail), CUSTOMER)))
Statement 67: customerEmail5 := "customer@example.com"
Statement 68: customerPassword5 := "CustomerPass1!"
Statement 69: tmp_T_4 := get_T()
Statement 70: T_old := tmp_T_4
Statement 71: tmp_U_8 := get_U()
Statement 72: tmp_U_9 := get_U()
Statement 73: assume(AND(in(customerEmail, dom(tmp_U_8)), =([](tmp_U_9, customerEmail), customerPassword)))
Statement 74: _result5 := login(customerEmail, customerPassword)
Statement 75: tmp_T_5 := get_T()
Statement 76: assert(=([](tmp_T_5, customerEmail), _result5))
Statement 77: customerEmail6 := "customer@example.com"
Statement 78: tmp_T_6 := get_T()
Statement 79: assume(in(customerEmail, dom(tmp_T_6)))
Statement 80: _result6 := browseRestaurants(customerEmail)
Statement 81: assert()
Statement 82: customerEmail7 := "customer@example.com"
Statement 83: restaurantId7 := "696a632bc1e2b9273264cc09"
Statement 84: tmp_T_7 := get_T()
Statement 85: tmp_R_3 := get_R()
Statement 86: assume(AND(in(customerEmail, dom(tmp_T_7)), in(restaurantId, dom(tmp_R_3))))
Statement 87: _result7 := viewMenu(customerEmail, restaurantId)
Statement 88: assert()
Statement 89: customerEmail8 := "customer@example.com"
Statement 90: menuItemId8 := "696a632bc1e2b9273264cc15"
Statement 91: quantity8 := 2
Statement 92: tmp_C_0 := get_C()
Statement 93: C_old := tmp_C_0
Statement 94: tmp_T_8 := get_T()
Statement 95: tmp_M_2 := get_M()
Statement 96: assume(AND(in(customerEmail, dom(tmp_T_8)), in(menuItemId, dom(tmp_M_2))))
Statement 97: _result8 := addToCart(customerEmail, menuItemId, quantity)
Statement 98: tmp_C_1 := get_C()
Statement 99: assert(in(customerEmail, dom(tmp_C_1)))
Statement 100: customerEmail9 := "customer@example.com"
Statement 101: deliveryAddress9 := "456 Customer Lane, Apt 7"
Statement 102: paymentMethod9 := "card"
Statement 103: tmp_C_2 := get_C()
Statement 104: C_old := tmp_C_2
Statement 105: tmp_O_0 := get_O()
Statement 106: O_old := tmp_O_0
Statement 107: tmp_T_9 := get_T()
Statement 108: tmp_C_3 := get_C()
Statement 109: assume(AND(in(customerEmail, dom(tmp_T_9)), in(customerEmail, dom(tmp_C_3))))
Statement 110: _result9 := placeOrder(customerEmail, deliveryAddress, paymentMethod)
Statement 111: tmp_O_1 := get_O()
Statement 112: tmp_C_4 := get_C()
Statement 113: assert(AND(in(_result9, dom(tmp_O_1)), not_in(customerEmail, dom(tmp_C_4))))
Statement 114: agentEmail10 := "agent@example.com"
Statement 115: agentPassword10 := "AgentPass1!"
Statement 116: agentFullName10 := "Test Agent"
Statement 117: agentMobile10 := "5550000003"
Statement 118: tmp_Roles_6 := get_Roles()
Statement 119: Roles_old := tmp_Roles_6
Statement 120: tmp_U_10 := get_U()
Statement 121: U_old := tmp_U_10
Statement 122: tmp_U_11 := get_U()
Statement 123: assume(not_in(agentEmail, dom(tmp_U_11)))
Statement 124: _result10 := registerAgent(agentEmail, agentPassword, agentFullName, agentMobile)
Statement 125: tmp_U_12 := get_U()
Statement 126: tmp_Roles_7 := get_Roles()
Statement 127: assert(AND(=([](tmp_U_12, agentEmail), agentPassword), =([](tmp_Roles_7, agentEmail), AGENT)))
Statement 128: agentEmail11 := "agent@example.com"
Statement 129: agentPassword11 := "AgentPass1!"
Statement 130: tmp_T_10 := get_T()
Statement 131: T_old := tmp_T_10
Statement 132: tmp_U_13 := get_U()
Statement 133: tmp_U_14 := get_U()
Statement 134: assume(AND(in(agentEmail, dom(tmp_U_13)), =([](tmp_U_14, agentEmail), agentPassword)))
Statement 135: _result11 := login(agentEmail, agentPassword)
Statement 136: tmp_T_11 := get_T()
Statement 137: assert(=([](tmp_T_11, agentEmail), _result11))
Statement 138: ownerEmail12 := "owner@example.com"
Statement 139: orderId12 := "696a632bc1e2b9273264cc4d"
Statement 140: orderStatus12 := "accepted"
Statement 141: tmp_T_12 := get_T()
Statement 142: tmp_Roles_8 := get_Roles()
Statement 143: tmp_O_2 := get_O()
Statement 144: assume(AND(in(ownerEmail, dom(tmp_T_12)), =([](tmp_Roles_8, ownerEmail), OWNER), in(orderId, dom(tmp_O_2))))
Statement 145: _result12 := updateOrderStatusOwner(ownerEmail, orderId, orderStatus)
Statement 146: assert()
Statement 147: ownerEmail13 := "owner@example.com"
Statement 148: orderId13 := "696a632bc1e2b9273264cc4d"
Statement 149: orderStatus13 := "preparing"
Statement 150: tmp_T_13 := get_T()
Statement 151: tmp_Roles_9 := get_Roles()
Statement 152: tmp_O_3 := get_O()
Statement 153: assume(AND(in(ownerEmail, dom(tmp_T_13)), =([](tmp_Roles_9, ownerEmail), OWNER), in(orderId, dom(tmp_O_3))))
Statement 154: _result13 := updateOrderStatusOwner(ownerEmail, orderId, orderStatus)
Statement 155: assert()
Statement 156: ownerEmail14 := "owner@example.com"
Statement 157: orderId14 := "696a632bc1e2b9273264cc4d"
Statement 158: orderStatus14 := "ready"
Statement 159: tmp_T_14 := get_T()
Statement 160: tmp_Roles_10 := get_Roles()
Statement 161: tmp_O_4 := get_O()
Statement 162: assume(AND(in(ownerEmail, dom(tmp_T_14)), =([](tmp_Roles_10, ownerEmail), OWNER), in(orderId, dom(tmp_O_4))))
Statement 163: _result14 := updateOrderStatusOwner(ownerEmail, orderId, orderStatus)
Statement 164: assert()
Statement 165: ownerEmail15 := "owner@example.com"
Statement 166: orderId15 := "696a632bc1e2b9273264cc4d"
Statement 167: agentEmail15 := "agent@example.com"
Statement 168: tmp_Assignments_0 := get_Assignments()
Statement 169: Assignments_old := tmp_Assignments_0
Statement 170: tmp_T_15 := get_T()
Statement 171: tmp_Roles_11 := get_Roles()
Statement 172: tmp_O_5 := get_O()
Statement 173: tmp_U_15 := get_U()
Statement 174: tmp_Roles_12 := get_Roles()
Statement 175: assume(AND(in(ownerEmail, dom(tmp_T_15)), =([](tmp_Roles_11, ownerEmail), OWNER), in(orderId, dom(tmp_O_5)), in(agentEmail, dom(tmp_U_15)), =([](tmp_Roles_12, agentEmail), AGENT)))
Statement 176: _result15 := assignOrder(ownerEmail, orderId, agentEmail)
Statement 177: tmp_Assignments_1 := get_Assignments()
Statement 178: assert(=([](tmp_Assignments_1, orderId), agentEmail))
Statement 179: agentEmail16 := "agent@example.com"
Statement 180: orderId16 := "696a632bc1e2b9273264cc4d"
Statement 181: orderStatus16 := "picked_up"
Statement 182: tmp_T_16 := get_T()
Statement 183: tmp_Roles_13 := get_Roles()
Statement 184: tmp_Assignments_2 := get_Assignments()
Statement 185: tmp_Assignments_3 := get_Assignments()
Statement 186: assume(AND(in(agentEmail, dom(tmp_T_16)), =([](tmp_Roles_13, agentEmail), AGENT), in(orderId, dom(tmp_Assignments_2)), =([](tmp_Assignments_3, orderId), agentEmail)))
Statement 187: _result16 := updateOrderStatusAgent(agentEmail, orderId, orderStatus)
Statement 188: assert()
Statement 189: agentEmail17 := "agent@example.com"
Statement 190: orderId17 := "696a632bc1e2b9273264cc4d"
Statement 191: orderStatus17 := "delivered"
Statement 192: tmp_T_17 := get_T()
Statement 193: tmp_Roles_14 := get_Roles()
Statement 194: tmp_Assignments_4 := get_Assignments()
Statement 195: tmp_Assignments_5 := get_Assignments()
Statement 196: assume(AND(in(agentEmail, dom(tmp_T_17)), =([](tmp_Roles_14, agentEmail), AGENT), in(orderId, dom(tmp_Assignments_4)), =([](tmp_Assignments_5, orderId), agentEmail)))
Statement 197: _result17 := updateOrderStatusAgent(agentEmail, orderId, orderStatus)
Statement 198: assert()
Statement 199: customerEmail18 := "customer@example.com"
Statement 200: orderId18 := "696a632bc1e2b9273264cc4d"
Statement 201: restaurantRating18 := 5
Statement 202: deliveryRating18 := 4
Statement 203: reviewComment18 := "Great food and fast delivery!"
Statement 204: tmp_Rev_0 := get_Rev()
Statement 205: Rev_old := tmp_Rev_0
Statement 206: tmp_T_18 := get_T()
Statement 207: tmp_O_6 := get_O()
Statement 208: assume(AND(in(customerEmail, dom(tmp_T_18)), in(orderId, dom(tmp_O_6))))
Statement 209: _result18 := leaveReview(customerEmail, orderId, restaurantRating, deliveryRating, reviewComment)
Statement 210: tmp_Rev_1 := get_Rev()
Statement 211: assert(in(_result18, dom(tmp_Rev_1)))
=== End Program ===

✓ Test 10: Browse → Leave Review (No Auth) (Depth=2) COMPLETE!

