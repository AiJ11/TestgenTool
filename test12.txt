
╔════════════════════════════════════════╗
║  TESTGEN - RESTAURANT TEST SUITE      ║
║  Total Tests: 25                       ║
╚════════════════════════════════════════╝


=== DEPTH TESTS ===

========================================
TEST: Test 12: Register Owner → Login → Create Restaurant → Add Menu (Depth=4)
MODE: Full Pipeline (With Backend)
DEPTH: 6 API calls
========================================

[RestaurantFunctionFactory] Initialized with baseUrl: http://localhost:5002
[RewriteGlobalsVisitor] Detected 10 globals: Assignments C M O Owners R Rev Roles T U 
[RewriteGlobalsVisitor] Generated 0 statements in rewritten program

=== TEST-API ATC (After Rewrite) ===
=== Program ===
Statement 0: _ := reset()
Statement 1: ownerEmail0 := input()
Statement 2: ownerPassword0 := input()
Statement 3: ownerFullName0 := input()
Statement 4: ownerMobile0 := input()
Statement 5: tmp_Roles_0 := get_Roles()
Statement 6: Roles_old := tmp_Roles_0
Statement 7: tmp_U_0 := get_U()
Statement 8: U_old := tmp_U_0
Statement 9: tmp_U_1 := get_U()
Statement 10: assume(not_in(ownerEmail, dom(tmp_U_1)))
Statement 11: _result0 := registerOwner(ownerEmail, ownerPassword, ownerFullName, ownerMobile)
Statement 12: tmp_U_2 := get_U()
Statement 13: tmp_Roles_1 := get_Roles()
Statement 14: assert(AND(=([](tmp_U_2, ownerEmail), ownerPassword), =([](tmp_Roles_1, ownerEmail), OWNER)))
Statement 15: ownerEmail1 := input()
Statement 16: ownerPassword1 := input()
Statement 17: tmp_T_0 := get_T()
Statement 18: T_old := tmp_T_0
Statement 19: tmp_U_3 := get_U()
Statement 20: tmp_U_4 := get_U()
Statement 21: assume(AND(in(ownerEmail, dom(tmp_U_3)), =([](tmp_U_4, ownerEmail), ownerPassword)))
Statement 22: _result1 := login(ownerEmail, ownerPassword)
Statement 23: tmp_T_1 := get_T()
Statement 24: assert(=([](tmp_T_1, ownerEmail), _result1))
Statement 25: ownerEmail2 := input()
Statement 26: restaurantName2 := input()
Statement 27: restaurantAddress2 := input()
Statement 28: restaurantContact2 := input()
Statement 29: tmp_Owners_0 := get_Owners()
Statement 30: Owners_old := tmp_Owners_0
Statement 31: tmp_R_0 := get_R()
Statement 32: R_old := tmp_R_0
Statement 33: tmp_T_2 := get_T()
Statement 34: tmp_Roles_2 := get_Roles()
Statement 35: assume(AND(in(ownerEmail, dom(tmp_T_2)), =([](tmp_Roles_2, ownerEmail), OWNER)))
Statement 36: _result2 := createRestaurant(ownerEmail, restaurantName, restaurantAddress, restaurantContact)
Statement 37: tmp_R_1 := get_R()
Statement 38: tmp_Owners_1 := get_Owners()
Statement 39: assert(AND(in(_result2, dom(tmp_R_1)), =([](tmp_Owners_1, _result2), ownerEmail)))
Statement 40: ownerEmail3 := input()
Statement 41: restaurantId3 := input()
Statement 42: itemName3 := input()
Statement 43: itemPrice3 := input()
Statement 44: tmp_M_0 := get_M()
Statement 45: M_old := tmp_M_0
Statement 46: tmp_T_3 := get_T()
Statement 47: tmp_Roles_3 := get_Roles()
Statement 48: tmp_R_2 := get_R()
Statement 49: assume(AND(in(ownerEmail, dom(tmp_T_3)), =([](tmp_Roles_3, ownerEmail), OWNER), in(restaurantId, dom(tmp_R_2))))
Statement 50: _result3 := addMenuItem(ownerEmail, restaurantId, itemName, itemPrice)
Statement 51: tmp_M_1 := get_M()
Statement 52: assert(in(_result3, dom(tmp_M_1)))
Statement 53: ownerEmail4 := input()
Statement 54: restaurantId4 := input()
Statement 55: itemName4 := input()
Statement 56: itemPrice4 := input()
Statement 57: tmp_M_2 := get_M()
Statement 58: M_old := tmp_M_2
Statement 59: tmp_T_4 := get_T()
Statement 60: tmp_Roles_4 := get_Roles()
Statement 61: tmp_R_3 := get_R()
Statement 62: assume(AND(in(ownerEmail, dom(tmp_T_4)), =([](tmp_Roles_4, ownerEmail), OWNER), in(restaurantId, dom(tmp_R_3))))
Statement 63: _result4 := addMenuItem(ownerEmail, restaurantId, itemName, itemPrice)
Statement 64: tmp_M_3 := get_M()
Statement 65: assert(in(_result4, dom(tmp_M_3)))
Statement 66: ownerEmail5 := input()
Statement 67: restaurantId5 := input()
Statement 68: itemName5 := input()
Statement 69: itemPrice5 := input()
Statement 70: tmp_M_4 := get_M()
Statement 71: M_old := tmp_M_4
Statement 72: tmp_T_5 := get_T()
Statement 73: tmp_Roles_5 := get_Roles()
Statement 74: tmp_R_4 := get_R()
Statement 75: assume(AND(in(ownerEmail, dom(tmp_T_5)), =([](tmp_Roles_5, ownerEmail), OWNER), in(restaurantId, dom(tmp_R_4))))
Statement 76: _result5 := addMenuItem(ownerEmail, restaurantId, itemName, itemPrice)
Statement 77: tmp_M_5 := get_M()
Statement 78: assert(in(_result5, dom(tmp_M_5)))
=== End Program ===

========================================
>>> generateCTC: Starting iteration
========================================
>>> generateCTC: Program needs processing
>>> generateCTC: Concrete values provided: 0
>>> generateCTC: Is abstract: 1
>>> generateCTC: Has placeholders: 0

>>> generateCTC: STEP 1 - Rewriting ATC with concrete values

>>> generateCTC: STEP 2 - Running symbolic execution
[SEE] API call 'reset' ready for actual execution

[ASSIGN] Evaluating: _ := reset()
[API_CALL] Executing API function: reset
  [API_CALL] Getting function from factory...
[Factory] Creating function: reset
  [API_CALL] Executing function...
[ResetFunc] Clearing all collections...
[HttpClient] POST /api/test/reset -> 200
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _
[ASSIGN] Result: _ := 200

[ASSIGN] Evaluating: ownerEmail0 := input()
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X0
[ASSIGN] Result: ownerEmail0 := X0

[ASSIGN] Evaluating: ownerPassword0 := input()
[SEE] Mapping base name 'ownerPassword' -> 'ownerPassword0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X1
[ASSIGN] Result: ownerPassword0 := X1

[ASSIGN] Evaluating: ownerFullName0 := input()
[SEE] Mapping base name 'ownerFullName' -> 'ownerFullName0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X2
[ASSIGN] Result: ownerFullName0 := X2

[ASSIGN] Evaluating: ownerMobile0 := input()
[SEE] Mapping base name 'ownerMobile' -> 'ownerMobile0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X3
[ASSIGN] Result: ownerMobile0 := X3
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_0 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_0'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_0
[ASSIGN] Result: tmp_Roles_0 := {}

[ASSIGN] Evaluating: Roles_old := tmp_Roles_0
  [EVAL] Var lookup: tmp_Roles_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Roles_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_0 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_0'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_0
[ASSIGN] Result: tmp_U_0 := {}

[ASSIGN] Evaluating: U_old := tmp_U_0
  [EVAL] Var lookup: tmp_U_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: U_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_1 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_1'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_1
[ASSIGN] Result: tmp_U_1 := {}

[ASSUME] Evaluating: not_in(ownerEmail, dom(tmp_U_1))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail0'
    [EVAL] Found in sigma: X0
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
[ASSUME] Adding constraint: true
[SEE] API call 'registerOwner' with symbolic arguments - interruption point
[SEE] Interruption at statement 11

[ASSIGN] Evaluating: _result0 := registerOwner(ownerEmail, ownerPassword, ownerFullName, ownerMobile)
[SEE] Mapping base name '_result' -> '_result0'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail0'
    [EVAL] Found in sigma: X0
  [EVAL] Var lookup: ownerPassword
    [EVAL] Resolved base name 'ownerPassword' -> 'ownerPassword0'
    [EVAL] Found in sigma: X1
  [EVAL] Var lookup: ownerFullName
    [EVAL] Resolved base name 'ownerFullName' -> 'ownerFullName0'
    [EVAL] Found in sigma: X2
  [EVAL] Var lookup: ownerMobile
    [EVAL] Resolved base name 'ownerMobile' -> 'ownerMobile0'
    [EVAL] Found in sigma: X3
[API_CALL] registerOwner has symbolic arguments - skipping actual execution
  [API_ARG 0] X0 (symbolic: 1)
  [API_ARG 1] X1 (symbolic: 1)
  [API_ARG 2] X2 (symbolic: 1)
  [API_ARG 3] X3 (symbolic: 1)
[ASSIGN] Result: _result0 := -1 (symbolic placeholder)
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_2 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_2'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_2
[ASSIGN] Result: tmp_U_2 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_1 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_1'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_1
[ASSIGN] Result: tmp_Roles_1 := {}
[SEE] Interruption at statement 14

[ASSERT] Evaluating: AND(=([](tmp_U_2, ownerEmail), ownerPassword), =([](tmp_Roles_1, ownerEmail), OWNER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: =([](tmp_U_2, ownerEmail), ownerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_2
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail0'
    [EVAL] Found in sigma: X0
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X0
    [EVAL] Key not found in map
  [EVAL] Var lookup: ownerPassword
    [EVAL] Resolved base name 'ownerPassword' -> 'ownerPassword0'
    [EVAL] Found in sigma: X1
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[0] result: (= []({}, X0) X1)
    [EVAL] Arg[1]: =([](tmp_Roles_1, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail0'
    [EVAL] Found in sigma: X0
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X0
    [EVAL] Key not found in map
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X0) OWNER)
    [EVAL] FuncCall result: AND((= []({}, X0) X1), (= []({}, X0) OWNER))
[ASSERT] Result: AND((= []({}, X0) X1), (= []({}, X0) OWNER))
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: ownerEmail1 := input()
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail1'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X4
[ASSIGN] Result: ownerEmail1 := X4

[ASSIGN] Evaluating: ownerPassword1 := input()
[SEE] Mapping base name 'ownerPassword' -> 'ownerPassword1'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X5
[ASSIGN] Result: ownerPassword1 := X5
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_0 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_0'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_0
[ASSIGN] Result: tmp_T_0 := {}

[ASSIGN] Evaluating: T_old := tmp_T_0
  [EVAL] Var lookup: tmp_T_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: T_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_3 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_3'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_3
[ASSIGN] Result: tmp_U_3 := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_4 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_4'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_4
[ASSIGN] Result: tmp_U_4 := {}
[SEE] Interruption at statement 21

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_U_3)), =([](tmp_U_4, ownerEmail), ownerPassword))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_U_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail1'
    [EVAL] Found in sigma: X4
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X4
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_U_4, ownerEmail), ownerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_4
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail1'
    [EVAL] Found in sigma: X4
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X4
    [EVAL] Key not found in map
  [EVAL] Var lookup: ownerPassword
    [EVAL] Resolved base name 'ownerPassword' -> 'ownerPassword1'
    [EVAL] Found in sigma: X5
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X4) X5)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'login' with symbolic arguments - interruption point
[SEE] Interruption at statement 22

[ASSIGN] Evaluating: _result1 := login(ownerEmail, ownerPassword)
[SEE] Mapping base name '_result' -> '_result1'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail1'
    [EVAL] Found in sigma: X4
  [EVAL] Var lookup: ownerPassword
    [EVAL] Resolved base name 'ownerPassword' -> 'ownerPassword1'
    [EVAL] Found in sigma: X5
[API_CALL] login has symbolic arguments - skipping actual execution
  [API_ARG 0] X4 (symbolic: 1)
  [API_ARG 1] X5 (symbolic: 1)
[ASSIGN] Result: _result1 := -1 (symbolic placeholder)
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_1 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_1'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_1
[ASSIGN] Result: tmp_T_1 := {}

[ASSERT] Evaluating: =([](tmp_T_1, ownerEmail), _result1)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_T_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail1'
    [EVAL] Found in sigma: X4
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X4
    [EVAL] Key not found in map
  [EVAL] Var lookup: _result1
    [EVAL] Found in sigma: -1
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
[ASSERT] Result: (= []({}, X4) -1)
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: ownerEmail2 := input()
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X6
[ASSIGN] Result: ownerEmail2 := X6

[ASSIGN] Evaluating: restaurantName2 := input()
[SEE] Mapping base name 'restaurantName' -> 'restaurantName2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X7
[ASSIGN] Result: restaurantName2 := X7

[ASSIGN] Evaluating: restaurantAddress2 := input()
[SEE] Mapping base name 'restaurantAddress' -> 'restaurantAddress2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X8
[ASSIGN] Result: restaurantAddress2 := X8

[ASSIGN] Evaluating: restaurantContact2 := input()
[SEE] Mapping base name 'restaurantContact' -> 'restaurantContact2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X9
[ASSIGN] Result: restaurantContact2 := X9
[SEE] API call 'get_Owners' ready for actual execution

[ASSIGN] Evaluating: tmp_Owners_0 := get_Owners()
[SEE] Mapping base name 'tmp_Owners_' -> 'tmp_Owners_0'
[API_CALL] Executing API function: get_Owners
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Owners
  [API_CALL] Executing function...
[GetOwnersFunc] Fetching Owners...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Owners_0
[ASSIGN] Result: tmp_Owners_0 := {}

[ASSIGN] Evaluating: Owners_old := tmp_Owners_0
  [EVAL] Var lookup: tmp_Owners_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Owners_old := {}
[SEE] API call 'get_R' ready for actual execution

[ASSIGN] Evaluating: tmp_R_0 := get_R()
[SEE] Mapping base name 'tmp_R_' -> 'tmp_R_0'
[API_CALL] Executing API function: get_R
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_R
  [API_CALL] Executing function...
[GetRFunc] Fetching R...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_R_0
[ASSIGN] Result: tmp_R_0 := {}

[ASSIGN] Evaluating: R_old := tmp_R_0
  [EVAL] Var lookup: tmp_R_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: R_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_2 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_2'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_2
[ASSIGN] Result: tmp_T_2 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_2 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_2'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_2
[ASSIGN] Result: tmp_Roles_2 := {}
[SEE] Interruption at statement 35

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_2)), =([](tmp_Roles_2, ownerEmail), OWNER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail2'
    [EVAL] Found in sigma: X6
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_2
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X6
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_2, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_2
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail2'
    [EVAL] Found in sigma: X6
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X6
    [EVAL] Key not found in map
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X6) OWNER)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'createRestaurant' with symbolic arguments - interruption point
[SEE] Interruption at statement 36

[ASSIGN] Evaluating: _result2 := createRestaurant(ownerEmail, restaurantName, restaurantAddress, restaurantContact)
[SEE] Mapping base name '_result' -> '_result2'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail2'
    [EVAL] Found in sigma: X6
  [EVAL] Var lookup: restaurantName
    [EVAL] Resolved base name 'restaurantName' -> 'restaurantName2'
    [EVAL] Found in sigma: X7
  [EVAL] Var lookup: restaurantAddress
    [EVAL] Resolved base name 'restaurantAddress' -> 'restaurantAddress2'
    [EVAL] Found in sigma: X8
  [EVAL] Var lookup: restaurantContact
    [EVAL] Resolved base name 'restaurantContact' -> 'restaurantContact2'
    [EVAL] Found in sigma: X9
[API_CALL] createRestaurant has symbolic arguments - skipping actual execution
  [API_ARG 0] X6 (symbolic: 1)
  [API_ARG 1] X7 (symbolic: 1)
  [API_ARG 2] X8 (symbolic: 1)
  [API_ARG 3] X9 (symbolic: 1)
[ASSIGN] Result: _result2 := -1 (symbolic placeholder)
[SEE] API call 'get_R' ready for actual execution

[ASSIGN] Evaluating: tmp_R_1 := get_R()
[SEE] Mapping base name 'tmp_R_' -> 'tmp_R_1'
[API_CALL] Executing API function: get_R
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_R
  [API_CALL] Executing function...
[GetRFunc] Fetching R...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_R_1
[ASSIGN] Result: tmp_R_1 := {}
[SEE] API call 'get_Owners' ready for actual execution

[ASSIGN] Evaluating: tmp_Owners_1 := get_Owners()
[SEE] Mapping base name 'tmp_Owners_' -> 'tmp_Owners_1'
[API_CALL] Executing API function: get_Owners
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Owners
  [API_CALL] Executing function...
[GetOwnersFunc] Fetching Owners...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Owners_1
[ASSIGN] Result: tmp_Owners_1 := {}
[SEE] Interruption at statement 39

[ASSERT] Evaluating: AND(in(_result2, dom(tmp_R_1)), =([](tmp_Owners_1, _result2), ownerEmail))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(_result2, dom(tmp_R_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result2
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_R_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Owners_1, _result2), ownerEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Owners_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: _result2
    [EVAL] Found in sigma: -1
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: -1
    [EVAL] Key not found in map
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail2'
    [EVAL] Found in sigma: X6
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, -1) X6)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: ownerEmail3 := input()
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X10
[ASSIGN] Result: ownerEmail3 := X10

[ASSIGN] Evaluating: restaurantId3 := input()
[SEE] Mapping base name 'restaurantId' -> 'restaurantId3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X11
[ASSIGN] Result: restaurantId3 := X11

[ASSIGN] Evaluating: itemName3 := input()
[SEE] Mapping base name 'itemName' -> 'itemName3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X12
[ASSIGN] Result: itemName3 := X12

[ASSIGN] Evaluating: itemPrice3 := input()
[SEE] Mapping base name 'itemPrice' -> 'itemPrice3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X13
[ASSIGN] Result: itemPrice3 := X13
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_0 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_0'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_M_0
[ASSIGN] Result: tmp_M_0 := {}

[ASSIGN] Evaluating: M_old := tmp_M_0
  [EVAL] Var lookup: tmp_M_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: M_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_3 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_3'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_3
[ASSIGN] Result: tmp_T_3 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_3 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_3'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_3
[ASSIGN] Result: tmp_Roles_3 := {}
[SEE] API call 'get_R' ready for actual execution

[ASSIGN] Evaluating: tmp_R_2 := get_R()
[SEE] Mapping base name 'tmp_R_' -> 'tmp_R_2'
[API_CALL] Executing API function: get_R
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_R
  [API_CALL] Executing function...
[GetRFunc] Fetching R...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_R_2
[ASSIGN] Result: tmp_R_2 := {}
[SEE] Interruption at statement 49

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_3)), =([](tmp_Roles_3, ownerEmail), OWNER), in(restaurantId, dom(tmp_R_2)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail3'
    [EVAL] Found in sigma: X10
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X10
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_3, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_3
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail3'
    [EVAL] Found in sigma: X10
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X10
    [EVAL] Key not found in map
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X10) OWNER)
    [EVAL] Arg[2]: in(restaurantId, dom(tmp_R_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId3'
    [EVAL] Found in sigma: X11
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_R_2
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X11
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'addMenuItem' with symbolic arguments - interruption point
[SEE] Interruption at statement 50

[ASSIGN] Evaluating: _result3 := addMenuItem(ownerEmail, restaurantId, itemName, itemPrice)
[SEE] Mapping base name '_result' -> '_result3'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail3'
    [EVAL] Found in sigma: X10
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId3'
    [EVAL] Found in sigma: X11
  [EVAL] Var lookup: itemName
    [EVAL] Resolved base name 'itemName' -> 'itemName3'
    [EVAL] Found in sigma: X12
  [EVAL] Var lookup: itemPrice
    [EVAL] Resolved base name 'itemPrice' -> 'itemPrice3'
    [EVAL] Found in sigma: X13
[API_CALL] addMenuItem has symbolic arguments - skipping actual execution
  [API_ARG 0] X10 (symbolic: 1)
  [API_ARG 1] X11 (symbolic: 1)
  [API_ARG 2] X12 (symbolic: 1)
  [API_ARG 3] X13 (symbolic: 1)
[ASSIGN] Result: _result3 := -1 (symbolic placeholder)
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_1 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_1'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_M_1
[ASSIGN] Result: tmp_M_1 := {}

[ASSERT] Evaluating: in(_result3, dom(tmp_M_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result3
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_M_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: ownerEmail4 := input()
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail4'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X14
[ASSIGN] Result: ownerEmail4 := X14

[ASSIGN] Evaluating: restaurantId4 := input()
[SEE] Mapping base name 'restaurantId' -> 'restaurantId4'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X15
[ASSIGN] Result: restaurantId4 := X15

[ASSIGN] Evaluating: itemName4 := input()
[SEE] Mapping base name 'itemName' -> 'itemName4'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X16
[ASSIGN] Result: itemName4 := X16

[ASSIGN] Evaluating: itemPrice4 := input()
[SEE] Mapping base name 'itemPrice' -> 'itemPrice4'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X17
[ASSIGN] Result: itemPrice4 := X17
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_2 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_2'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_M_2
[ASSIGN] Result: tmp_M_2 := {}

[ASSIGN] Evaluating: M_old := tmp_M_2
  [EVAL] Var lookup: tmp_M_2
    [EVAL] Found in sigma: {}
[ASSIGN] Result: M_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_4 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_4'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_4
[ASSIGN] Result: tmp_T_4 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_4 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_4'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_4
[ASSIGN] Result: tmp_Roles_4 := {}
[SEE] API call 'get_R' ready for actual execution

[ASSIGN] Evaluating: tmp_R_3 := get_R()
[SEE] Mapping base name 'tmp_R_' -> 'tmp_R_3'
[API_CALL] Executing API function: get_R
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_R
  [API_CALL] Executing function...
[GetRFunc] Fetching R...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_R_3
[ASSIGN] Result: tmp_R_3 := {}
[SEE] Interruption at statement 62

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_4)), =([](tmp_Roles_4, ownerEmail), OWNER), in(restaurantId, dom(tmp_R_3)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_4))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail4'
    [EVAL] Found in sigma: X14
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_4
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X14
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_4, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_4
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail4'
    [EVAL] Found in sigma: X14
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X14
    [EVAL] Key not found in map
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X14) OWNER)
    [EVAL] Arg[2]: in(restaurantId, dom(tmp_R_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId4'
    [EVAL] Found in sigma: X15
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_R_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X15
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'addMenuItem' with symbolic arguments - interruption point
[SEE] Interruption at statement 63

[ASSIGN] Evaluating: _result4 := addMenuItem(ownerEmail, restaurantId, itemName, itemPrice)
[SEE] Mapping base name '_result' -> '_result4'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail4'
    [EVAL] Found in sigma: X14
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId4'
    [EVAL] Found in sigma: X15
  [EVAL] Var lookup: itemName
    [EVAL] Resolved base name 'itemName' -> 'itemName4'
    [EVAL] Found in sigma: X16
  [EVAL] Var lookup: itemPrice
    [EVAL] Resolved base name 'itemPrice' -> 'itemPrice4'
    [EVAL] Found in sigma: X17
[API_CALL] addMenuItem has symbolic arguments - skipping actual execution
  [API_ARG 0] X14 (symbolic: 1)
  [API_ARG 1] X15 (symbolic: 1)
  [API_ARG 2] X16 (symbolic: 1)
  [API_ARG 3] X17 (symbolic: 1)
[ASSIGN] Result: _result4 := -1 (symbolic placeholder)
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_3 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_3'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_M_3
[ASSIGN] Result: tmp_M_3 := {}

[ASSERT] Evaluating: in(_result4, dom(tmp_M_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result4
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_M_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: ownerEmail5 := input()
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail5'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X18
[ASSIGN] Result: ownerEmail5 := X18

[ASSIGN] Evaluating: restaurantId5 := input()
[SEE] Mapping base name 'restaurantId' -> 'restaurantId5'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X19
[ASSIGN] Result: restaurantId5 := X19

[ASSIGN] Evaluating: itemName5 := input()
[SEE] Mapping base name 'itemName' -> 'itemName5'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X20
[ASSIGN] Result: itemName5 := X20

[ASSIGN] Evaluating: itemPrice5 := input()
[SEE] Mapping base name 'itemPrice' -> 'itemPrice5'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X21
[ASSIGN] Result: itemPrice5 := X21
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_4 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_4'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_M_4
[ASSIGN] Result: tmp_M_4 := {}

[ASSIGN] Evaluating: M_old := tmp_M_4
  [EVAL] Var lookup: tmp_M_4
    [EVAL] Found in sigma: {}
[ASSIGN] Result: M_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_5 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_5'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_5
[ASSIGN] Result: tmp_T_5 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_5 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_5'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_5
[ASSIGN] Result: tmp_Roles_5 := {}
[SEE] API call 'get_R' ready for actual execution

[ASSIGN] Evaluating: tmp_R_4 := get_R()
[SEE] Mapping base name 'tmp_R_' -> 'tmp_R_4'
[API_CALL] Executing API function: get_R
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_R
  [API_CALL] Executing function...
[GetRFunc] Fetching R...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_R_4
[ASSIGN] Result: tmp_R_4 := {}
[SEE] Interruption at statement 75

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_5)), =([](tmp_Roles_5, ownerEmail), OWNER), in(restaurantId, dom(tmp_R_4)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_5))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail5'
    [EVAL] Found in sigma: X18
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_5
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X18
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_5, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_5
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail5'
    [EVAL] Found in sigma: X18
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X18
    [EVAL] Key not found in map
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X18) OWNER)
    [EVAL] Arg[2]: in(restaurantId, dom(tmp_R_4))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId5'
    [EVAL] Found in sigma: X19
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_R_4
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X19
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'addMenuItem' with symbolic arguments - interruption point
[SEE] Interruption at statement 76

[ASSIGN] Evaluating: _result5 := addMenuItem(ownerEmail, restaurantId, itemName, itemPrice)
[SEE] Mapping base name '_result' -> '_result5'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail5'
    [EVAL] Found in sigma: X18
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId5'
    [EVAL] Found in sigma: X19
  [EVAL] Var lookup: itemName
    [EVAL] Resolved base name 'itemName' -> 'itemName5'
    [EVAL] Found in sigma: X20
  [EVAL] Var lookup: itemPrice
    [EVAL] Resolved base name 'itemPrice' -> 'itemPrice5'
    [EVAL] Found in sigma: X21
[API_CALL] addMenuItem has symbolic arguments - skipping actual execution
  [API_ARG 0] X18 (symbolic: 1)
  [API_ARG 1] X19 (symbolic: 1)
  [API_ARG 2] X20 (symbolic: 1)
  [API_ARG 3] X21 (symbolic: 1)
[ASSIGN] Result: _result5 := -1 (symbolic placeholder)
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_5 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_5'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_M_5
[ASSIGN] Result: tmp_M_5 := {}

[ASSERT] Evaluating: in(_result5, dom(tmp_M_5))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result5
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_M_5
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[SEE] Path Constraint: And(true, And(true, And(AND((= []({}, X0) X1), (= []({}, X0) OWNER)), And(false, And((= []({}, X4) -1), And(false, And(false, And(false, false))))))))
>>> generateCTC: After symex - Is abstract: 1, Has placeholders: 0

>>> generateCTC: STEP 3 - Generating values with sigma lookup
    [Found existing] _ -> _
    [Found existing] tmp_Roles_ -> tmp_Roles_0
    [Found existing] Roles_old -> Roles_old
    [Found existing] tmp_U_ -> tmp_U_0
    [Found existing] U_old -> U_old
    [Found existing] _result -> _result0
    [Found existing] tmp_T_ -> tmp_T_0
    [Found existing] T_old -> T_old
    [Found existing] tmp_Owners_ -> tmp_Owners_0
    [Found existing] Owners_old -> Owners_old
    [Found existing] tmp_R_ -> tmp_R_0
    [Found existing] R_old -> R_old
    [Found existing] tmp_M_ -> tmp_M_0
    [Found existing] M_old -> M_old
    ownerEmail0 = "owner@example.com"
    ownerPassword0 = "OwnerPass1!"
    ownerFullName0 = "Test Owner"
    ownerMobile0 = "5550000001"
    ownerEmail1 = (reusing ownerEmail) "owner@example.com"
    ownerPassword1 = (reusing ownerPassword) "OwnerPass1!"
    ownerEmail2 = (reusing ownerEmail) "owner@example.com"
    restaurantName2 = "Test Restaurant"
    restaurantAddress2 = "123 Restaurant Street"
    restaurantContact2 = "restaurant@test.com"
    ownerEmail3 = (reusing ownerEmail) "owner@example.com"
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] tmp_R_4 is empty map
    [findKeyFromMapInSigma] tmp_R_3 is empty map
    [findKeyFromMapInSigma] tmp_R_2 is empty map
    [findKeyFromMapInSigma] tmp_R_1 is empty map
    [findKeyFromMapInSigma] tmp_R_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_R_
    [DEFERRED] restaurantId - no restaurant in sigma yet
    restaurantId3 = "__NEEDS_RESTAURANT_ID__"
    itemName3 = "Delicious Dish"
    itemPrice3 = 150
    ownerEmail4 = (reusing ownerEmail) "owner@example.com"
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] tmp_R_4 is empty map
    [findKeyFromMapInSigma] tmp_R_3 is empty map
    [findKeyFromMapInSigma] tmp_R_2 is empty map
    [findKeyFromMapInSigma] tmp_R_1 is empty map
    [findKeyFromMapInSigma] tmp_R_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_R_
    [DEFERRED] restaurantId - no restaurant in sigma yet
    restaurantId4 = "__NEEDS_RESTAURANT_ID__"
    itemName4 = (reusing itemName) "Delicious Dish"
    itemPrice4 = (reusing itemPrice) 150
    ownerEmail5 = (reusing ownerEmail) "owner@example.com"
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] tmp_R_4 is empty map
    [findKeyFromMapInSigma] tmp_R_3 is empty map
    [findKeyFromMapInSigma] tmp_R_2 is empty map
    [findKeyFromMapInSigma] tmp_R_1 is empty map
    [findKeyFromMapInSigma] tmp_R_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_R_
    [DEFERRED] restaurantId - no restaurant in sigma yet
    restaurantId5 = "__NEEDS_RESTAURANT_ID__"
    itemName5 = (reusing itemName) "Delicious Dish"
    itemPrice5 = (reusing itemPrice) 150

>>> generateCTC: STEP 4 - Resolving placeholders from sigma
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] tmp_R_4 is empty map
    [findKeyFromMapInSigma] tmp_R_3 is empty map
    [findKeyFromMapInSigma] tmp_R_2 is empty map
    [findKeyFromMapInSigma] tmp_R_1 is empty map
    [findKeyFromMapInSigma] tmp_R_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_R_
    [STILL PENDING] restaurantId3 - keeping placeholder for next iteration
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] tmp_R_4 is empty map
    [findKeyFromMapInSigma] tmp_R_3 is empty map
    [findKeyFromMapInSigma] tmp_R_2 is empty map
    [findKeyFromMapInSigma] tmp_R_1 is empty map
    [findKeyFromMapInSigma] tmp_R_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_R_
    [STILL PENDING] restaurantId4 - keeping placeholder for next iteration
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] tmp_R_4 is empty map
    [findKeyFromMapInSigma] tmp_R_3 is empty map
    [findKeyFromMapInSigma] tmp_R_2 is empty map
    [findKeyFromMapInSigma] tmp_R_1 is empty map
    [findKeyFromMapInSigma] tmp_R_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_R_
    [STILL PENDING] restaurantId5 - keeping placeholder for next iteration

>>> generateCTC: STEP 5 - Recursing with 22 concrete values

========================================
>>> generateCTC: Starting iteration
========================================
>>> generateCTC: Program needs processing
>>> generateCTC: Concrete values provided: 22
>>> generateCTC: Is abstract: 1
>>> generateCTC: Has placeholders: 0

>>> generateCTC: STEP 1 - Rewriting ATC with concrete values

>>> generateCTC: STEP 2 - Running symbolic execution
[SEE] API call 'reset' ready for actual execution

[ASSIGN] Evaluating: _ := reset()
[API_CALL] Executing API function: reset
  [API_CALL] Getting function from factory...
[Factory] Creating function: reset
  [API_CALL] Executing function...
[ResetFunc] Clearing all collections...
[HttpClient] POST /api/test/reset -> 200
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _
[ASSIGN] Result: _ := 200

[ASSIGN] Evaluating: ownerEmail0 := "owner@example.com"
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail0'
  [EVAL] String: "owner@example.com"
[ASSIGN] Result: ownerEmail0 := "owner@example.com"

[ASSIGN] Evaluating: ownerPassword0 := "OwnerPass1!"
[SEE] Mapping base name 'ownerPassword' -> 'ownerPassword0'
  [EVAL] String: "OwnerPass1!"
[ASSIGN] Result: ownerPassword0 := "OwnerPass1!"

[ASSIGN] Evaluating: ownerFullName0 := "Test Owner"
[SEE] Mapping base name 'ownerFullName' -> 'ownerFullName0'
  [EVAL] String: "Test Owner"
[ASSIGN] Result: ownerFullName0 := "Test Owner"

[ASSIGN] Evaluating: ownerMobile0 := "5550000001"
[SEE] Mapping base name 'ownerMobile' -> 'ownerMobile0'
  [EVAL] String: "5550000001"
[ASSIGN] Result: ownerMobile0 := "5550000001"
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_0 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_0'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_0
[ASSIGN] Result: tmp_Roles_0 := {}

[ASSIGN] Evaluating: Roles_old := tmp_Roles_0
  [EVAL] Var lookup: tmp_Roles_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Roles_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_0 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_0'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_0
[ASSIGN] Result: tmp_U_0 := {}

[ASSIGN] Evaluating: U_old := tmp_U_0
  [EVAL] Var lookup: tmp_U_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: U_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_1 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_1'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_1
[ASSIGN] Result: tmp_U_1 := {}

[ASSUME] Evaluating: not_in(ownerEmail, dom(tmp_U_1))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail0'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
[ASSUME] Adding constraint: true
[SEE] API call 'registerOwner' ready for actual execution

[ASSIGN] Evaluating: _result0 := registerOwner(ownerEmail, ownerPassword, ownerFullName, ownerMobile)
[SEE] Mapping base name '_result' -> '_result0'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail0'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] Var lookup: ownerPassword
    [EVAL] Resolved base name 'ownerPassword' -> 'ownerPassword0'
    [EVAL] Found in sigma: "OwnerPass1!"
  [EVAL] Var lookup: ownerFullName
    [EVAL] Resolved base name 'ownerFullName' -> 'ownerFullName0'
    [EVAL] Found in sigma: "Test Owner"
  [EVAL] Var lookup: ownerMobile
    [EVAL] Resolved base name 'ownerMobile' -> 'ownerMobile0'
    [EVAL] Found in sigma: "5550000001"
[API_CALL] Executing API function: registerOwner
  [API_ARG] "owner@example.com"
  [API_ARG] "OwnerPass1!"
  [API_ARG] "Test Owner"
  [API_ARG] "5550000001"
  [API_CALL] Getting function from factory...
[Factory] Creating function: registerOwner
  [API_CALL] Executing function...
[RegisterOwnerFunc] Registering owner: owner@example.com
[HttpClient] POST /api/auth/register -> 201
  [API_CALL] Function returned: 201
  [API_CALL] Storing result in variable: _result0
[ASSIGN] Result: _result0 := 201
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_2 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_2'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {owner@example.com -> "OwnerPass1!"}
  [API_CALL] Storing result in variable: tmp_U_2
[ASSIGN] Result: tmp_U_2 := {owner@example.com -> "OwnerPass1!"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_1 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_1'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {owner@example.com -> "restaurant_owner"}
  [API_CALL] Storing result in variable: tmp_Roles_1
[ASSIGN] Result: tmp_Roles_1 := {owner@example.com -> "restaurant_owner"}

[ASSERT] Evaluating: AND(=([](tmp_U_2, ownerEmail), ownerPassword), =([](tmp_Roles_1, ownerEmail), OWNER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: =([](tmp_U_2, ownerEmail), ownerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_2
    [EVAL] Found in sigma: {owner@example.com -> "OwnerPass1!"}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail0'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Map expr evaluated: {owner@example.com -> "OwnerPass1!"}
    [EVAL] Key expr evaluated: "owner@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "OwnerPass1!"
  [EVAL] Var lookup: ownerPassword
    [EVAL] Resolved base name 'ownerPassword' -> 'ownerPassword0'
    [EVAL] Found in sigma: "OwnerPass1!"
    [EVAL] Eq result: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_1, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_1
    [EVAL] Found in sigma: {owner@example.com -> "restaurant_owner"}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail0'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Map expr evaluated: {owner@example.com -> "restaurant_owner"}
    [EVAL] Key expr evaluated: "owner@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "restaurant_owner"
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "restaurant_owner" OWNER)
    [EVAL] FuncCall result: AND(true, (= "restaurant_owner" OWNER))
[ASSERT] Result: AND(true, (= "restaurant_owner" OWNER))
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: ownerEmail1 := "owner@example.com"
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail1'
  [EVAL] String: "owner@example.com"
[ASSIGN] Result: ownerEmail1 := "owner@example.com"

[ASSIGN] Evaluating: ownerPassword1 := "OwnerPass1!"
[SEE] Mapping base name 'ownerPassword' -> 'ownerPassword1'
  [EVAL] String: "OwnerPass1!"
[ASSIGN] Result: ownerPassword1 := "OwnerPass1!"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_0 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_0'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
  [API_CALL] Storing result in variable: tmp_T_0
[ASSIGN] Result: tmp_T_0 := {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}

[ASSIGN] Evaluating: T_old := tmp_T_0
  [EVAL] Var lookup: tmp_T_0
    [EVAL] Found in sigma: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
[ASSIGN] Result: T_old := {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_3 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_3'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {owner@example.com -> "OwnerPass1!"}
  [API_CALL] Storing result in variable: tmp_U_3
[ASSIGN] Result: tmp_U_3 := {owner@example.com -> "OwnerPass1!"}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_4 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_4'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {owner@example.com -> "OwnerPass1!"}
  [API_CALL] Storing result in variable: tmp_U_4
[ASSIGN] Result: tmp_U_4 := {owner@example.com -> "OwnerPass1!"}

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_U_3)), =([](tmp_U_4, ownerEmail), ownerPassword))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_U_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail1'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_3
    [EVAL] Found in sigma: {owner@example.com -> "OwnerPass1!"}
    [EVAL] Map expr evaluated: {owner@example.com -> "OwnerPass1!"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"owner@example.com"}
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_U_4, ownerEmail), ownerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_4
    [EVAL] Found in sigma: {owner@example.com -> "OwnerPass1!"}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail1'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Map expr evaluated: {owner@example.com -> "OwnerPass1!"}
    [EVAL] Key expr evaluated: "owner@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "OwnerPass1!"
  [EVAL] Var lookup: ownerPassword
    [EVAL] Resolved base name 'ownerPassword' -> 'ownerPassword1'
    [EVAL] Found in sigma: "OwnerPass1!"
    [EVAL] Eq result: true
    [EVAL] Arg[1] result: true
    [EVAL] FuncCall result: AND(...) = true
[ASSUME] Adding constraint: true
[SEE] API call 'login' ready for actual execution

[ASSIGN] Evaluating: _result1 := login(ownerEmail, ownerPassword)
[SEE] Mapping base name '_result' -> '_result1'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail1'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] Var lookup: ownerPassword
    [EVAL] Resolved base name 'ownerPassword' -> 'ownerPassword1'
    [EVAL] Found in sigma: "OwnerPass1!"
[API_CALL] Executing API function: login
  [API_ARG] "owner@example.com"
  [API_ARG] "OwnerPass1!"
  [API_CALL] Getting function from factory...
[Factory] Creating function: login
  [API_CALL] Executing function...
[LoginFunc] Logging in: owner@example.com
[HttpClient] POST /api/auth/login -> 200
[LoginFunc] Token received for: owner@example.com
  [API_CALL] Function returned: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"
  [API_CALL] Storing result in variable: _result1
[ASSIGN] Result: _result1 := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_1 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_1'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
  [API_CALL] Storing result in variable: tmp_T_1
[ASSIGN] Result: tmp_T_1 := {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}

[ASSERT] Evaluating: =([](tmp_T_1, ownerEmail), _result1)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_T_1
    [EVAL] Found in sigma: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail1'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Map expr evaluated: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
    [EVAL] Key expr evaluated: "owner@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"
  [EVAL] Var lookup: _result1
    [EVAL] Found in sigma: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"
    [EVAL] Eq result: true
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[ASSIGN] Evaluating: ownerEmail2 := "owner@example.com"
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail2'
  [EVAL] String: "owner@example.com"
[ASSIGN] Result: ownerEmail2 := "owner@example.com"

[ASSIGN] Evaluating: restaurantName2 := "Test Restaurant"
[SEE] Mapping base name 'restaurantName' -> 'restaurantName2'
  [EVAL] String: "Test Restaurant"
[ASSIGN] Result: restaurantName2 := "Test Restaurant"

[ASSIGN] Evaluating: restaurantAddress2 := "123 Restaurant Street"
[SEE] Mapping base name 'restaurantAddress' -> 'restaurantAddress2'
  [EVAL] String: "123 Restaurant Street"
[ASSIGN] Result: restaurantAddress2 := "123 Restaurant Street"

[ASSIGN] Evaluating: restaurantContact2 := "restaurant@test.com"
[SEE] Mapping base name 'restaurantContact' -> 'restaurantContact2'
  [EVAL] String: "restaurant@test.com"
[ASSIGN] Result: restaurantContact2 := "restaurant@test.com"
[SEE] API call 'get_Owners' ready for actual execution

[ASSIGN] Evaluating: tmp_Owners_0 := get_Owners()
[SEE] Mapping base name 'tmp_Owners_' -> 'tmp_Owners_0'
[API_CALL] Executing API function: get_Owners
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Owners
  [API_CALL] Executing function...
[GetOwnersFunc] Fetching Owners...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Owners_0
[ASSIGN] Result: tmp_Owners_0 := {}

[ASSIGN] Evaluating: Owners_old := tmp_Owners_0
  [EVAL] Var lookup: tmp_Owners_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Owners_old := {}
[SEE] API call 'get_R' ready for actual execution

[ASSIGN] Evaluating: tmp_R_0 := get_R()
[SEE] Mapping base name 'tmp_R_' -> 'tmp_R_0'
[API_CALL] Executing API function: get_R
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_R
  [API_CALL] Executing function...
[GetRFunc] Fetching R...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_R_0
[ASSIGN] Result: tmp_R_0 := {}

[ASSIGN] Evaluating: R_old := tmp_R_0
  [EVAL] Var lookup: tmp_R_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: R_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_2 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_2'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
  [API_CALL] Storing result in variable: tmp_T_2
[ASSIGN] Result: tmp_T_2 := {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_2 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_2'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {owner@example.com -> "restaurant_owner"}
  [API_CALL] Storing result in variable: tmp_Roles_2
[ASSIGN] Result: tmp_Roles_2 := {owner@example.com -> "restaurant_owner"}

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_2)), =([](tmp_Roles_2, ownerEmail), OWNER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail2'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_2
    [EVAL] Found in sigma: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
    [EVAL] Map expr evaluated: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"owner@example.com"}
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_2, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_2
    [EVAL] Found in sigma: {owner@example.com -> "restaurant_owner"}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail2'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Map expr evaluated: {owner@example.com -> "restaurant_owner"}
    [EVAL] Key expr evaluated: "owner@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "restaurant_owner"
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "restaurant_owner" OWNER)
    [EVAL] FuncCall result: AND(true, (= "restaurant_owner" OWNER))
[ASSUME] Adding constraint: AND(true, (= "restaurant_owner" OWNER))
[SEE] API call 'createRestaurant' ready for actual execution

[ASSIGN] Evaluating: _result2 := createRestaurant(ownerEmail, restaurantName, restaurantAddress, restaurantContact)
[SEE] Mapping base name '_result' -> '_result2'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail2'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] Var lookup: restaurantName
    [EVAL] Resolved base name 'restaurantName' -> 'restaurantName2'
    [EVAL] Found in sigma: "Test Restaurant"
  [EVAL] Var lookup: restaurantAddress
    [EVAL] Resolved base name 'restaurantAddress' -> 'restaurantAddress2'
    [EVAL] Found in sigma: "123 Restaurant Street"
  [EVAL] Var lookup: restaurantContact
    [EVAL] Resolved base name 'restaurantContact' -> 'restaurantContact2'
    [EVAL] Found in sigma: "restaurant@test.com"
[API_CALL] Executing API function: createRestaurant
  [API_ARG] "owner@example.com"
  [API_ARG] "Test Restaurant"
  [API_ARG] "123 Restaurant Street"
  [API_ARG] "restaurant@test.com"
  [API_CALL] Getting function from factory...
[Factory] Creating function: createRestaurant
  [API_CALL] Executing function...
[CreateRestaurantFunc] owner@example.com creating restaurant: Test Restaurant
[CreateRestaurantFunc] Request body: {
  "address": {
    "city": "TestCity",
    "state": "TestState",
    "street": "123 Restaurant Street",
    "zipCode": "12345"
  },
  "contact": {
    "email": "restaurant@test.com",
    "phone": "1234567890"
  },
  "cuisineTypes": [
    "Indian",
    "Continental"
  ],
  "hours": {
    "closing": "22:00",
    "opening": "09:00"
  },
  "name": "Test Restaurant"
}
[HttpClient] POST /api/restaurants -> 201
[CreateRestaurantFunc] Response status: 201
[CreateRestaurantFunc] Restaurant created: 696b451bac7475a04fb8330e
  [API_CALL] Function returned: "696b451bac7475a04fb8330e"
  [API_CALL] Storing result in variable: _result2
[ASSIGN] Result: _result2 := "696b451bac7475a04fb8330e"
[SEE] API call 'get_R' ready for actual execution

[ASSIGN] Evaluating: tmp_R_1 := get_R()
[SEE] Mapping base name 'tmp_R_' -> 'tmp_R_1'
[API_CALL] Executing API function: get_R
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_R
  [API_CALL] Executing function...
[GetRFunc] Fetching R...
  [API_CALL] Function returned: {696b451bac7475a04fb8330e -> ""Test Restaurant""}
  [API_CALL] Storing result in variable: tmp_R_1
[ASSIGN] Result: tmp_R_1 := {696b451bac7475a04fb8330e -> ""Test Restaurant""}
[SEE] API call 'get_Owners' ready for actual execution

[ASSIGN] Evaluating: tmp_Owners_1 := get_Owners()
[SEE] Mapping base name 'tmp_Owners_' -> 'tmp_Owners_1'
[API_CALL] Executing API function: get_Owners
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Owners
  [API_CALL] Executing function...
[GetOwnersFunc] Fetching Owners...
  [API_CALL] Function returned: {696b451bac7475a04fb8330e -> "owner@example.com"}
  [API_CALL] Storing result in variable: tmp_Owners_1
[ASSIGN] Result: tmp_Owners_1 := {696b451bac7475a04fb8330e -> "owner@example.com"}

[ASSERT] Evaluating: AND(in(_result2, dom(tmp_R_1)), =([](tmp_Owners_1, _result2), ownerEmail))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(_result2, dom(tmp_R_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result2
    [EVAL] Found in sigma: "696b451bac7475a04fb8330e"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_R_1
    [EVAL] Found in sigma: {696b451bac7475a04fb8330e -> ""Test Restaurant""}
    [EVAL] Map expr evaluated: {696b451bac7475a04fb8330e -> ""Test Restaurant""}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696b451bac7475a04fb8330e"
    [EVAL] Set: {"696b451bac7475a04fb8330e"}
    [EVAL] Element: "696b451bac7475a04fb8330e"
    [EVAL] Set: {"696b451bac7475a04fb8330e"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Owners_1, _result2), ownerEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Owners_1
    [EVAL] Found in sigma: {696b451bac7475a04fb8330e -> "owner@example.com"}
  [EVAL] Var lookup: _result2
    [EVAL] Found in sigma: "696b451bac7475a04fb8330e"
    [EVAL] Map expr evaluated: {696b451bac7475a04fb8330e -> "owner@example.com"}
    [EVAL] Key expr evaluated: "696b451bac7475a04fb8330e"
    [EVAL] Key found in map, returning value
  [EVAL] String: "owner@example.com"
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail2'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Eq result: true
    [EVAL] Arg[1] result: true
    [EVAL] FuncCall result: AND(...) = true
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[ASSIGN] Evaluating: ownerEmail3 := "owner@example.com"
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail3'
  [EVAL] String: "owner@example.com"
[ASSIGN] Result: ownerEmail3 := "owner@example.com"

[ASSIGN] Evaluating: restaurantId3 := "__NEEDS_RESTAURANT_ID__"
[SEE] Mapping base name 'restaurantId' -> 'restaurantId3'
  [EVAL] String: "__NEEDS_RESTAURANT_ID__"
[ASSIGN] Result: restaurantId3 := "__NEEDS_RESTAURANT_ID__"

[ASSIGN] Evaluating: itemName3 := "Delicious Dish"
[SEE] Mapping base name 'itemName' -> 'itemName3'
  [EVAL] String: "Delicious Dish"
[ASSIGN] Result: itemName3 := "Delicious Dish"

[ASSIGN] Evaluating: itemPrice3 := 150
[SEE] Mapping base name 'itemPrice' -> 'itemPrice3'
  [EVAL] Num: 150
[ASSIGN] Result: itemPrice3 := 150
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_0 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_0'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_M_0
[ASSIGN] Result: tmp_M_0 := {}

[ASSIGN] Evaluating: M_old := tmp_M_0
  [EVAL] Var lookup: tmp_M_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: M_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_3 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_3'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
  [API_CALL] Storing result in variable: tmp_T_3
[ASSIGN] Result: tmp_T_3 := {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_3 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_3'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {owner@example.com -> "restaurant_owner"}
  [API_CALL] Storing result in variable: tmp_Roles_3
[ASSIGN] Result: tmp_Roles_3 := {owner@example.com -> "restaurant_owner"}
[SEE] API call 'get_R' ready for actual execution

[ASSIGN] Evaluating: tmp_R_2 := get_R()
[SEE] Mapping base name 'tmp_R_' -> 'tmp_R_2'
[API_CALL] Executing API function: get_R
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_R
  [API_CALL] Executing function...
[GetRFunc] Fetching R...
  [API_CALL] Function returned: {696b451bac7475a04fb8330e -> ""Test Restaurant""}
  [API_CALL] Storing result in variable: tmp_R_2
[ASSIGN] Result: tmp_R_2 := {696b451bac7475a04fb8330e -> ""Test Restaurant""}

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_3)), =([](tmp_Roles_3, ownerEmail), OWNER), in(restaurantId, dom(tmp_R_2)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail3'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_3
    [EVAL] Found in sigma: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
    [EVAL] Map expr evaluated: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"owner@example.com"}
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_3, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_3
    [EVAL] Found in sigma: {owner@example.com -> "restaurant_owner"}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail3'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Map expr evaluated: {owner@example.com -> "restaurant_owner"}
    [EVAL] Key expr evaluated: "owner@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "restaurant_owner"
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "restaurant_owner" OWNER)
    [EVAL] Arg[2]: in(restaurantId, dom(tmp_R_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId3'
    [EVAL] Found placeholder __NEEDS_RESTAURANT_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] tmp_R_0 is empty map
    [findKeyFromMapInSigma] Found tmp_R_1 with 1 entries, key: 696b451bac7475a04fb8330e
    [findKeyFromMapInSigma] Found tmp_R_2 with 1 entries, key: 696b451bac7475a04fb8330e
    [findKeyFromMapInSigma] tmp_R_3 is empty map
    [findKeyFromMapInSigma] tmp_R_4 is empty map
    [EVAL] Resolved to: 696b451bac7475a04fb8330e
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_R_2
    [EVAL] Found in sigma: {696b451bac7475a04fb8330e -> ""Test Restaurant""}
    [EVAL] Map expr evaluated: {696b451bac7475a04fb8330e -> ""Test Restaurant""}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696b451bac7475a04fb8330e"
    [EVAL] Set: {"696b451bac7475a04fb8330e"}
    [EVAL] Element: "696b451bac7475a04fb8330e"
    [EVAL] Set: {"696b451bac7475a04fb8330e"}
    [EVAL] Element found in set: true
    [EVAL] Arg[2] result: true
    [EVAL] FuncCall result: AND(true, (= "restaurant_owner" OWNER), true)
[ASSUME] Adding constraint: AND(true, (= "restaurant_owner" OWNER), true)
[SEE] API call 'addMenuItem' ready for actual execution

[ASSIGN] Evaluating: _result3 := addMenuItem(ownerEmail, restaurantId, itemName, itemPrice)
[SEE] Mapping base name '_result' -> '_result3'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail3'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId3'
    [EVAL] Found in sigma: "696b451bac7475a04fb8330e"
  [EVAL] Var lookup: itemName
    [EVAL] Resolved base name 'itemName' -> 'itemName3'
    [EVAL] Found in sigma: "Delicious Dish"
  [EVAL] Var lookup: itemPrice
    [EVAL] Resolved base name 'itemPrice' -> 'itemPrice3'
    [EVAL] Found in sigma: 150
[API_CALL] Executing API function: addMenuItem
  [API_ARG] "owner@example.com"
  [API_ARG] "696b451bac7475a04fb8330e"
  [API_ARG] "Delicious Dish"
  [API_ARG] 150
  [API_CALL] Getting function from factory...
[Factory] Creating function: addMenuItem
  [API_CALL] Executing function...
[AddMenuItemFunc] owner@example.com adding menu item: Delicious Dish to restaurant 696b451bac7475a04fb8330e
[HttpClient] POST /api/menu -> 201
[AddMenuItemFunc] Menu item created: 696b451bac7475a04fb8331a
  [API_CALL] Function returned: 201
  [API_CALL] Storing result in variable: _result3
[ASSIGN] Result: _result3 := 201
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_1 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_1'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
[GetMFunc] Menu item: 696b451bac7475a04fb8331a -> restaurant: 696b451bac7475a04fb8330e
  [API_CALL] Function returned: {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e"}
  [API_CALL] Storing result in variable: tmp_M_1
[ASSIGN] Result: tmp_M_1 := {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e"}

[ASSERT] Evaluating: in(_result3, dom(tmp_M_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result3
    [EVAL] Found in sigma: 201
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_M_1
    [EVAL] Found in sigma: {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e"}
    [EVAL] Map expr evaluated: {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696b451bac7475a04fb8331a"
    [EVAL] Set: {"696b451bac7475a04fb8331a"}
    [EVAL] Element: 201
    [EVAL] Set: {"696b451bac7475a04fb8331a"}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: ownerEmail4 := "owner@example.com"
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail4'
  [EVAL] String: "owner@example.com"
[ASSIGN] Result: ownerEmail4 := "owner@example.com"

[ASSIGN] Evaluating: restaurantId4 := "__NEEDS_RESTAURANT_ID__"
[SEE] Mapping base name 'restaurantId' -> 'restaurantId4'
  [EVAL] String: "__NEEDS_RESTAURANT_ID__"
[ASSIGN] Result: restaurantId4 := "__NEEDS_RESTAURANT_ID__"

[ASSIGN] Evaluating: itemName4 := "Delicious Dish"
[SEE] Mapping base name 'itemName' -> 'itemName4'
  [EVAL] String: "Delicious Dish"
[ASSIGN] Result: itemName4 := "Delicious Dish"

[ASSIGN] Evaluating: itemPrice4 := 150
[SEE] Mapping base name 'itemPrice' -> 'itemPrice4'
  [EVAL] Num: 150
[ASSIGN] Result: itemPrice4 := 150
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_2 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_2'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
[GetMFunc] Menu item: 696b451bac7475a04fb8331a -> restaurant: 696b451bac7475a04fb8330e
  [API_CALL] Function returned: {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e"}
  [API_CALL] Storing result in variable: tmp_M_2
[ASSIGN] Result: tmp_M_2 := {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e"}

[ASSIGN] Evaluating: M_old := tmp_M_2
  [EVAL] Var lookup: tmp_M_2
    [EVAL] Found in sigma: {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e"}
[ASSIGN] Result: M_old := {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e"}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_4 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_4'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
  [API_CALL] Storing result in variable: tmp_T_4
[ASSIGN] Result: tmp_T_4 := {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_4 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_4'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {owner@example.com -> "restaurant_owner"}
  [API_CALL] Storing result in variable: tmp_Roles_4
[ASSIGN] Result: tmp_Roles_4 := {owner@example.com -> "restaurant_owner"}
[SEE] API call 'get_R' ready for actual execution

[ASSIGN] Evaluating: tmp_R_3 := get_R()
[SEE] Mapping base name 'tmp_R_' -> 'tmp_R_3'
[API_CALL] Executing API function: get_R
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_R
  [API_CALL] Executing function...
[GetRFunc] Fetching R...
  [API_CALL] Function returned: {696b451bac7475a04fb8330e -> ""Test Restaurant""}
  [API_CALL] Storing result in variable: tmp_R_3
[ASSIGN] Result: tmp_R_3 := {696b451bac7475a04fb8330e -> ""Test Restaurant""}

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_4)), =([](tmp_Roles_4, ownerEmail), OWNER), in(restaurantId, dom(tmp_R_3)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_4))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail4'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_4
    [EVAL] Found in sigma: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
    [EVAL] Map expr evaluated: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"owner@example.com"}
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_4, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_4
    [EVAL] Found in sigma: {owner@example.com -> "restaurant_owner"}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail4'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Map expr evaluated: {owner@example.com -> "restaurant_owner"}
    [EVAL] Key expr evaluated: "owner@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "restaurant_owner"
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "restaurant_owner" OWNER)
    [EVAL] Arg[2]: in(restaurantId, dom(tmp_R_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId4'
    [EVAL] Found placeholder __NEEDS_RESTAURANT_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] tmp_R_0 is empty map
    [findKeyFromMapInSigma] Found tmp_R_1 with 1 entries, key: 696b451bac7475a04fb8330e
    [findKeyFromMapInSigma] Found tmp_R_2 with 1 entries, key: 696b451bac7475a04fb8330e
    [findKeyFromMapInSigma] Found tmp_R_3 with 1 entries, key: 696b451bac7475a04fb8330e
    [findKeyFromMapInSigma] tmp_R_4 is empty map
    [EVAL] Resolved to: 696b451bac7475a04fb8330e
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_R_3
    [EVAL] Found in sigma: {696b451bac7475a04fb8330e -> ""Test Restaurant""}
    [EVAL] Map expr evaluated: {696b451bac7475a04fb8330e -> ""Test Restaurant""}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696b451bac7475a04fb8330e"
    [EVAL] Set: {"696b451bac7475a04fb8330e"}
    [EVAL] Element: "696b451bac7475a04fb8330e"
    [EVAL] Set: {"696b451bac7475a04fb8330e"}
    [EVAL] Element found in set: true
    [EVAL] Arg[2] result: true
    [EVAL] FuncCall result: AND(true, (= "restaurant_owner" OWNER), true)
[ASSUME] Adding constraint: AND(true, (= "restaurant_owner" OWNER), true)
[SEE] API call 'addMenuItem' ready for actual execution

[ASSIGN] Evaluating: _result4 := addMenuItem(ownerEmail, restaurantId, itemName, itemPrice)
[SEE] Mapping base name '_result' -> '_result4'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail4'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId4'
    [EVAL] Found in sigma: "696b451bac7475a04fb8330e"
  [EVAL] Var lookup: itemName
    [EVAL] Resolved base name 'itemName' -> 'itemName4'
    [EVAL] Found in sigma: "Delicious Dish"
  [EVAL] Var lookup: itemPrice
    [EVAL] Resolved base name 'itemPrice' -> 'itemPrice4'
    [EVAL] Found in sigma: 150
[API_CALL] Executing API function: addMenuItem
  [API_ARG] "owner@example.com"
  [API_ARG] "696b451bac7475a04fb8330e"
  [API_ARG] "Delicious Dish"
  [API_ARG] 150
  [API_CALL] Getting function from factory...
[Factory] Creating function: addMenuItem
  [API_CALL] Executing function...
[AddMenuItemFunc] owner@example.com adding menu item: Delicious Dish to restaurant 696b451bac7475a04fb8330e
[HttpClient] POST /api/menu -> 201
[AddMenuItemFunc] Menu item created: 696b451bac7475a04fb83324
  [API_CALL] Function returned: 201
  [API_CALL] Storing result in variable: _result4
[ASSIGN] Result: _result4 := 201
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_3 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_3'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
[GetMFunc] Menu item: 696b451bac7475a04fb8331a -> restaurant: 696b451bac7475a04fb8330e
[GetMFunc] Menu item: 696b451bac7475a04fb83324 -> restaurant: 696b451bac7475a04fb8330e
  [API_CALL] Function returned: {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e", 696b451bac7475a04fb83324 -> "696b451bac7475a04fb8330e"}
  [API_CALL] Storing result in variable: tmp_M_3
[ASSIGN] Result: tmp_M_3 := {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e", 696b451bac7475a04fb83324 -> "696b451bac7475a04fb8330e"}

[ASSERT] Evaluating: in(_result4, dom(tmp_M_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result4
    [EVAL] Found in sigma: 201
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_M_3
    [EVAL] Found in sigma: {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e", 696b451bac7475a04fb83324 -> "696b451bac7475a04fb8330e"}
    [EVAL] Map expr evaluated: {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e", 696b451bac7475a04fb83324 -> "696b451bac7475a04fb8330e"}
    [EVAL] Domain has 2 keys
    [EVAL] Element: "696b451bac7475a04fb8331a"
    [EVAL] Element: "696b451bac7475a04fb83324"
    [EVAL] Set: {"696b451bac7475a04fb8331a", "696b451bac7475a04fb83324"}
    [EVAL] Element: 201
    [EVAL] Set: {"696b451bac7475a04fb8331a", "696b451bac7475a04fb83324"}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: ownerEmail5 := "owner@example.com"
[SEE] Mapping base name 'ownerEmail' -> 'ownerEmail5'
  [EVAL] String: "owner@example.com"
[ASSIGN] Result: ownerEmail5 := "owner@example.com"

[ASSIGN] Evaluating: restaurantId5 := "__NEEDS_RESTAURANT_ID__"
[SEE] Mapping base name 'restaurantId' -> 'restaurantId5'
  [EVAL] String: "__NEEDS_RESTAURANT_ID__"
[ASSIGN] Result: restaurantId5 := "__NEEDS_RESTAURANT_ID__"

[ASSIGN] Evaluating: itemName5 := "Delicious Dish"
[SEE] Mapping base name 'itemName' -> 'itemName5'
  [EVAL] String: "Delicious Dish"
[ASSIGN] Result: itemName5 := "Delicious Dish"

[ASSIGN] Evaluating: itemPrice5 := 150
[SEE] Mapping base name 'itemPrice' -> 'itemPrice5'
  [EVAL] Num: 150
[ASSIGN] Result: itemPrice5 := 150
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_4 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_4'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
[GetMFunc] Menu item: 696b451bac7475a04fb8331a -> restaurant: 696b451bac7475a04fb8330e
[GetMFunc] Menu item: 696b451bac7475a04fb83324 -> restaurant: 696b451bac7475a04fb8330e
  [API_CALL] Function returned: {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e", 696b451bac7475a04fb83324 -> "696b451bac7475a04fb8330e"}
  [API_CALL] Storing result in variable: tmp_M_4
[ASSIGN] Result: tmp_M_4 := {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e", 696b451bac7475a04fb83324 -> "696b451bac7475a04fb8330e"}

[ASSIGN] Evaluating: M_old := tmp_M_4
  [EVAL] Var lookup: tmp_M_4
    [EVAL] Found in sigma: {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e", 696b451bac7475a04fb83324 -> "696b451bac7475a04fb8330e"}
[ASSIGN] Result: M_old := {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e", 696b451bac7475a04fb83324 -> "696b451bac7475a04fb8330e"}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_5 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_5'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
  [API_CALL] Storing result in variable: tmp_T_5
[ASSIGN] Result: tmp_T_5 := {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_5 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_5'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {owner@example.com -> "restaurant_owner"}
  [API_CALL] Storing result in variable: tmp_Roles_5
[ASSIGN] Result: tmp_Roles_5 := {owner@example.com -> "restaurant_owner"}
[SEE] API call 'get_R' ready for actual execution

[ASSIGN] Evaluating: tmp_R_4 := get_R()
[SEE] Mapping base name 'tmp_R_' -> 'tmp_R_4'
[API_CALL] Executing API function: get_R
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_R
  [API_CALL] Executing function...
[GetRFunc] Fetching R...
  [API_CALL] Function returned: {696b451bac7475a04fb8330e -> ""Test Restaurant""}
  [API_CALL] Storing result in variable: tmp_R_4
[ASSIGN] Result: tmp_R_4 := {696b451bac7475a04fb8330e -> ""Test Restaurant""}

[ASSUME] Evaluating: AND(in(ownerEmail, dom(tmp_T_5)), =([](tmp_Roles_5, ownerEmail), OWNER), in(restaurantId, dom(tmp_R_4)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(ownerEmail, dom(tmp_T_5))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail5'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_5
    [EVAL] Found in sigma: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
    [EVAL] Map expr evaluated: {owner@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZiNDUxYmFjNzQ3NWEwNGZiODMyZmUiLCJpYXQiOjE3Njg2Mzc3MjMsImV4cCI6MTc2OTI0MjUyM30.eBSNizB6fAhZTpm69NR4nRqQ7OeHKKaTX7RAGYZItEQ"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"owner@example.com"}
    [EVAL] Element: "owner@example.com"
    [EVAL] Set: {"owner@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_5, ownerEmail), OWNER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_5
    [EVAL] Found in sigma: {owner@example.com -> "restaurant_owner"}
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail5'
    [EVAL] Found in sigma: "owner@example.com"
    [EVAL] Map expr evaluated: {owner@example.com -> "restaurant_owner"}
    [EVAL] Key expr evaluated: "owner@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "restaurant_owner"
  [EVAL] Var lookup: OWNER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "restaurant_owner" OWNER)
    [EVAL] Arg[2]: in(restaurantId, dom(tmp_R_4))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId5'
    [EVAL] Found placeholder __NEEDS_RESTAURANT_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] tmp_R_0 is empty map
    [findKeyFromMapInSigma] Found tmp_R_1 with 1 entries, key: 696b451bac7475a04fb8330e
    [findKeyFromMapInSigma] Found tmp_R_2 with 1 entries, key: 696b451bac7475a04fb8330e
    [findKeyFromMapInSigma] Found tmp_R_3 with 1 entries, key: 696b451bac7475a04fb8330e
    [findKeyFromMapInSigma] Found tmp_R_4 with 1 entries, key: 696b451bac7475a04fb8330e
    [EVAL] Resolved to: 696b451bac7475a04fb8330e
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_R_4
    [EVAL] Found in sigma: {696b451bac7475a04fb8330e -> ""Test Restaurant""}
    [EVAL] Map expr evaluated: {696b451bac7475a04fb8330e -> ""Test Restaurant""}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696b451bac7475a04fb8330e"
    [EVAL] Set: {"696b451bac7475a04fb8330e"}
    [EVAL] Element: "696b451bac7475a04fb8330e"
    [EVAL] Set: {"696b451bac7475a04fb8330e"}
    [EVAL] Element found in set: true
    [EVAL] Arg[2] result: true
    [EVAL] FuncCall result: AND(true, (= "restaurant_owner" OWNER), true)
[ASSUME] Adding constraint: AND(true, (= "restaurant_owner" OWNER), true)
[SEE] API call 'addMenuItem' ready for actual execution

[ASSIGN] Evaluating: _result5 := addMenuItem(ownerEmail, restaurantId, itemName, itemPrice)
[SEE] Mapping base name '_result' -> '_result5'
  [EVAL] Var lookup: ownerEmail
    [EVAL] Resolved base name 'ownerEmail' -> 'ownerEmail5'
    [EVAL] Found in sigma: "owner@example.com"
  [EVAL] Var lookup: restaurantId
    [EVAL] Resolved base name 'restaurantId' -> 'restaurantId5'
    [EVAL] Found in sigma: "696b451bac7475a04fb8330e"
  [EVAL] Var lookup: itemName
    [EVAL] Resolved base name 'itemName' -> 'itemName5'
    [EVAL] Found in sigma: "Delicious Dish"
  [EVAL] Var lookup: itemPrice
    [EVAL] Resolved base name 'itemPrice' -> 'itemPrice5'
    [EVAL] Found in sigma: 150
[API_CALL] Executing API function: addMenuItem
  [API_ARG] "owner@example.com"
  [API_ARG] "696b451bac7475a04fb8330e"
  [API_ARG] "Delicious Dish"
  [API_ARG] 150
  [API_CALL] Getting function from factory...
[Factory] Creating function: addMenuItem
  [API_CALL] Executing function...
[AddMenuItemFunc] owner@example.com adding menu item: Delicious Dish to restaurant 696b451bac7475a04fb8330e
[HttpClient] POST /api/menu -> 201
[AddMenuItemFunc] Menu item created: 696b451bac7475a04fb8332e
  [API_CALL] Function returned: 201
  [API_CALL] Storing result in variable: _result5
[ASSIGN] Result: _result5 := 201
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_5 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_5'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
[GetMFunc] Menu item: 696b451bac7475a04fb8331a -> restaurant: 696b451bac7475a04fb8330e
[GetMFunc] Menu item: 696b451bac7475a04fb83324 -> restaurant: 696b451bac7475a04fb8330e
[GetMFunc] Menu item: 696b451bac7475a04fb8332e -> restaurant: 696b451bac7475a04fb8330e
  [API_CALL] Function returned: {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e", 696b451bac7475a04fb83324 -> "696b451bac7475a04fb8330e", 696b451bac7475a04fb8332e -> "696b451bac7475a04fb8330e"}
  [API_CALL] Storing result in variable: tmp_M_5
[ASSIGN] Result: tmp_M_5 := {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e", 696b451bac7475a04fb83324 -> "696b451bac7475a04fb8330e", 696b451bac7475a04fb8332e -> "696b451bac7475a04fb8330e"}

[ASSERT] Evaluating: in(_result5, dom(tmp_M_5))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result5
    [EVAL] Found in sigma: 201
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_M_5
    [EVAL] Found in sigma: {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e", 696b451bac7475a04fb83324 -> "696b451bac7475a04fb8330e", 696b451bac7475a04fb8332e -> "696b451bac7475a04fb8330e"}
    [EVAL] Map expr evaluated: {696b451bac7475a04fb8331a -> "696b451bac7475a04fb8330e", 696b451bac7475a04fb83324 -> "696b451bac7475a04fb8330e", 696b451bac7475a04fb8332e -> "696b451bac7475a04fb8330e"}
    [EVAL] Domain has 3 keys
    [EVAL] Element: "696b451bac7475a04fb8331a"
    [EVAL] Element: "696b451bac7475a04fb83324"
    [EVAL] Element: "696b451bac7475a04fb8332e"
    [EVAL] Set: {"696b451bac7475a04fb8331a", "696b451bac7475a04fb83324", "696b451bac7475a04fb8332e"}
    [EVAL] Element: 201
    [EVAL] Set: {"696b451bac7475a04fb8331a", "696b451bac7475a04fb83324", "696b451bac7475a04fb8332e"}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[SEE] Path Constraint: And(true, And(true, And(AND(true, (= "restaurant_owner" OWNER)), And(true, And(AND(true, (= "restaurant_owner" OWNER)), And(AND(true, (= "restaurant_owner" OWNER), true), And(AND(true, (= "restaurant_owner" OWNER), true), AND(true, (= "restaurant_owner" OWNER), true))))))))
>>> generateCTC: After symex - Is abstract: 0, Has placeholders: 1

>>> generateCTC: STEP 3a - Resolving placeholders in AST

>>> Resolving placeholders in program AST
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] Found tmp_R_4 with 1 entries, returning key: 696b451bac7475a04fb8330e
    [AST RESOLVED] restaurantId3 = "696b451bac7475a04fb8330e"
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] Found tmp_R_4 with 1 entries, returning key: 696b451bac7475a04fb8330e
    [AST RESOLVED] restaurantId4 = "696b451bac7475a04fb8330e"
    [findKeyFromMapInSigma] Searching for prefix: tmp_R_
    [findKeyFromMapInSigma] Found tmp_R_4 with 1 entries, returning key: 696b451bac7475a04fb8330e
    [AST RESOLVED] restaurantId5 = "696b451bac7475a04fb8330e"
>>> generateCTC: All placeholders resolved, program is fully concrete

[FINAL CTC]
=== Program ===
Statement 0: _ := reset()
Statement 1: ownerEmail0 := "owner@example.com"
Statement 2: ownerPassword0 := "OwnerPass1!"
Statement 3: ownerFullName0 := "Test Owner"
Statement 4: ownerMobile0 := "5550000001"
Statement 5: tmp_Roles_0 := get_Roles()
Statement 6: Roles_old := tmp_Roles_0
Statement 7: tmp_U_0 := get_U()
Statement 8: U_old := tmp_U_0
Statement 9: tmp_U_1 := get_U()
Statement 10: assume(not_in(ownerEmail, dom(tmp_U_1)))
Statement 11: _result0 := registerOwner(ownerEmail, ownerPassword, ownerFullName, ownerMobile)
Statement 12: tmp_U_2 := get_U()
Statement 13: tmp_Roles_1 := get_Roles()
Statement 14: assert(AND(=([](tmp_U_2, ownerEmail), ownerPassword), =([](tmp_Roles_1, ownerEmail), OWNER)))
Statement 15: ownerEmail1 := "owner@example.com"
Statement 16: ownerPassword1 := "OwnerPass1!"
Statement 17: tmp_T_0 := get_T()
Statement 18: T_old := tmp_T_0
Statement 19: tmp_U_3 := get_U()
Statement 20: tmp_U_4 := get_U()
Statement 21: assume(AND(in(ownerEmail, dom(tmp_U_3)), =([](tmp_U_4, ownerEmail), ownerPassword)))
Statement 22: _result1 := login(ownerEmail, ownerPassword)
Statement 23: tmp_T_1 := get_T()
Statement 24: assert(=([](tmp_T_1, ownerEmail), _result1))
Statement 25: ownerEmail2 := "owner@example.com"
Statement 26: restaurantName2 := "Test Restaurant"
Statement 27: restaurantAddress2 := "123 Restaurant Street"
Statement 28: restaurantContact2 := "restaurant@test.com"
Statement 29: tmp_Owners_0 := get_Owners()
Statement 30: Owners_old := tmp_Owners_0
Statement 31: tmp_R_0 := get_R()
Statement 32: R_old := tmp_R_0
Statement 33: tmp_T_2 := get_T()
Statement 34: tmp_Roles_2 := get_Roles()
Statement 35: assume(AND(in(ownerEmail, dom(tmp_T_2)), =([](tmp_Roles_2, ownerEmail), OWNER)))
Statement 36: _result2 := createRestaurant(ownerEmail, restaurantName, restaurantAddress, restaurantContact)
Statement 37: tmp_R_1 := get_R()
Statement 38: tmp_Owners_1 := get_Owners()
Statement 39: assert(AND(in(_result2, dom(tmp_R_1)), =([](tmp_Owners_1, _result2), ownerEmail)))
Statement 40: ownerEmail3 := "owner@example.com"
Statement 41: restaurantId3 := "696b451bac7475a04fb8330e"
Statement 42: itemName3 := "Delicious Dish"
Statement 43: itemPrice3 := 150
Statement 44: tmp_M_0 := get_M()
Statement 45: M_old := tmp_M_0
Statement 46: tmp_T_3 := get_T()
Statement 47: tmp_Roles_3 := get_Roles()
Statement 48: tmp_R_2 := get_R()
Statement 49: assume(AND(in(ownerEmail, dom(tmp_T_3)), =([](tmp_Roles_3, ownerEmail), OWNER), in(restaurantId, dom(tmp_R_2))))
Statement 50: _result3 := addMenuItem(ownerEmail, restaurantId, itemName, itemPrice)
Statement 51: tmp_M_1 := get_M()
Statement 52: assert(in(_result3, dom(tmp_M_1)))
Statement 53: ownerEmail4 := "owner@example.com"
Statement 54: restaurantId4 := "696b451bac7475a04fb8330e"
Statement 55: itemName4 := "Delicious Dish"
Statement 56: itemPrice4 := 150
Statement 57: tmp_M_2 := get_M()
Statement 58: M_old := tmp_M_2
Statement 59: tmp_T_4 := get_T()
Statement 60: tmp_Roles_4 := get_Roles()
Statement 61: tmp_R_3 := get_R()
Statement 62: assume(AND(in(ownerEmail, dom(tmp_T_4)), =([](tmp_Roles_4, ownerEmail), OWNER), in(restaurantId, dom(tmp_R_3))))
Statement 63: _result4 := addMenuItem(ownerEmail, restaurantId, itemName, itemPrice)
Statement 64: tmp_M_3 := get_M()
Statement 65: assert(in(_result4, dom(tmp_M_3)))
Statement 66: ownerEmail5 := "owner@example.com"
Statement 67: restaurantId5 := "696b451bac7475a04fb8330e"
Statement 68: itemName5 := "Delicious Dish"
Statement 69: itemPrice5 := 150
Statement 70: tmp_M_4 := get_M()
Statement 71: M_old := tmp_M_4
Statement 72: tmp_T_5 := get_T()
Statement 73: tmp_Roles_5 := get_Roles()
Statement 74: tmp_R_4 := get_R()
Statement 75: assume(AND(in(ownerEmail, dom(tmp_T_5)), =([](tmp_Roles_5, ownerEmail), OWNER), in(restaurantId, dom(tmp_R_4))))
Statement 76: _result5 := addMenuItem(ownerEmail, restaurantId, itemName, itemPrice)
Statement 77: tmp_M_5 := get_M()
Statement 78: assert(in(_result5, dom(tmp_M_5)))
=== End Program ===

✓ Test 12: Register Owner → Login → Create Restaurant → Add Menu (Depth=4) COMPLETE!

