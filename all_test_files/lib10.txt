
╔════════════════════════════════════════╗
║  TESTGEN - LIBRARY TEST SUITE          ║
║  Total Tests: 25                       ║
╚════════════════════════════════════════╝


========================================
TEST: Test 10: Student CRUD - Save → Update → Delete (Depth=3)
MODE: Full Pipeline (With Backend)
DEPTH: 3 API calls
========================================

[LibraryFunctionFactory] Initialized with baseUrl: http://localhost:8080
[RewriteGlobalsVisitor] Detected 4 globals: B Loans Req S 
[RewriteGlobalsVisitor] Generated 0 statements in rewritten program

=== TEST-API ATC (After Rewrite) ===
=== Program ===
Statement 0: _ := reset()
Statement 1: studentName0 := input()
Statement 2: studentEmail0 := input()
Statement 3: studentPhone0 := input()
Statement 4: tmp_S_0 := get_S()
Statement 5: S_old := tmp_S_0
Statement 6: assume(1)
Statement 7: _result0 := saveStudent(studentName, studentEmail, studentPhone)
Statement 8: tmp_S_1 := get_S()
Statement 9: assert(in(_result0, dom(tmp_S_1)))
Statement 10: studentId1 := input()
Statement 11: studentName1 := input()
Statement 12: studentEmail1 := input()
Statement 13: studentPhone1 := input()
Statement 14: tmp_S_2 := get_S()
Statement 15: S_old := tmp_S_2
Statement 16: tmp_S_3 := get_S()
Statement 17: assume(in(studentId, dom(tmp_S_3)))
Statement 18: _result1 := updateStudent(studentId, studentName, studentEmail, studentPhone)
Statement 19: tmp_S_4 := get_S()
Statement 20: assert(in(studentId, dom(tmp_S_4)))
Statement 21: studentId2 := input()
Statement 22: tmp_S_5 := get_S()
Statement 23: S_old := tmp_S_5
Statement 24: tmp_S_6 := get_S()
Statement 25: assume(in(studentId, dom(tmp_S_6)))
Statement 26: _result2 := deleteStudent(studentId)
Statement 27: tmp_S_7 := get_S()
Statement 28: assert(not_in(studentId, dom(tmp_S_7)))
=== End Program ===

========================================
>>> generateCTC: Starting iteration
========================================
>>> generateCTC: Program needs processing
>>> generateCTC: Concrete values provided: 0
>>> generateCTC: Is abstract: 1
>>> generateCTC: Has placeholders: 0

>>> generateCTC: STEP 1 - Rewriting ATC with concrete values

>>> generateCTC: STEP 2 - Running symbolic execution
[SEE] API call 'reset' ready for actual execution

[ASSIGN] Evaluating: _ := reset()
[API_CALL] Executing API function: reset
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: reset
  [API_CALL] Executing function...
[ResetFunc] Clearing all collections...
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _
[ASSIGN] Result: _ := 200

[ASSIGN] Evaluating: studentName0 := input()
[SEE] Mapping base name 'studentName' -> 'studentName0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X0
[ASSIGN] Result: studentName0 := X0

[ASSIGN] Evaluating: studentEmail0 := input()
[SEE] Mapping base name 'studentEmail' -> 'studentEmail0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X1
[ASSIGN] Result: studentEmail0 := X1

[ASSIGN] Evaluating: studentPhone0 := input()
[SEE] Mapping base name 'studentPhone' -> 'studentPhone0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X2
[ASSIGN] Result: studentPhone0 := X2
[SEE] API call 'get_S' ready for actual execution

[ASSIGN] Evaluating: tmp_S_0 := get_S()
[SEE] Mapping base name 'tmp_S_' -> 'tmp_S_0'
[API_CALL] Executing API function: get_S
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: get_S
  [API_CALL] Executing function...
[GetSFunc] Fetching S (Students)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_S_0
[ASSIGN] Result: tmp_S_0 := {}

[ASSIGN] Evaluating: S_old := tmp_S_0
  [EVAL] Var lookup: tmp_S_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: S_old := {}

[ASSUME] Evaluating: 1
  [EVAL] Num: 1
[ASSUME] Adding constraint: 1
[SEE] API call 'saveStudent' with symbolic arguments - interruption point
[SEE] Interruption at statement 7

[ASSIGN] Evaluating: _result0 := saveStudent(studentName, studentEmail, studentPhone)
[SEE] Mapping base name '_result' -> '_result0'
  [EVAL] Var lookup: studentName
    [EVAL] Resolved base name 'studentName' -> 'studentName0'
    [EVAL] Found in sigma: X0
  [EVAL] Var lookup: studentEmail
    [EVAL] Resolved base name 'studentEmail' -> 'studentEmail0'
    [EVAL] Found in sigma: X1
  [EVAL] Var lookup: studentPhone
    [EVAL] Resolved base name 'studentPhone' -> 'studentPhone0'
    [EVAL] Found in sigma: X2
[API_CALL] saveStudent has symbolic arguments - skipping actual execution
  [API_ARG 0] X0 (symbolic: 1)
  [API_ARG 1] X1 (symbolic: 1)
  [API_ARG 2] X2 (symbolic: 1)
[ASSIGN] Result: _result0 := -1 (symbolic placeholder)
[SEE] API call 'get_S' ready for actual execution

[ASSIGN] Evaluating: tmp_S_1 := get_S()
[SEE] Mapping base name 'tmp_S_' -> 'tmp_S_1'
[API_CALL] Executing API function: get_S
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: get_S
  [API_CALL] Executing function...
[GetSFunc] Fetching S (Students)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_S_1
[ASSIGN] Result: tmp_S_1 := {}

[ASSERT] Evaluating: in(_result0, dom(tmp_S_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result0
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_S_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: studentId1 := input()
[SEE] Mapping base name 'studentId' -> 'studentId1'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X3
[ASSIGN] Result: studentId1 := X3

[ASSIGN] Evaluating: studentName1 := input()
[SEE] Mapping base name 'studentName' -> 'studentName1'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X4
[ASSIGN] Result: studentName1 := X4

[ASSIGN] Evaluating: studentEmail1 := input()
[SEE] Mapping base name 'studentEmail' -> 'studentEmail1'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X5
[ASSIGN] Result: studentEmail1 := X5

[ASSIGN] Evaluating: studentPhone1 := input()
[SEE] Mapping base name 'studentPhone' -> 'studentPhone1'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X6
[ASSIGN] Result: studentPhone1 := X6
[SEE] API call 'get_S' ready for actual execution

[ASSIGN] Evaluating: tmp_S_2 := get_S()
[SEE] Mapping base name 'tmp_S_' -> 'tmp_S_2'
[API_CALL] Executing API function: get_S
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: get_S
  [API_CALL] Executing function...
[GetSFunc] Fetching S (Students)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_S_2
[ASSIGN] Result: tmp_S_2 := {}

[ASSIGN] Evaluating: S_old := tmp_S_2
  [EVAL] Var lookup: tmp_S_2
    [EVAL] Found in sigma: {}
[ASSIGN] Result: S_old := {}
[SEE] API call 'get_S' ready for actual execution

[ASSIGN] Evaluating: tmp_S_3 := get_S()
[SEE] Mapping base name 'tmp_S_' -> 'tmp_S_3'
[API_CALL] Executing API function: get_S
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: get_S
  [API_CALL] Executing function...
[GetSFunc] Fetching S (Students)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_S_3
[ASSIGN] Result: tmp_S_3 := {}

[ASSUME] Evaluating: in(studentId, dom(tmp_S_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: studentId
    [EVAL] Resolved base name 'studentId' -> 'studentId1'
    [EVAL] Found in sigma: X3
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_S_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X3
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSUME] Adding constraint: false
[SEE] API call 'updateStudent' with symbolic arguments - interruption point
[SEE] Interruption at statement 18

[ASSIGN] Evaluating: _result1 := updateStudent(studentId, studentName, studentEmail, studentPhone)
[SEE] Mapping base name '_result' -> '_result1'
  [EVAL] Var lookup: studentId
    [EVAL] Resolved base name 'studentId' -> 'studentId1'
    [EVAL] Found in sigma: X3
  [EVAL] Var lookup: studentName
    [EVAL] Resolved base name 'studentName' -> 'studentName1'
    [EVAL] Found in sigma: X4
  [EVAL] Var lookup: studentEmail
    [EVAL] Resolved base name 'studentEmail' -> 'studentEmail1'
    [EVAL] Found in sigma: X5
  [EVAL] Var lookup: studentPhone
    [EVAL] Resolved base name 'studentPhone' -> 'studentPhone1'
    [EVAL] Found in sigma: X6
[API_CALL] updateStudent has symbolic arguments - skipping actual execution
  [API_ARG 0] X3 (symbolic: 1)
  [API_ARG 1] X4 (symbolic: 1)
  [API_ARG 2] X5 (symbolic: 1)
  [API_ARG 3] X6 (symbolic: 1)
[ASSIGN] Result: _result1 := -1 (symbolic placeholder)
[SEE] API call 'get_S' ready for actual execution

[ASSIGN] Evaluating: tmp_S_4 := get_S()
[SEE] Mapping base name 'tmp_S_' -> 'tmp_S_4'
[API_CALL] Executing API function: get_S
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: get_S
  [API_CALL] Executing function...
[GetSFunc] Fetching S (Students)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_S_4
[ASSIGN] Result: tmp_S_4 := {}

[ASSERT] Evaluating: in(studentId, dom(tmp_S_4))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: studentId
    [EVAL] Resolved base name 'studentId' -> 'studentId1'
    [EVAL] Found in sigma: X3
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_S_4
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X3
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: studentId2 := input()
[SEE] Mapping base name 'studentId' -> 'studentId2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X7
[ASSIGN] Result: studentId2 := X7
[SEE] API call 'get_S' ready for actual execution

[ASSIGN] Evaluating: tmp_S_5 := get_S()
[SEE] Mapping base name 'tmp_S_' -> 'tmp_S_5'
[API_CALL] Executing API function: get_S
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: get_S
  [API_CALL] Executing function...
[GetSFunc] Fetching S (Students)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_S_5
[ASSIGN] Result: tmp_S_5 := {}

[ASSIGN] Evaluating: S_old := tmp_S_5
  [EVAL] Var lookup: tmp_S_5
    [EVAL] Found in sigma: {}
[ASSIGN] Result: S_old := {}
[SEE] API call 'get_S' ready for actual execution

[ASSIGN] Evaluating: tmp_S_6 := get_S()
[SEE] Mapping base name 'tmp_S_' -> 'tmp_S_6'
[API_CALL] Executing API function: get_S
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: get_S
  [API_CALL] Executing function...
[GetSFunc] Fetching S (Students)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_S_6
[ASSIGN] Result: tmp_S_6 := {}

[ASSUME] Evaluating: in(studentId, dom(tmp_S_6))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: studentId
    [EVAL] Resolved base name 'studentId' -> 'studentId2'
    [EVAL] Found in sigma: X7
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_S_6
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X7
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSUME] Adding constraint: false
[SEE] API call 'deleteStudent' with symbolic arguments - interruption point
[SEE] Interruption at statement 26

[ASSIGN] Evaluating: _result2 := deleteStudent(studentId)
[SEE] Mapping base name '_result' -> '_result2'
  [EVAL] Var lookup: studentId
    [EVAL] Resolved base name 'studentId' -> 'studentId2'
    [EVAL] Found in sigma: X7
[API_CALL] deleteStudent has symbolic arguments - skipping actual execution
  [API_ARG 0] X7 (symbolic: 1)
[ASSIGN] Result: _result2 := -1 (symbolic placeholder)
[SEE] API call 'get_S' ready for actual execution

[ASSIGN] Evaluating: tmp_S_7 := get_S()
[SEE] Mapping base name 'tmp_S_' -> 'tmp_S_7'
[API_CALL] Executing API function: get_S
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: get_S
  [API_CALL] Executing function...
[GetSFunc] Fetching S (Students)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_S_7
[ASSIGN] Result: tmp_S_7 := {}

[ASSERT] Evaluating: not_in(studentId, dom(tmp_S_7))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: studentId
    [EVAL] Resolved base name 'studentId' -> 'studentId2'
    [EVAL] Found in sigma: X7
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_S_7
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[SEE] Path Constraint: And(true, And(1, And(false, false)))

[UNSAT-CHECK] Path constraint contains FALSE - checking dependencies...

[DEPENDENCY-CHECK] Analyzing sequence for true UNSAT...
[DEPENDENCY-CHECK] ✓ All dependencies satisfied - sequence is potentially satisfiable.
>>> generateCTC: After symex - Is abstract: 1, Has placeholders: 0

>>> generateCTC: STEP 3 - Generating values with sigma lookup
    [Found existing] _ -> _
    [Found existing] tmp_S_ -> tmp_S_0
    [Found existing] S_old -> S_old
    [Found existing] _result -> _result0
    studentName0 = "Test Student 1"
    studentEmail0 = "student1@library.edu"
    studentPhone0 = "555-000-1000"
    [findKeyFromMapInSigma] Searching for prefix: tmp_S_
    [findKeyFromMapInSigma] tmp_S_7 is empty map
    [findKeyFromMapInSigma] tmp_S_6 is empty map
    [findKeyFromMapInSigma] tmp_S_5 is empty map
    [findKeyFromMapInSigma] tmp_S_4 is empty map
    [findKeyFromMapInSigma] tmp_S_3 is empty map
    [findKeyFromMapInSigma] tmp_S_2 is empty map
    [findKeyFromMapInSigma] tmp_S_1 is empty map
    [findKeyFromMapInSigma] tmp_S_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_S_
    [DEFERRED] studentId - no student in sigma yet
    studentId1 = "__NEEDS_STUDENT_ID__"
    studentName1 = (reusing studentName) "Test Student 1"
    studentEmail1 = (reusing studentEmail) "student1@library.edu"
    studentPhone1 = (reusing studentPhone) "555-000-1000"
    [findKeyFromMapInSigma] Searching for prefix: tmp_S_
    [findKeyFromMapInSigma] tmp_S_7 is empty map
    [findKeyFromMapInSigma] tmp_S_6 is empty map
    [findKeyFromMapInSigma] tmp_S_5 is empty map
    [findKeyFromMapInSigma] tmp_S_4 is empty map
    [findKeyFromMapInSigma] tmp_S_3 is empty map
    [findKeyFromMapInSigma] tmp_S_2 is empty map
    [findKeyFromMapInSigma] tmp_S_1 is empty map
    [findKeyFromMapInSigma] tmp_S_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_S_
    [DEFERRED] studentId - no student in sigma yet
    studentId2 = "__NEEDS_STUDENT_ID__"

>>> generateCTC: STEP 4 - Resolving placeholders from sigma
    [findKeyFromMapInSigma] Searching for prefix: tmp_S_
    [findKeyFromMapInSigma] tmp_S_7 is empty map
    [findKeyFromMapInSigma] tmp_S_6 is empty map
    [findKeyFromMapInSigma] tmp_S_5 is empty map
    [findKeyFromMapInSigma] tmp_S_4 is empty map
    [findKeyFromMapInSigma] tmp_S_3 is empty map
    [findKeyFromMapInSigma] tmp_S_2 is empty map
    [findKeyFromMapInSigma] tmp_S_1 is empty map
    [findKeyFromMapInSigma] tmp_S_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_S_
    [STILL PENDING] studentId1 - keeping placeholder for next iteration
    [findKeyFromMapInSigma] Searching for prefix: tmp_S_
    [findKeyFromMapInSigma] tmp_S_7 is empty map
    [findKeyFromMapInSigma] tmp_S_6 is empty map
    [findKeyFromMapInSigma] tmp_S_5 is empty map
    [findKeyFromMapInSigma] tmp_S_4 is empty map
    [findKeyFromMapInSigma] tmp_S_3 is empty map
    [findKeyFromMapInSigma] tmp_S_2 is empty map
    [findKeyFromMapInSigma] tmp_S_1 is empty map
    [findKeyFromMapInSigma] tmp_S_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_S_
    [STILL PENDING] studentId2 - keeping placeholder for next iteration

>>> generateCTC: STEP 5 - Recursing with 8 concrete values

========================================
>>> generateCTC: Starting iteration
========================================
>>> generateCTC: Program needs processing
>>> generateCTC: Concrete values provided: 8
>>> generateCTC: Is abstract: 1
>>> generateCTC: Has placeholders: 0

>>> generateCTC: STEP 1 - Rewriting ATC with concrete values

>>> generateCTC: STEP 2 - Running symbolic execution
[SEE] API call 'reset' ready for actual execution

[ASSIGN] Evaluating: _ := reset()
[API_CALL] Executing API function: reset
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: reset
  [API_CALL] Executing function...
[ResetFunc] Clearing all collections...
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _
[ASSIGN] Result: _ := 200

[ASSIGN] Evaluating: studentName0 := "Test Student 1"
[SEE] Mapping base name 'studentName' -> 'studentName0'
  [EVAL] String: "Test Student 1"
[ASSIGN] Result: studentName0 := "Test Student 1"

[ASSIGN] Evaluating: studentEmail0 := "student1@library.edu"
[SEE] Mapping base name 'studentEmail' -> 'studentEmail0'
  [EVAL] String: "student1@library.edu"
[ASSIGN] Result: studentEmail0 := "student1@library.edu"

[ASSIGN] Evaluating: studentPhone0 := "555-000-1000"
[SEE] Mapping base name 'studentPhone' -> 'studentPhone0'
  [EVAL] String: "555-000-1000"
[ASSIGN] Result: studentPhone0 := "555-000-1000"
[SEE] API call 'get_S' ready for actual execution

[ASSIGN] Evaluating: tmp_S_0 := get_S()
[SEE] Mapping base name 'tmp_S_' -> 'tmp_S_0'
[API_CALL] Executing API function: get_S
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: get_S
  [API_CALL] Executing function...
[GetSFunc] Fetching S (Students)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_S_0
[ASSIGN] Result: tmp_S_0 := {}

[ASSIGN] Evaluating: S_old := tmp_S_0
  [EVAL] Var lookup: tmp_S_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: S_old := {}

[ASSUME] Evaluating: 1
  [EVAL] Num: 1
[ASSUME] Adding constraint: 1
[SEE] API call 'saveStudent' ready for actual execution

[ASSIGN] Evaluating: _result0 := saveStudent(studentName, studentEmail, studentPhone)
[SEE] Mapping base name '_result' -> '_result0'
  [EVAL] Var lookup: studentName
    [EVAL] Resolved base name 'studentName' -> 'studentName0'
    [EVAL] Found in sigma: "Test Student 1"
  [EVAL] Var lookup: studentEmail
    [EVAL] Resolved base name 'studentEmail' -> 'studentEmail0'
    [EVAL] Found in sigma: "student1@library.edu"
  [EVAL] Var lookup: studentPhone
    [EVAL] Resolved base name 'studentPhone' -> 'studentPhone0'
    [EVAL] Found in sigma: "555-000-1000"
[API_CALL] Executing API function: saveStudent
  [API_ARG] "Test Student 1"
  [API_ARG] "student1@library.edu"
  [API_ARG] "555-000-1000"
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: saveStudent
  [API_CALL] Executing function...
[SaveStudentFunc] Creating student: Test Student 1
[HttpClient] POST /student/save?userId=1 -> 200
[SaveStudentFunc] Created student with id: 41
  [API_CALL] Function returned: "41"
  [API_CALL] Storing result in variable: _result0
[ASSIGN] Result: _result0 := "41"
[SEE] API call 'get_S' ready for actual execution

[ASSIGN] Evaluating: tmp_S_1 := get_S()
[SEE] Mapping base name 'tmp_S_' -> 'tmp_S_1'
[API_CALL] Executing API function: get_S
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: get_S
  [API_CALL] Executing function...
[GetSFunc] Fetching S (Students)...
  [API_CALL] Function returned: {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}
  [API_CALL] Storing result in variable: tmp_S_1
[ASSIGN] Result: tmp_S_1 := {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}

[ASSERT] Evaluating: in(_result0, dom(tmp_S_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result0
    [EVAL] Found in sigma: "41"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_S_1
    [EVAL] Found in sigma: {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}
    [EVAL] Map expr evaluated: {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "41"
    [EVAL] Set: {"41"}
    [EVAL] Element: "41"
    [EVAL] Set: {"41"}
    [EVAL] Element found in set: true
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[ASSIGN] Evaluating: studentId1 := "__NEEDS_STUDENT_ID__"
[SEE] Mapping base name 'studentId' -> 'studentId1'
  [EVAL] String: "__NEEDS_STUDENT_ID__"
[ASSIGN] Result: studentId1 := "__NEEDS_STUDENT_ID__"

[ASSIGN] Evaluating: studentName1 := "Test Student 1"
[SEE] Mapping base name 'studentName' -> 'studentName1'
  [EVAL] String: "Test Student 1"
[ASSIGN] Result: studentName1 := "Test Student 1"

[ASSIGN] Evaluating: studentEmail1 := "student1@library.edu"
[SEE] Mapping base name 'studentEmail' -> 'studentEmail1'
  [EVAL] String: "student1@library.edu"
[ASSIGN] Result: studentEmail1 := "student1@library.edu"

[ASSIGN] Evaluating: studentPhone1 := "555-000-1000"
[SEE] Mapping base name 'studentPhone' -> 'studentPhone1'
  [EVAL] String: "555-000-1000"
[ASSIGN] Result: studentPhone1 := "555-000-1000"
[SEE] API call 'get_S' ready for actual execution

[ASSIGN] Evaluating: tmp_S_2 := get_S()
[SEE] Mapping base name 'tmp_S_' -> 'tmp_S_2'
[API_CALL] Executing API function: get_S
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: get_S
  [API_CALL] Executing function...
[GetSFunc] Fetching S (Students)...
  [API_CALL] Function returned: {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}
  [API_CALL] Storing result in variable: tmp_S_2
[ASSIGN] Result: tmp_S_2 := {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}

[ASSIGN] Evaluating: S_old := tmp_S_2
  [EVAL] Var lookup: tmp_S_2
    [EVAL] Found in sigma: {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}
[ASSIGN] Result: S_old := {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}
[SEE] API call 'get_S' ready for actual execution

[ASSIGN] Evaluating: tmp_S_3 := get_S()
[SEE] Mapping base name 'tmp_S_' -> 'tmp_S_3'
[API_CALL] Executing API function: get_S
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: get_S
  [API_CALL] Executing function...
[GetSFunc] Fetching S (Students)...
  [API_CALL] Function returned: {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}
  [API_CALL] Storing result in variable: tmp_S_3
[ASSIGN] Result: tmp_S_3 := {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}

[ASSUME] Evaluating: in(studentId, dom(tmp_S_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: studentId
    [EVAL] Resolved base name 'studentId' -> 'studentId1'
    [EVAL] Found placeholder __NEEDS_STUDENT_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_S_
    [findKeyFromMapInSigma] tmp_S_0 is empty map
    [findKeyFromMapInSigma] Found tmp_S_1 with 1 entries, key: 41
    [findKeyFromMapInSigma] Found tmp_S_2 with 1 entries, key: 41
    [findKeyFromMapInSigma] Found tmp_S_3 with 1 entries, key: 41
    [findKeyFromMapInSigma] tmp_S_4 is empty map
    [findKeyFromMapInSigma] tmp_S_5 is empty map
    [findKeyFromMapInSigma] tmp_S_6 is empty map
    [findKeyFromMapInSigma] tmp_S_7 is empty map
    [EVAL] Resolved to: 41
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_S_3
    [EVAL] Found in sigma: {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}
    [EVAL] Map expr evaluated: {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "41"
    [EVAL] Set: {"41"}
    [EVAL] Element: "41"
    [EVAL] Set: {"41"}
    [EVAL] Element found in set: true
[ASSUME] Adding constraint: true
[SEE] API call 'updateStudent' ready for actual execution

[ASSIGN] Evaluating: _result1 := updateStudent(studentId, studentName, studentEmail, studentPhone)
[SEE] Mapping base name '_result' -> '_result1'
  [EVAL] Var lookup: studentId
    [EVAL] Resolved base name 'studentId' -> 'studentId1'
    [EVAL] Found in sigma: "41"
  [EVAL] Var lookup: studentName
    [EVAL] Resolved base name 'studentName' -> 'studentName1'
    [EVAL] Found in sigma: "Test Student 1"
  [EVAL] Var lookup: studentEmail
    [EVAL] Resolved base name 'studentEmail' -> 'studentEmail1'
    [EVAL] Found in sigma: "student1@library.edu"
  [EVAL] Var lookup: studentPhone
    [EVAL] Resolved base name 'studentPhone' -> 'studentPhone1'
    [EVAL] Found in sigma: "555-000-1000"
[API_CALL] Executing API function: updateStudent
  [API_ARG] "41"
  [API_ARG] "Test Student 1"
  [API_ARG] "student1@library.edu"
  [API_ARG] "555-000-1000"
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: updateStudent
  [API_CALL] Executing function...
[UpdateStudentFunc] Updating student: 41
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _result1
[ASSIGN] Result: _result1 := 200
[SEE] API call 'get_S' ready for actual execution

[ASSIGN] Evaluating: tmp_S_4 := get_S()
[SEE] Mapping base name 'tmp_S_' -> 'tmp_S_4'
[API_CALL] Executing API function: get_S
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: get_S
  [API_CALL] Executing function...
[GetSFunc] Fetching S (Students)...
  [API_CALL] Function returned: {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}
  [API_CALL] Storing result in variable: tmp_S_4
[ASSIGN] Result: tmp_S_4 := {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}

[ASSERT] Evaluating: in(studentId, dom(tmp_S_4))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: studentId
    [EVAL] Resolved base name 'studentId' -> 'studentId1'
    [EVAL] Found in sigma: "41"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_S_4
    [EVAL] Found in sigma: {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}
    [EVAL] Map expr evaluated: {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "41"
    [EVAL] Set: {"41"}
    [EVAL] Element: "41"
    [EVAL] Set: {"41"}
    [EVAL] Element found in set: true
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[ASSIGN] Evaluating: studentId2 := "__NEEDS_STUDENT_ID__"
[SEE] Mapping base name 'studentId' -> 'studentId2'
  [EVAL] String: "__NEEDS_STUDENT_ID__"
[ASSIGN] Result: studentId2 := "__NEEDS_STUDENT_ID__"
[SEE] API call 'get_S' ready for actual execution

[ASSIGN] Evaluating: tmp_S_5 := get_S()
[SEE] Mapping base name 'tmp_S_' -> 'tmp_S_5'
[API_CALL] Executing API function: get_S
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: get_S
  [API_CALL] Executing function...
[GetSFunc] Fetching S (Students)...
  [API_CALL] Function returned: {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}
  [API_CALL] Storing result in variable: tmp_S_5
[ASSIGN] Result: tmp_S_5 := {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}

[ASSIGN] Evaluating: S_old := tmp_S_5
  [EVAL] Var lookup: tmp_S_5
    [EVAL] Found in sigma: {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}
[ASSIGN] Result: S_old := {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}
[SEE] API call 'get_S' ready for actual execution

[ASSIGN] Evaluating: tmp_S_6 := get_S()
[SEE] Mapping base name 'tmp_S_' -> 'tmp_S_6'
[API_CALL] Executing API function: get_S
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: get_S
  [API_CALL] Executing function...
[GetSFunc] Fetching S (Students)...
  [API_CALL] Function returned: {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}
  [API_CALL] Storing result in variable: tmp_S_6
[ASSIGN] Result: tmp_S_6 := {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}

[ASSUME] Evaluating: in(studentId, dom(tmp_S_6))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: studentId
    [EVAL] Resolved base name 'studentId' -> 'studentId2'
    [EVAL] Found placeholder __NEEDS_STUDENT_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_S_
    [findKeyFromMapInSigma] tmp_S_0 is empty map
    [findKeyFromMapInSigma] Found tmp_S_1 with 1 entries, key: 41
    [findKeyFromMapInSigma] Found tmp_S_2 with 1 entries, key: 41
    [findKeyFromMapInSigma] Found tmp_S_3 with 1 entries, key: 41
    [findKeyFromMapInSigma] Found tmp_S_4 with 1 entries, key: 41
    [findKeyFromMapInSigma] Found tmp_S_5 with 1 entries, key: 41
    [findKeyFromMapInSigma] Found tmp_S_6 with 1 entries, key: 41
    [findKeyFromMapInSigma] tmp_S_7 is empty map
    [EVAL] Resolved to: 41
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_S_6
    [EVAL] Found in sigma: {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}
    [EVAL] Map expr evaluated: {41 -> "{"email":"student1@library.edu","phone":"555-000-1000","studentName":"Test Student 1","userId":1}"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "41"
    [EVAL] Set: {"41"}
    [EVAL] Element: "41"
    [EVAL] Set: {"41"}
    [EVAL] Element found in set: true
[ASSUME] Adding constraint: true
[SEE] API call 'deleteStudent' ready for actual execution

[ASSIGN] Evaluating: _result2 := deleteStudent(studentId)
[SEE] Mapping base name '_result' -> '_result2'
  [EVAL] Var lookup: studentId
    [EVAL] Resolved base name 'studentId' -> 'studentId2'
    [EVAL] Found in sigma: "41"
[API_CALL] Executing API function: deleteStudent
  [API_ARG] "41"
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: deleteStudent
  [API_CALL] Executing function...
[DeleteStudentFunc] Deleting student: 41
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _result2
[ASSIGN] Result: _result2 := 200
[SEE] API call 'get_S' ready for actual execution

[ASSIGN] Evaluating: tmp_S_7 := get_S()
[SEE] Mapping base name 'tmp_S_' -> 'tmp_S_7'
[API_CALL] Executing API function: get_S
  [API_CALL] Getting function from factory...
[LibraryFactory] Creating function: get_S
  [API_CALL] Executing function...
[GetSFunc] Fetching S (Students)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_S_7
[ASSIGN] Result: tmp_S_7 := {}

[ASSERT] Evaluating: not_in(studentId, dom(tmp_S_7))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: studentId
    [EVAL] Resolved base name 'studentId' -> 'studentId2'
    [EVAL] Found in sigma: "41"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_S_7
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[SEE] Path Constraint: And(true, And(1, And(true, true)))
>>> generateCTC: After symex - Is abstract: 0, Has placeholders: 1

>>> generateCTC: STEP 3a - Resolving placeholders in AST

>>> Resolving placeholders in program AST
    [findKeyFromMapInSigma] Searching for prefix: tmp_S_
    [findKeyFromMapInSigma] tmp_S_7 is empty map
    [findKeyFromMapInSigma] Found tmp_S_6 with 1 entries, returning key: 41
    [AST RESOLVED] studentId1 = "41"
    [findKeyFromMapInSigma] Searching for prefix: tmp_S_
    [findKeyFromMapInSigma] tmp_S_7 is empty map
    [findKeyFromMapInSigma] Found tmp_S_6 with 1 entries, returning key: 41
    [AST RESOLVED] studentId2 = "41"
>>> generateCTC: All placeholders resolved, program is fully concrete

[FINAL CTC]
=== Program ===
Statement 0: _ := reset()
Statement 1: studentName0 := "Test Student 1"
Statement 2: studentEmail0 := "student1@library.edu"
Statement 3: studentPhone0 := "555-000-1000"
Statement 4: tmp_S_0 := get_S()
Statement 5: S_old := tmp_S_0
Statement 6: assume(1)
Statement 7: _result0 := saveStudent(studentName, studentEmail, studentPhone)
Statement 8: tmp_S_1 := get_S()
Statement 9: assert(in(_result0, dom(tmp_S_1)))
Statement 10: studentId1 := "41"
Statement 11: studentName1 := "Test Student 1"
Statement 12: studentEmail1 := "student1@library.edu"
Statement 13: studentPhone1 := "555-000-1000"
Statement 14: tmp_S_2 := get_S()
Statement 15: S_old := tmp_S_2
Statement 16: tmp_S_3 := get_S()
Statement 17: assume(in(studentId, dom(tmp_S_3)))
Statement 18: _result1 := updateStudent(studentId, studentName, studentEmail, studentPhone)
Statement 19: tmp_S_4 := get_S()
Statement 20: assert(in(studentId, dom(tmp_S_4)))
Statement 21: studentId2 := "41"
Statement 22: tmp_S_5 := get_S()
Statement 23: S_old := tmp_S_5
Statement 24: tmp_S_6 := get_S()
Statement 25: assume(in(studentId, dom(tmp_S_6)))
Statement 26: _result2 := deleteStudent(studentId)
Statement 27: tmp_S_7 := get_S()
Statement 28: assert(not_in(studentId, dom(tmp_S_7)))
=== End Program ===

✓ Test 10: Student CRUD - Save → Update → Delete (Depth=3) COMPLETE!


╔════════════════════════════════════════╗
║  ALL TESTS COMPLETED                   ║
╚════════════════════════════════════════╝

