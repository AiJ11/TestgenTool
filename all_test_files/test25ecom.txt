
╔════════════════════════════════════════╗
║  TESTGEN - E-COMMERCE TEST SUITE       ║
║  Total Tests: 30 (21 SAT, 9 UNSAT)     ║
╚════════════════════════════════════════╝


========================================
TEST: [UNSAT] Test 25: Buyer Cannot Create Product (Depth=3)
MODE: Full Pipeline (With Backend)
DEPTH: 3 API calls
========================================

[EcommerceFunctionFactory] Initialized with baseUrl: http://localhost:3000
[RewriteGlobalsVisitor] Detected 10 globals: C O OrderStatus P Rev Roles Sellers Stock T U 
[RewriteGlobalsVisitor] Generated 0 statements in rewritten program

=== TEST-API ATC (After Rewrite) ===
=== Program ===
Statement 0: _ := reset()
Statement 1: buyerEmail0 := input()
Statement 2: buyerPassword0 := input()
Statement 3: buyerFullName0 := input()
Statement 4: tmp_Roles_0 := get_Roles()
Statement 5: Roles_old := tmp_Roles_0
Statement 6: tmp_U_0 := get_U()
Statement 7: U_old := tmp_U_0
Statement 8: tmp_U_1 := get_U()
Statement 9: assume(not_in(buyerEmail, dom(tmp_U_1)))
Statement 10: _result0 := registerBuyer(buyerEmail, buyerPassword, buyerFullName)
Statement 11: tmp_U_2 := get_U()
Statement 12: tmp_Roles_1 := get_Roles()
Statement 13: assert(AND(=([](tmp_U_2, buyerEmail), buyerPassword), =([](tmp_Roles_1, buyerEmail), BUYER)))
Statement 14: buyerEmail1 := input()
Statement 15: buyerPassword1 := input()
Statement 16: tmp_T_0 := get_T()
Statement 17: T_old := tmp_T_0
Statement 18: tmp_U_3 := get_U()
Statement 19: tmp_U_4 := get_U()
Statement 20: tmp_Roles_2 := get_Roles()
Statement 21: assume(AND(in(buyerEmail, dom(tmp_U_3)), =([](tmp_U_4, buyerEmail), buyerPassword), =([](tmp_Roles_2, buyerEmail), BUYER)))
Statement 22: _result1 := login(buyerEmail, buyerPassword)
Statement 23: tmp_T_1 := get_T()
Statement 24: assert(=([](tmp_T_1, buyerEmail), _result1))
Statement 25: sellerEmail2 := input()
Statement 26: title2 := input()
Statement 27: description2 := input()
Statement 28: category2 := input()
Statement 29: price2 := input()
Statement 30: quantity2 := input()
Statement 31: tmp_P_0 := get_P()
Statement 32: P_old := tmp_P_0
Statement 33: tmp_Sellers_0 := get_Sellers()
Statement 34: Sellers_old := tmp_Sellers_0
Statement 35: tmp_T_2 := get_T()
Statement 36: tmp_Roles_3 := get_Roles()
Statement 37: assume(AND(in(sellerEmail, dom(tmp_T_2)), =([](tmp_Roles_3, sellerEmail), SELLER)))
Statement 38: _result2 := createProduct(sellerEmail, title, description, category, price, quantity)
Statement 39: tmp_P_1 := get_P()
Statement 40: tmp_Sellers_1 := get_Sellers()
Statement 41: assert(AND(in(_result2, dom(tmp_P_1)), =([](tmp_Sellers_1, _result2), sellerEmail)))
=== End Program ===

========================================
>>> generateCTC: Starting iteration
========================================
>>> generateCTC: Program needs processing
>>> generateCTC: Concrete values provided: 0
>>> generateCTC: Is abstract: 1
>>> generateCTC: Has placeholders: 0

>>> generateCTC: STEP 1 - Rewriting ATC with concrete values

>>> generateCTC: STEP 2 - Running symbolic execution
[SEE] API call 'reset' ready for actual execution

[ASSIGN] Evaluating: _ := reset()
[API_CALL] Executing API function: reset
  [API_CALL] Getting function from factory...
[Factory] Creating function: reset
  [API_CALL] Executing function...
[ResetFunc] Clearing all collections...
[HttpClient] POST /api/test/reset -> 200
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _
[ASSIGN] Result: _ := 200

[ASSIGN] Evaluating: buyerEmail0 := input()
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X0
[ASSIGN] Result: buyerEmail0 := X0

[ASSIGN] Evaluating: buyerPassword0 := input()
[SEE] Mapping base name 'buyerPassword' -> 'buyerPassword0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X1
[ASSIGN] Result: buyerPassword0 := X1

[ASSIGN] Evaluating: buyerFullName0 := input()
[SEE] Mapping base name 'buyerFullName' -> 'buyerFullName0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X2
[ASSIGN] Result: buyerFullName0 := X2
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_0 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_0'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_0
[ASSIGN] Result: tmp_Roles_0 := {}

[ASSIGN] Evaluating: Roles_old := tmp_Roles_0
  [EVAL] Var lookup: tmp_Roles_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Roles_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_0 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_0'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_0
[ASSIGN] Result: tmp_U_0 := {}

[ASSIGN] Evaluating: U_old := tmp_U_0
  [EVAL] Var lookup: tmp_U_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: U_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_1 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_1'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_1
[ASSIGN] Result: tmp_U_1 := {}

[ASSUME] Evaluating: not_in(buyerEmail, dom(tmp_U_1))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail0'
    [EVAL] Found in sigma: X0
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
[ASSUME] Adding constraint: true
[SEE] API call 'registerBuyer' with symbolic arguments - interruption point
[SEE] Interruption at statement 10

[ASSIGN] Evaluating: _result0 := registerBuyer(buyerEmail, buyerPassword, buyerFullName)
[SEE] Mapping base name '_result' -> '_result0'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail0'
    [EVAL] Found in sigma: X0
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword0'
    [EVAL] Found in sigma: X1
  [EVAL] Var lookup: buyerFullName
    [EVAL] Resolved base name 'buyerFullName' -> 'buyerFullName0'
    [EVAL] Found in sigma: X2
[API_CALL] registerBuyer has symbolic arguments - skipping actual execution
  [API_ARG 0] X0 (symbolic: 1)
  [API_ARG 1] X1 (symbolic: 1)
  [API_ARG 2] X2 (symbolic: 1)
[ASSIGN] Result: _result0 := -1 (symbolic placeholder)
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_2 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_2'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_2
[ASSIGN] Result: tmp_U_2 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_1 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_1'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_1
[ASSIGN] Result: tmp_Roles_1 := {}
[SEE] Interruption at statement 13

[ASSERT] Evaluating: AND(=([](tmp_U_2, buyerEmail), buyerPassword), =([](tmp_Roles_1, buyerEmail), BUYER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: =([](tmp_U_2, buyerEmail), buyerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_2
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail0'
    [EVAL] Found in sigma: X0
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X0
    [EVAL] Key not found in map
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword0'
    [EVAL] Found in sigma: X1
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[0] result: (= []({}, X0) X1)
    [EVAL] Arg[1]: =([](tmp_Roles_1, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail0'
    [EVAL] Found in sigma: X0
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X0
    [EVAL] Key not found in map
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X0) BUYER)
    [EVAL] FuncCall result: AND((= []({}, X0) X1), (= []({}, X0) BUYER))
[ASSERT] Result: AND((= []({}, X0) X1), (= []({}, X0) BUYER))
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: buyerEmail1 := input()
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail1'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X3
[ASSIGN] Result: buyerEmail1 := X3

[ASSIGN] Evaluating: buyerPassword1 := input()
[SEE] Mapping base name 'buyerPassword' -> 'buyerPassword1'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X4
[ASSIGN] Result: buyerPassword1 := X4
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_0 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_0'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_0
[ASSIGN] Result: tmp_T_0 := {}

[ASSIGN] Evaluating: T_old := tmp_T_0
  [EVAL] Var lookup: tmp_T_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: T_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_3 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_3'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_3
[ASSIGN] Result: tmp_U_3 := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_4 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_4'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_4
[ASSIGN] Result: tmp_U_4 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_2 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_2'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_2
[ASSIGN] Result: tmp_Roles_2 := {}
[SEE] Interruption at statement 21

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_U_3)), =([](tmp_U_4, buyerEmail), buyerPassword), =([](tmp_Roles_2, buyerEmail), BUYER))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_U_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail1'
    [EVAL] Found in sigma: X3
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X3
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_U_4, buyerEmail), buyerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_4
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail1'
    [EVAL] Found in sigma: X3
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X3
    [EVAL] Key not found in map
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword1'
    [EVAL] Found in sigma: X4
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X3) X4)
    [EVAL] Arg[2]: =([](tmp_Roles_2, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_2
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail1'
    [EVAL] Found in sigma: X3
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X3
    [EVAL] Key not found in map
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[2] result: (= []({}, X3) BUYER)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'login' with symbolic arguments - interruption point
[SEE] Interruption at statement 22

[ASSIGN] Evaluating: _result1 := login(buyerEmail, buyerPassword)
[SEE] Mapping base name '_result' -> '_result1'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail1'
    [EVAL] Found in sigma: X3
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword1'
    [EVAL] Found in sigma: X4
[API_CALL] login has symbolic arguments - skipping actual execution
  [API_ARG 0] X3 (symbolic: 1)
  [API_ARG 1] X4 (symbolic: 1)
[ASSIGN] Result: _result1 := -1 (symbolic placeholder)
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_1 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_1'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_1
[ASSIGN] Result: tmp_T_1 := {}

[ASSERT] Evaluating: =([](tmp_T_1, buyerEmail), _result1)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_T_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail1'
    [EVAL] Found in sigma: X3
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X3
    [EVAL] Key not found in map
  [EVAL] Var lookup: _result1
    [EVAL] Found in sigma: -1
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
[ASSERT] Result: (= []({}, X3) -1)
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: sellerEmail2 := input()
[SEE] Mapping base name 'sellerEmail' -> 'sellerEmail2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X5
[ASSIGN] Result: sellerEmail2 := X5

[ASSIGN] Evaluating: title2 := input()
[SEE] Mapping base name 'title' -> 'title2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X6
[ASSIGN] Result: title2 := X6

[ASSIGN] Evaluating: description2 := input()
[SEE] Mapping base name 'description' -> 'description2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X7
[ASSIGN] Result: description2 := X7

[ASSIGN] Evaluating: category2 := input()
[SEE] Mapping base name 'category' -> 'category2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X8
[ASSIGN] Result: category2 := X8

[ASSIGN] Evaluating: price2 := input()
[SEE] Mapping base name 'price' -> 'price2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X9
[ASSIGN] Result: price2 := X9

[ASSIGN] Evaluating: quantity2 := input()
[SEE] Mapping base name 'quantity' -> 'quantity2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X10
[ASSIGN] Result: quantity2 := X10
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_0 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_0'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_P_0
[ASSIGN] Result: tmp_P_0 := {}

[ASSIGN] Evaluating: P_old := tmp_P_0
  [EVAL] Var lookup: tmp_P_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: P_old := {}
[SEE] API call 'get_Sellers' ready for actual execution

[ASSIGN] Evaluating: tmp_Sellers_0 := get_Sellers()
[SEE] Mapping base name 'tmp_Sellers_' -> 'tmp_Sellers_0'
[API_CALL] Executing API function: get_Sellers
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Sellers
  [API_CALL] Executing function...
[GetSellersFunc] Fetching Sellers...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Sellers_0
[ASSIGN] Result: tmp_Sellers_0 := {}

[ASSIGN] Evaluating: Sellers_old := tmp_Sellers_0
  [EVAL] Var lookup: tmp_Sellers_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Sellers_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_2 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_2'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_2
[ASSIGN] Result: tmp_T_2 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_3 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_3'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_3
[ASSIGN] Result: tmp_Roles_3 := {}
[SEE] Interruption at statement 37

[ASSUME] Evaluating: AND(in(sellerEmail, dom(tmp_T_2)), =([](tmp_Roles_3, sellerEmail), SELLER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(sellerEmail, dom(tmp_T_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: X5
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_2
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X5
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_3, sellerEmail), SELLER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_3
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: X5
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X5
    [EVAL] Key not found in map
  [EVAL] Var lookup: SELLER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X5) SELLER)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'createProduct' with symbolic arguments - interruption point
[SEE] Interruption at statement 38

[ASSIGN] Evaluating: _result2 := createProduct(sellerEmail, title, description, category, price, quantity)
[SEE] Mapping base name '_result' -> '_result2'
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: X5
  [EVAL] Var lookup: title
    [EVAL] Resolved base name 'title' -> 'title2'
    [EVAL] Found in sigma: X6
  [EVAL] Var lookup: description
    [EVAL] Resolved base name 'description' -> 'description2'
    [EVAL] Found in sigma: X7
  [EVAL] Var lookup: category
    [EVAL] Resolved base name 'category' -> 'category2'
    [EVAL] Found in sigma: X8
  [EVAL] Var lookup: price
    [EVAL] Resolved base name 'price' -> 'price2'
    [EVAL] Found in sigma: X9
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity2'
    [EVAL] Found in sigma: X10
[API_CALL] createProduct has symbolic arguments - skipping actual execution
  [API_ARG 0] X5 (symbolic: 1)
  [API_ARG 1] X6 (symbolic: 1)
  [API_ARG 2] X7 (symbolic: 1)
  [API_ARG 3] X8 (symbolic: 1)
  [API_ARG 4] X9 (symbolic: 1)
  [API_ARG 5] X10 (symbolic: 1)
[ASSIGN] Result: _result2 := -1 (symbolic placeholder)
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_1 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_1'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_P_1
[ASSIGN] Result: tmp_P_1 := {}
[SEE] API call 'get_Sellers' ready for actual execution

[ASSIGN] Evaluating: tmp_Sellers_1 := get_Sellers()
[SEE] Mapping base name 'tmp_Sellers_' -> 'tmp_Sellers_1'
[API_CALL] Executing API function: get_Sellers
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Sellers
  [API_CALL] Executing function...
[GetSellersFunc] Fetching Sellers...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Sellers_1
[ASSIGN] Result: tmp_Sellers_1 := {}
[SEE] Interruption at statement 41

[ASSERT] Evaluating: AND(in(_result2, dom(tmp_P_1)), =([](tmp_Sellers_1, _result2), sellerEmail))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(_result2, dom(tmp_P_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result2
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_P_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Sellers_1, _result2), sellerEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Sellers_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: _result2
    [EVAL] Found in sigma: -1
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: -1
    [EVAL] Key not found in map
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: X5
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, -1) X5)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[SEE] Path Constraint: And(true, And(true, And(AND((= []({}, X0) X1), (= []({}, X0) BUYER)), And(false, And((= []({}, X3) -1), false)))))

[UNSAT-CHECK] Path constraint contains FALSE - checking dependencies...

[DEPENDENCY-CHECK] Analyzing sequence for true UNSAT...
[DEPENDENCY-CHECK] ✓ All dependencies satisfied - sequence is potentially satisfiable.
>>> generateCTC: After symex - Is abstract: 1, Has placeholders: 0

>>> generateCTC: STEP 3 - Generating values with sigma lookup
    [Found existing] _ -> _
    [Found existing] tmp_Roles_ -> tmp_Roles_0
    [Found existing] Roles_old -> Roles_old
    [Found existing] tmp_U_ -> tmp_U_0
    [Found existing] U_old -> U_old
    [Found existing] _result -> _result0
    [Found existing] tmp_T_ -> tmp_T_0
    [Found existing] T_old -> T_old
    [Found existing] tmp_P_ -> tmp_P_0
    [Found existing] P_old -> P_old
    [Found existing] tmp_Sellers_ -> tmp_Sellers_0
    [Found existing] Sellers_old -> Sellers_old
    buyerEmail0 = "buyer@example.com"
    buyerPassword0 = "BuyerPass123!"
    buyerFullName0 = "Test Buyer"
    buyerEmail1 = (reusing buyerEmail) "buyer@example.com"
    buyerPassword1 = (reusing buyerPassword) "BuyerPass123!"
    sellerEmail2 = "seller@example.com"
    title2 = "Test Product"
    description2 = "A great test product description"
    category2 = "Electronics"
    price2 = 99
    quantity2 = 2

>>> generateCTC: STEP 4 - Resolving placeholders from sigma

>>> generateCTC: STEP 5 - Recursing with 11 concrete values

========================================
>>> generateCTC: Starting iteration
========================================
>>> generateCTC: Program needs processing
>>> generateCTC: Concrete values provided: 11
>>> generateCTC: Is abstract: 1
>>> generateCTC: Has placeholders: 0

>>> generateCTC: STEP 1 - Rewriting ATC with concrete values

>>> generateCTC: STEP 2 - Running symbolic execution
[SEE] API call 'reset' ready for actual execution

[ASSIGN] Evaluating: _ := reset()
[API_CALL] Executing API function: reset
  [API_CALL] Getting function from factory...
[Factory] Creating function: reset
  [API_CALL] Executing function...
[ResetFunc] Clearing all collections...
[HttpClient] POST /api/test/reset -> 200
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _
[ASSIGN] Result: _ := 200

[ASSIGN] Evaluating: buyerEmail0 := "buyer@example.com"
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail0'
  [EVAL] String: "buyer@example.com"
[ASSIGN] Result: buyerEmail0 := "buyer@example.com"

[ASSIGN] Evaluating: buyerPassword0 := "BuyerPass123!"
[SEE] Mapping base name 'buyerPassword' -> 'buyerPassword0'
  [EVAL] String: "BuyerPass123!"
[ASSIGN] Result: buyerPassword0 := "BuyerPass123!"

[ASSIGN] Evaluating: buyerFullName0 := "Test Buyer"
[SEE] Mapping base name 'buyerFullName' -> 'buyerFullName0'
  [EVAL] String: "Test Buyer"
[ASSIGN] Result: buyerFullName0 := "Test Buyer"
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_0 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_0'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_0
[ASSIGN] Result: tmp_Roles_0 := {}

[ASSIGN] Evaluating: Roles_old := tmp_Roles_0
  [EVAL] Var lookup: tmp_Roles_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Roles_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_0 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_0'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_0
[ASSIGN] Result: tmp_U_0 := {}

[ASSIGN] Evaluating: U_old := tmp_U_0
  [EVAL] Var lookup: tmp_U_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: U_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_1 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_1'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_1
[ASSIGN] Result: tmp_U_1 := {}

[ASSUME] Evaluating: not_in(buyerEmail, dom(tmp_U_1))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail0'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
[ASSUME] Adding constraint: true
[SEE] API call 'registerBuyer' ready for actual execution

[ASSIGN] Evaluating: _result0 := registerBuyer(buyerEmail, buyerPassword, buyerFullName)
[SEE] Mapping base name '_result' -> '_result0'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail0'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword0'
    [EVAL] Found in sigma: "BuyerPass123!"
  [EVAL] Var lookup: buyerFullName
    [EVAL] Resolved base name 'buyerFullName' -> 'buyerFullName0'
    [EVAL] Found in sigma: "Test Buyer"
[API_CALL] Executing API function: registerBuyer
  [API_ARG] "buyer@example.com"
  [API_ARG] "BuyerPass123!"
  [API_ARG] "Test Buyer"
  [API_CALL] Getting function from factory...
[Factory] Creating function: registerBuyer
  [API_CALL] Executing function...
[RegisterBuyerFunc] Registering buyer: buyer@example.com
[HttpClient] POST /api/auth/register -> 201
  [API_CALL] Function returned: 201
  [API_CALL] Storing result in variable: _result0
[ASSIGN] Result: _result0 := 201
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_2 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_2'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {buyer@example.com -> "BuyerPass123!"}
  [API_CALL] Storing result in variable: tmp_U_2
[ASSIGN] Result: tmp_U_2 := {buyer@example.com -> "BuyerPass123!"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_1 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_1'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {buyer@example.com -> "Buyer"}
  [API_CALL] Storing result in variable: tmp_Roles_1
[ASSIGN] Result: tmp_Roles_1 := {buyer@example.com -> "Buyer"}

[ASSERT] Evaluating: AND(=([](tmp_U_2, buyerEmail), buyerPassword), =([](tmp_Roles_1, buyerEmail), BUYER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: =([](tmp_U_2, buyerEmail), buyerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_2
    [EVAL] Found in sigma: {buyer@example.com -> "BuyerPass123!"}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail0'
    [EVAL] Found in sigma: "buyer@example.com"
    [EVAL] Map expr evaluated: {buyer@example.com -> "BuyerPass123!"}
    [EVAL] Key expr evaluated: "buyer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "BuyerPass123!"
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword0'
    [EVAL] Found in sigma: "BuyerPass123!"
    [EVAL] Eq result: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_1, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_1
    [EVAL] Found in sigma: {buyer@example.com -> "Buyer"}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail0'
    [EVAL] Found in sigma: "buyer@example.com"
    [EVAL] Map expr evaluated: {buyer@example.com -> "Buyer"}
    [EVAL] Key expr evaluated: "buyer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "Buyer"
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "Buyer" BUYER)
    [EVAL] FuncCall result: AND(true, (= "Buyer" BUYER))
[ASSERT] Result: AND(true, (= "Buyer" BUYER))
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: buyerEmail1 := "buyer@example.com"
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail1'
  [EVAL] String: "buyer@example.com"
[ASSIGN] Result: buyerEmail1 := "buyer@example.com"

[ASSIGN] Evaluating: buyerPassword1 := "BuyerPass123!"
[SEE] Mapping base name 'buyerPassword' -> 'buyerPassword1'
  [EVAL] String: "BuyerPass123!"
[ASSIGN] Result: buyerPassword1 := "BuyerPass123!"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_0 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_0'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_0
[ASSIGN] Result: tmp_T_0 := {}

[ASSIGN] Evaluating: T_old := tmp_T_0
  [EVAL] Var lookup: tmp_T_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: T_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_3 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_3'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {buyer@example.com -> "BuyerPass123!"}
  [API_CALL] Storing result in variable: tmp_U_3
[ASSIGN] Result: tmp_U_3 := {buyer@example.com -> "BuyerPass123!"}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_4 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_4'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {buyer@example.com -> "BuyerPass123!"}
  [API_CALL] Storing result in variable: tmp_U_4
[ASSIGN] Result: tmp_U_4 := {buyer@example.com -> "BuyerPass123!"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_2 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_2'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {buyer@example.com -> "Buyer"}
  [API_CALL] Storing result in variable: tmp_Roles_2
[ASSIGN] Result: tmp_Roles_2 := {buyer@example.com -> "Buyer"}

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_U_3)), =([](tmp_U_4, buyerEmail), buyerPassword), =([](tmp_Roles_2, buyerEmail), BUYER))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_U_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail1'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_3
    [EVAL] Found in sigma: {buyer@example.com -> "BuyerPass123!"}
    [EVAL] Map expr evaluated: {buyer@example.com -> "BuyerPass123!"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "buyer@example.com"
    [EVAL] Set: {"buyer@example.com"}
    [EVAL] Element: "buyer@example.com"
    [EVAL] Set: {"buyer@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_U_4, buyerEmail), buyerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_4
    [EVAL] Found in sigma: {buyer@example.com -> "BuyerPass123!"}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail1'
    [EVAL] Found in sigma: "buyer@example.com"
    [EVAL] Map expr evaluated: {buyer@example.com -> "BuyerPass123!"}
    [EVAL] Key expr evaluated: "buyer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "BuyerPass123!"
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword1'
    [EVAL] Found in sigma: "BuyerPass123!"
    [EVAL] Eq result: true
    [EVAL] Arg[1] result: true
    [EVAL] Arg[2]: =([](tmp_Roles_2, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_2
    [EVAL] Found in sigma: {buyer@example.com -> "Buyer"}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail1'
    [EVAL] Found in sigma: "buyer@example.com"
    [EVAL] Map expr evaluated: {buyer@example.com -> "Buyer"}
    [EVAL] Key expr evaluated: "buyer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "Buyer"
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[2] result: (= "Buyer" BUYER)
    [EVAL] FuncCall result: AND(true, true, (= "Buyer" BUYER))
[ASSUME] Adding constraint: AND(true, true, (= "Buyer" BUYER))
[SEE] API call 'login' ready for actual execution

[ASSIGN] Evaluating: _result1 := login(buyerEmail, buyerPassword)
[SEE] Mapping base name '_result' -> '_result1'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail1'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword1'
    [EVAL] Found in sigma: "BuyerPass123!"
[API_CALL] Executing API function: login
  [API_ARG] "buyer@example.com"
  [API_ARG] "BuyerPass123!"
  [API_CALL] Getting function from factory...
[Factory] Creating function: login
  [API_CALL] Executing function...
[LoginFunc] Logging in: buyer@example.com
[HttpClient] POST /api/auth/login -> 200
[LoginFunc] Token received for: buyer@example.com
  [API_CALL] Function returned: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYmE0ZTA5ZmM3ZmEyYzA2YzI2ZGYiLCJpYXQiOjE3Njg3MzMyNjIsImV4cCI6MTc2ODgxOTY2Mn0.NP-UUzEPHqyRPS3Ts-CvaWsLXL3PgpT6Z7XMncMW-z8"
  [API_CALL] Storing result in variable: _result1
[ASSIGN] Result: _result1 := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYmE0ZTA5ZmM3ZmEyYzA2YzI2ZGYiLCJpYXQiOjE3Njg3MzMyNjIsImV4cCI6MTc2ODgxOTY2Mn0.NP-UUzEPHqyRPS3Ts-CvaWsLXL3PgpT6Z7XMncMW-z8"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_1 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_1'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYmE0ZTA5ZmM3ZmEyYzA2YzI2ZGYiLCJpYXQiOjE3Njg3MzMyNjIsImV4cCI6MTc2ODgxOTY2Mn0.NP-UUzEPHqyRPS3Ts-CvaWsLXL3PgpT6Z7XMncMW-z8"}
  [API_CALL] Storing result in variable: tmp_T_1
[ASSIGN] Result: tmp_T_1 := {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYmE0ZTA5ZmM3ZmEyYzA2YzI2ZGYiLCJpYXQiOjE3Njg3MzMyNjIsImV4cCI6MTc2ODgxOTY2Mn0.NP-UUzEPHqyRPS3Ts-CvaWsLXL3PgpT6Z7XMncMW-z8"}

[ASSERT] Evaluating: =([](tmp_T_1, buyerEmail), _result1)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_T_1
    [EVAL] Found in sigma: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYmE0ZTA5ZmM3ZmEyYzA2YzI2ZGYiLCJpYXQiOjE3Njg3MzMyNjIsImV4cCI6MTc2ODgxOTY2Mn0.NP-UUzEPHqyRPS3Ts-CvaWsLXL3PgpT6Z7XMncMW-z8"}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail1'
    [EVAL] Found in sigma: "buyer@example.com"
    [EVAL] Map expr evaluated: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYmE0ZTA5ZmM3ZmEyYzA2YzI2ZGYiLCJpYXQiOjE3Njg3MzMyNjIsImV4cCI6MTc2ODgxOTY2Mn0.NP-UUzEPHqyRPS3Ts-CvaWsLXL3PgpT6Z7XMncMW-z8"}
    [EVAL] Key expr evaluated: "buyer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYmE0ZTA5ZmM3ZmEyYzA2YzI2ZGYiLCJpYXQiOjE3Njg3MzMyNjIsImV4cCI6MTc2ODgxOTY2Mn0.NP-UUzEPHqyRPS3Ts-CvaWsLXL3PgpT6Z7XMncMW-z8"
  [EVAL] Var lookup: _result1
    [EVAL] Found in sigma: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYmE0ZTA5ZmM3ZmEyYzA2YzI2ZGYiLCJpYXQiOjE3Njg3MzMyNjIsImV4cCI6MTc2ODgxOTY2Mn0.NP-UUzEPHqyRPS3Ts-CvaWsLXL3PgpT6Z7XMncMW-z8"
    [EVAL] Eq result: true
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[ASSIGN] Evaluating: sellerEmail2 := "seller@example.com"
[SEE] Mapping base name 'sellerEmail' -> 'sellerEmail2'
  [EVAL] String: "seller@example.com"
[ASSIGN] Result: sellerEmail2 := "seller@example.com"

[ASSIGN] Evaluating: title2 := "Test Product"
[SEE] Mapping base name 'title' -> 'title2'
  [EVAL] String: "Test Product"
[ASSIGN] Result: title2 := "Test Product"

[ASSIGN] Evaluating: description2 := "A great test product description"
[SEE] Mapping base name 'description' -> 'description2'
  [EVAL] String: "A great test product description"
[ASSIGN] Result: description2 := "A great test product description"

[ASSIGN] Evaluating: category2 := "Electronics"
[SEE] Mapping base name 'category' -> 'category2'
  [EVAL] String: "Electronics"
[ASSIGN] Result: category2 := "Electronics"

[ASSIGN] Evaluating: price2 := 99
[SEE] Mapping base name 'price' -> 'price2'
  [EVAL] Num: 99
[ASSIGN] Result: price2 := 99

[ASSIGN] Evaluating: quantity2 := 2
[SEE] Mapping base name 'quantity' -> 'quantity2'
  [EVAL] Num: 2
[ASSIGN] Result: quantity2 := 2
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_0 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_0'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_P_0
[ASSIGN] Result: tmp_P_0 := {}

[ASSIGN] Evaluating: P_old := tmp_P_0
  [EVAL] Var lookup: tmp_P_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: P_old := {}
[SEE] API call 'get_Sellers' ready for actual execution

[ASSIGN] Evaluating: tmp_Sellers_0 := get_Sellers()
[SEE] Mapping base name 'tmp_Sellers_' -> 'tmp_Sellers_0'
[API_CALL] Executing API function: get_Sellers
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Sellers
  [API_CALL] Executing function...
[GetSellersFunc] Fetching Sellers...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Sellers_0
[ASSIGN] Result: tmp_Sellers_0 := {}

[ASSIGN] Evaluating: Sellers_old := tmp_Sellers_0
  [EVAL] Var lookup: tmp_Sellers_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Sellers_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_2 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_2'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYmE0ZTA5ZmM3ZmEyYzA2YzI2ZGYiLCJpYXQiOjE3Njg3MzMyNjIsImV4cCI6MTc2ODgxOTY2Mn0.NP-UUzEPHqyRPS3Ts-CvaWsLXL3PgpT6Z7XMncMW-z8"}
  [API_CALL] Storing result in variable: tmp_T_2
[ASSIGN] Result: tmp_T_2 := {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYmE0ZTA5ZmM3ZmEyYzA2YzI2ZGYiLCJpYXQiOjE3Njg3MzMyNjIsImV4cCI6MTc2ODgxOTY2Mn0.NP-UUzEPHqyRPS3Ts-CvaWsLXL3PgpT6Z7XMncMW-z8"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_3 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_3'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {buyer@example.com -> "Buyer"}
  [API_CALL] Storing result in variable: tmp_Roles_3
[ASSIGN] Result: tmp_Roles_3 := {buyer@example.com -> "Buyer"}

[ASSUME] Evaluating: AND(in(sellerEmail, dom(tmp_T_2)), =([](tmp_Roles_3, sellerEmail), SELLER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(sellerEmail, dom(tmp_T_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: "seller@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_2
    [EVAL] Found in sigma: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYmE0ZTA5ZmM3ZmEyYzA2YzI2ZGYiLCJpYXQiOjE3Njg3MzMyNjIsImV4cCI6MTc2ODgxOTY2Mn0.NP-UUzEPHqyRPS3Ts-CvaWsLXL3PgpT6Z7XMncMW-z8"}
    [EVAL] Map expr evaluated: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYmE0ZTA5ZmM3ZmEyYzA2YzI2ZGYiLCJpYXQiOjE3Njg3MzMyNjIsImV4cCI6MTc2ODgxOTY2Mn0.NP-UUzEPHqyRPS3Ts-CvaWsLXL3PgpT6Z7XMncMW-z8"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "buyer@example.com"
    [EVAL] Set: {"buyer@example.com"}
    [EVAL] Element: "seller@example.com"
    [EVAL] Set: {"buyer@example.com"}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_3, sellerEmail), SELLER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_3
    [EVAL] Found in sigma: {buyer@example.com -> "Buyer"}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: "seller@example.com"
    [EVAL] Map expr evaluated: {buyer@example.com -> "Buyer"}
    [EVAL] Key expr evaluated: "seller@example.com"
    [EVAL] Key not found in map
  [EVAL] Var lookup: SELLER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({buyer@example.com -> "Buyer"}, "seller@example.com") SELLER)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'createProduct' ready for actual execution

[ASSIGN] Evaluating: _result2 := createProduct(sellerEmail, title, description, category, price, quantity)
[SEE] Mapping base name '_result' -> '_result2'
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: "seller@example.com"
  [EVAL] Var lookup: title
    [EVAL] Resolved base name 'title' -> 'title2'
    [EVAL] Found in sigma: "Test Product"
  [EVAL] Var lookup: description
    [EVAL] Resolved base name 'description' -> 'description2'
    [EVAL] Found in sigma: "A great test product description"
  [EVAL] Var lookup: category
    [EVAL] Resolved base name 'category' -> 'category2'
    [EVAL] Found in sigma: "Electronics"
  [EVAL] Var lookup: price
    [EVAL] Resolved base name 'price' -> 'price2'
    [EVAL] Found in sigma: 99
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity2'
    [EVAL] Found in sigma: 2
[API_CALL] Executing API function: createProduct
  [API_ARG] "seller@example.com"
  [API_ARG] "Test Product"
  [API_ARG] "A great test product description"
  [API_ARG] "Electronics"
  [API_ARG] 99
  [API_ARG] 2
  [API_CALL] Getting function from factory...
[Factory] Creating function: createProduct
  [API_CALL] Executing function...
[CreateProductFunc] seller@example.com creating product: Test Product
  [API_CALL] Function returned: ""
  [API_CALL] Storing result in variable: _result2
[ASSIGN] Result: _result2 := ""
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_1 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_1'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_P_1
[ASSIGN] Result: tmp_P_1 := {}
[SEE] API call 'get_Sellers' ready for actual execution

[ASSIGN] Evaluating: tmp_Sellers_1 := get_Sellers()
[SEE] Mapping base name 'tmp_Sellers_' -> 'tmp_Sellers_1'
[API_CALL] Executing API function: get_Sellers
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Sellers
  [API_CALL] Executing function...
[GetSellersFunc] Fetching Sellers...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Sellers_1
[ASSIGN] Result: tmp_Sellers_1 := {}

[ASSERT] Evaluating: AND(in(_result2, dom(tmp_P_1)), =([](tmp_Sellers_1, _result2), sellerEmail))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(_result2, dom(tmp_P_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result2
    [EVAL] Found in sigma: ""
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_P_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: ""
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Sellers_1, _result2), sellerEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Sellers_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: _result2
    [EVAL] Found in sigma: ""
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: ""
    [EVAL] Key not found in map
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: "seller@example.com"
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, "") "seller@example.com")
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[SEE] Path Constraint: And(true, And(true, And(AND(true, (= "Buyer" BUYER)), And(AND(true, true, (= "Buyer" BUYER)), false))))

[UNSAT-CHECK] Path constraint contains FALSE - checking dependencies...

[DEPENDENCY-CHECK] Analyzing sequence for true UNSAT...
[DEPENDENCY-CHECK] ✓ All dependencies satisfied - sequence is potentially satisfiable.
>>> generateCTC: After symex - Is abstract: 0, Has placeholders: 0
>>> generateCTC: Program is now fully concrete

[FINAL CTC]
=== Program ===
Statement 0: _ := reset()
Statement 1: buyerEmail0 := "buyer@example.com"
Statement 2: buyerPassword0 := "BuyerPass123!"
Statement 3: buyerFullName0 := "Test Buyer"
Statement 4: tmp_Roles_0 := get_Roles()
Statement 5: Roles_old := tmp_Roles_0
Statement 6: tmp_U_0 := get_U()
Statement 7: U_old := tmp_U_0
Statement 8: tmp_U_1 := get_U()
Statement 9: assume(not_in(buyerEmail, dom(tmp_U_1)))
Statement 10: _result0 := registerBuyer(buyerEmail, buyerPassword, buyerFullName)
Statement 11: tmp_U_2 := get_U()
Statement 12: tmp_Roles_1 := get_Roles()
Statement 13: assert(AND(=([](tmp_U_2, buyerEmail), buyerPassword), =([](tmp_Roles_1, buyerEmail), BUYER)))
Statement 14: buyerEmail1 := "buyer@example.com"
Statement 15: buyerPassword1 := "BuyerPass123!"
Statement 16: tmp_T_0 := get_T()
Statement 17: T_old := tmp_T_0
Statement 18: tmp_U_3 := get_U()
Statement 19: tmp_U_4 := get_U()
Statement 20: tmp_Roles_2 := get_Roles()
Statement 21: assume(AND(in(buyerEmail, dom(tmp_U_3)), =([](tmp_U_4, buyerEmail), buyerPassword), =([](tmp_Roles_2, buyerEmail), BUYER)))
Statement 22: _result1 := login(buyerEmail, buyerPassword)
Statement 23: tmp_T_1 := get_T()
Statement 24: assert(=([](tmp_T_1, buyerEmail), _result1))
Statement 25: sellerEmail2 := "seller@example.com"
Statement 26: title2 := "Test Product"
Statement 27: description2 := "A great test product description"
Statement 28: category2 := "Electronics"
Statement 29: price2 := 99
Statement 30: quantity2 := 2
Statement 31: tmp_P_0 := get_P()
Statement 32: P_old := tmp_P_0
Statement 33: tmp_Sellers_0 := get_Sellers()
Statement 34: Sellers_old := tmp_Sellers_0
Statement 35: tmp_T_2 := get_T()
Statement 36: tmp_Roles_3 := get_Roles()
Statement 37: assume(AND(in(sellerEmail, dom(tmp_T_2)), =([](tmp_Roles_3, sellerEmail), SELLER)))
Statement 38: _result2 := createProduct(sellerEmail, title, description, category, price, quantity)
Statement 39: tmp_P_1 := get_P()
Statement 40: tmp_Sellers_1 := get_Sellers()
Statement 41: assert(AND(in(_result2, dom(tmp_P_1)), =([](tmp_Sellers_1, _result2), sellerEmail)))
=== End Program ===

✓ [UNSAT] Test 25: Buyer Cannot Create Product (Depth=3) COMPLETE!

