
╔════════════════════════════════════════╗
║  TESTGEN - E-COMMERCE TEST SUITE       ║
║  Total Tests: 30 (21 SAT, 9 UNSAT)     ║
╚════════════════════════════════════════╝


========================================
TEST: [UNSAT] Test 30: Create Review - No Order Placed (Depth=7)
MODE: Full Pipeline (With Backend)
DEPTH: 7 API calls
========================================

[EcommerceFunctionFactory] Initialized with baseUrl: http://localhost:3000
[RewriteGlobalsVisitor] Detected 10 globals: C O OrderStatus P Rev Roles Sellers Stock T U 
[RewriteGlobalsVisitor] Generated 0 statements in rewritten program

=== TEST-API ATC (After Rewrite) ===
=== Program ===
Statement 0: _ := reset()
Statement 1: sellerEmail0 := input()
Statement 2: sellerPassword0 := input()
Statement 3: sellerFullName0 := input()
Statement 4: storeName0 := input()
Statement 5: storeDescription0 := input()
Statement 6: tmp_Roles_0 := get_Roles()
Statement 7: Roles_old := tmp_Roles_0
Statement 8: tmp_U_0 := get_U()
Statement 9: U_old := tmp_U_0
Statement 10: tmp_U_1 := get_U()
Statement 11: assume(not_in(sellerEmail, dom(tmp_U_1)))
Statement 12: _result0 := registerSeller(sellerEmail, sellerPassword, sellerFullName, storeName, storeDescription)
Statement 13: tmp_U_2 := get_U()
Statement 14: tmp_Roles_1 := get_Roles()
Statement 15: assert(AND(=([](tmp_U_2, sellerEmail), sellerPassword), =([](tmp_Roles_1, sellerEmail), SELLER)))
Statement 16: sellerEmail1 := input()
Statement 17: sellerPassword1 := input()
Statement 18: tmp_T_0 := get_T()
Statement 19: T_old := tmp_T_0
Statement 20: tmp_U_3 := get_U()
Statement 21: tmp_U_4 := get_U()
Statement 22: tmp_Roles_2 := get_Roles()
Statement 23: assume(AND(in(sellerEmail, dom(tmp_U_3)), =([](tmp_U_4, sellerEmail), sellerPassword), =([](tmp_Roles_2, sellerEmail), SELLER)))
Statement 24: _result1 := login(sellerEmail, sellerPassword)
Statement 25: tmp_T_1 := get_T()
Statement 26: assert(=([](tmp_T_1, sellerEmail), _result1))
Statement 27: sellerEmail2 := input()
Statement 28: title2 := input()
Statement 29: description2 := input()
Statement 30: category2 := input()
Statement 31: price2 := input()
Statement 32: quantity2 := input()
Statement 33: tmp_P_0 := get_P()
Statement 34: P_old := tmp_P_0
Statement 35: tmp_Sellers_0 := get_Sellers()
Statement 36: Sellers_old := tmp_Sellers_0
Statement 37: tmp_T_2 := get_T()
Statement 38: tmp_Roles_3 := get_Roles()
Statement 39: assume(AND(in(sellerEmail, dom(tmp_T_2)), =([](tmp_Roles_3, sellerEmail), SELLER)))
Statement 40: _result2 := createProduct(sellerEmail, title, description, category, price, quantity)
Statement 41: tmp_P_1 := get_P()
Statement 42: tmp_Sellers_1 := get_Sellers()
Statement 43: assert(AND(in(_result2, dom(tmp_P_1)), =([](tmp_Sellers_1, _result2), sellerEmail)))
Statement 44: buyerEmail3 := input()
Statement 45: buyerPassword3 := input()
Statement 46: buyerFullName3 := input()
Statement 47: tmp_Roles_4 := get_Roles()
Statement 48: Roles_old := tmp_Roles_4
Statement 49: tmp_U_5 := get_U()
Statement 50: U_old := tmp_U_5
Statement 51: tmp_U_6 := get_U()
Statement 52: assume(not_in(buyerEmail, dom(tmp_U_6)))
Statement 53: _result3 := registerBuyer(buyerEmail, buyerPassword, buyerFullName)
Statement 54: tmp_U_7 := get_U()
Statement 55: tmp_Roles_5 := get_Roles()
Statement 56: assert(AND(=([](tmp_U_7, buyerEmail), buyerPassword), =([](tmp_Roles_5, buyerEmail), BUYER)))
Statement 57: buyerEmail4 := input()
Statement 58: buyerPassword4 := input()
Statement 59: tmp_T_3 := get_T()
Statement 60: T_old := tmp_T_3
Statement 61: tmp_U_8 := get_U()
Statement 62: tmp_U_9 := get_U()
Statement 63: tmp_Roles_6 := get_Roles()
Statement 64: assume(AND(in(buyerEmail, dom(tmp_U_8)), =([](tmp_U_9, buyerEmail), buyerPassword), =([](tmp_Roles_6, buyerEmail), BUYER)))
Statement 65: _result4 := login(buyerEmail, buyerPassword)
Statement 66: tmp_T_4 := get_T()
Statement 67: assert(=([](tmp_T_4, buyerEmail), _result4))
Statement 68: buyerEmail5 := input()
Statement 69: productId5 := input()
Statement 70: quantity5 := input()
Statement 71: tmp_C_0 := get_C()
Statement 72: C_old := tmp_C_0
Statement 73: tmp_T_5 := get_T()
Statement 74: tmp_Roles_7 := get_Roles()
Statement 75: tmp_P_2 := get_P()
Statement 76: assume(AND(in(buyerEmail, dom(tmp_T_5)), =([](tmp_Roles_7, buyerEmail), BUYER), in(productId, dom(tmp_P_2))))
Statement 77: _result5 := addToCart(buyerEmail, productId, quantity)
Statement 78: tmp_C_1 := get_C()
Statement 79: assert(in(buyerEmail, dom(tmp_C_1)))
Statement 80: buyerEmail6 := input()
Statement 81: productId6 := input()
Statement 82: orderId6 := input()
Statement 83: rating6 := input()
Statement 84: comment6 := input()
Statement 85: tmp_Rev_0 := get_Rev()
Statement 86: Rev_old := tmp_Rev_0
Statement 87: tmp_T_6 := get_T()
Statement 88: tmp_Roles_8 := get_Roles()
Statement 89: tmp_O_0 := get_O()
Statement 90: tmp_O_1 := get_O()
Statement 91: assume(AND(in(buyerEmail, dom(tmp_T_6)), =([](tmp_Roles_8, buyerEmail), BUYER), in(orderId, dom(tmp_O_0)), =([](tmp_O_1, orderId), buyerEmail)))
Statement 92: _result6 := createReview(buyerEmail, productId, orderId, rating, comment)
Statement 93: tmp_Rev_1 := get_Rev()
Statement 94: assert(in(_result6, dom(tmp_Rev_1)))
=== End Program ===

========================================
>>> generateCTC: Starting iteration
========================================
>>> generateCTC: Program needs processing
>>> generateCTC: Concrete values provided: 0
>>> generateCTC: Is abstract: 1
>>> generateCTC: Has placeholders: 0

>>> generateCTC: STEP 1 - Rewriting ATC with concrete values

>>> generateCTC: STEP 2 - Running symbolic execution
[SEE] API call 'reset' ready for actual execution

[ASSIGN] Evaluating: _ := reset()
[API_CALL] Executing API function: reset
  [API_CALL] Getting function from factory...
[Factory] Creating function: reset
  [API_CALL] Executing function...
[ResetFunc] Clearing all collections...
[HttpClient] POST /api/test/reset -> 200
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _
[ASSIGN] Result: _ := 200

[ASSIGN] Evaluating: sellerEmail0 := input()
[SEE] Mapping base name 'sellerEmail' -> 'sellerEmail0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X0
[ASSIGN] Result: sellerEmail0 := X0

[ASSIGN] Evaluating: sellerPassword0 := input()
[SEE] Mapping base name 'sellerPassword' -> 'sellerPassword0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X1
[ASSIGN] Result: sellerPassword0 := X1

[ASSIGN] Evaluating: sellerFullName0 := input()
[SEE] Mapping base name 'sellerFullName' -> 'sellerFullName0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X2
[ASSIGN] Result: sellerFullName0 := X2

[ASSIGN] Evaluating: storeName0 := input()
[SEE] Mapping base name 'storeName' -> 'storeName0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X3
[ASSIGN] Result: storeName0 := X3

[ASSIGN] Evaluating: storeDescription0 := input()
[SEE] Mapping base name 'storeDescription' -> 'storeDescription0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X4
[ASSIGN] Result: storeDescription0 := X4
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_0 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_0'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_0
[ASSIGN] Result: tmp_Roles_0 := {}

[ASSIGN] Evaluating: Roles_old := tmp_Roles_0
  [EVAL] Var lookup: tmp_Roles_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Roles_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_0 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_0'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_0
[ASSIGN] Result: tmp_U_0 := {}

[ASSIGN] Evaluating: U_old := tmp_U_0
  [EVAL] Var lookup: tmp_U_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: U_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_1 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_1'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_1
[ASSIGN] Result: tmp_U_1 := {}

[ASSUME] Evaluating: not_in(sellerEmail, dom(tmp_U_1))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail0'
    [EVAL] Found in sigma: X0
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
[ASSUME] Adding constraint: true
[SEE] API call 'registerSeller' with symbolic arguments - interruption point
[SEE] Interruption at statement 12

[ASSIGN] Evaluating: _result0 := registerSeller(sellerEmail, sellerPassword, sellerFullName, storeName, storeDescription)
[SEE] Mapping base name '_result' -> '_result0'
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail0'
    [EVAL] Found in sigma: X0
  [EVAL] Var lookup: sellerPassword
    [EVAL] Resolved base name 'sellerPassword' -> 'sellerPassword0'
    [EVAL] Found in sigma: X1
  [EVAL] Var lookup: sellerFullName
    [EVAL] Resolved base name 'sellerFullName' -> 'sellerFullName0'
    [EVAL] Found in sigma: X2
  [EVAL] Var lookup: storeName
    [EVAL] Resolved base name 'storeName' -> 'storeName0'
    [EVAL] Found in sigma: X3
  [EVAL] Var lookup: storeDescription
    [EVAL] Resolved base name 'storeDescription' -> 'storeDescription0'
    [EVAL] Found in sigma: X4
[API_CALL] registerSeller has symbolic arguments - skipping actual execution
  [API_ARG 0] X0 (symbolic: 1)
  [API_ARG 1] X1 (symbolic: 1)
  [API_ARG 2] X2 (symbolic: 1)
  [API_ARG 3] X3 (symbolic: 1)
  [API_ARG 4] X4 (symbolic: 1)
[ASSIGN] Result: _result0 := -1 (symbolic placeholder)
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_2 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_2'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_2
[ASSIGN] Result: tmp_U_2 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_1 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_1'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_1
[ASSIGN] Result: tmp_Roles_1 := {}
[SEE] Interruption at statement 15

[ASSERT] Evaluating: AND(=([](tmp_U_2, sellerEmail), sellerPassword), =([](tmp_Roles_1, sellerEmail), SELLER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: =([](tmp_U_2, sellerEmail), sellerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_2
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail0'
    [EVAL] Found in sigma: X0
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X0
    [EVAL] Key not found in map
  [EVAL] Var lookup: sellerPassword
    [EVAL] Resolved base name 'sellerPassword' -> 'sellerPassword0'
    [EVAL] Found in sigma: X1
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[0] result: (= []({}, X0) X1)
    [EVAL] Arg[1]: =([](tmp_Roles_1, sellerEmail), SELLER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail0'
    [EVAL] Found in sigma: X0
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X0
    [EVAL] Key not found in map
  [EVAL] Var lookup: SELLER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X0) SELLER)
    [EVAL] FuncCall result: AND((= []({}, X0) X1), (= []({}, X0) SELLER))
[ASSERT] Result: AND((= []({}, X0) X1), (= []({}, X0) SELLER))
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: sellerEmail1 := input()
[SEE] Mapping base name 'sellerEmail' -> 'sellerEmail1'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X5
[ASSIGN] Result: sellerEmail1 := X5

[ASSIGN] Evaluating: sellerPassword1 := input()
[SEE] Mapping base name 'sellerPassword' -> 'sellerPassword1'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X6
[ASSIGN] Result: sellerPassword1 := X6
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_0 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_0'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_0
[ASSIGN] Result: tmp_T_0 := {}

[ASSIGN] Evaluating: T_old := tmp_T_0
  [EVAL] Var lookup: tmp_T_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: T_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_3 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_3'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_3
[ASSIGN] Result: tmp_U_3 := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_4 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_4'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_4
[ASSIGN] Result: tmp_U_4 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_2 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_2'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_2
[ASSIGN] Result: tmp_Roles_2 := {}
[SEE] Interruption at statement 23

[ASSUME] Evaluating: AND(in(sellerEmail, dom(tmp_U_3)), =([](tmp_U_4, sellerEmail), sellerPassword), =([](tmp_Roles_2, sellerEmail), SELLER))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(sellerEmail, dom(tmp_U_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail1'
    [EVAL] Found in sigma: X5
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X5
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_U_4, sellerEmail), sellerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_4
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail1'
    [EVAL] Found in sigma: X5
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X5
    [EVAL] Key not found in map
  [EVAL] Var lookup: sellerPassword
    [EVAL] Resolved base name 'sellerPassword' -> 'sellerPassword1'
    [EVAL] Found in sigma: X6
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X5) X6)
    [EVAL] Arg[2]: =([](tmp_Roles_2, sellerEmail), SELLER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_2
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail1'
    [EVAL] Found in sigma: X5
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X5
    [EVAL] Key not found in map
  [EVAL] Var lookup: SELLER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[2] result: (= []({}, X5) SELLER)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'login' with symbolic arguments - interruption point
[SEE] Interruption at statement 24

[ASSIGN] Evaluating: _result1 := login(sellerEmail, sellerPassword)
[SEE] Mapping base name '_result' -> '_result1'
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail1'
    [EVAL] Found in sigma: X5
  [EVAL] Var lookup: sellerPassword
    [EVAL] Resolved base name 'sellerPassword' -> 'sellerPassword1'
    [EVAL] Found in sigma: X6
[API_CALL] login has symbolic arguments - skipping actual execution
  [API_ARG 0] X5 (symbolic: 1)
  [API_ARG 1] X6 (symbolic: 1)
[ASSIGN] Result: _result1 := -1 (symbolic placeholder)
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_1 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_1'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_1
[ASSIGN] Result: tmp_T_1 := {}

[ASSERT] Evaluating: =([](tmp_T_1, sellerEmail), _result1)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_T_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail1'
    [EVAL] Found in sigma: X5
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X5
    [EVAL] Key not found in map
  [EVAL] Var lookup: _result1
    [EVAL] Found in sigma: -1
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
[ASSERT] Result: (= []({}, X5) -1)
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: sellerEmail2 := input()
[SEE] Mapping base name 'sellerEmail' -> 'sellerEmail2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X7
[ASSIGN] Result: sellerEmail2 := X7

[ASSIGN] Evaluating: title2 := input()
[SEE] Mapping base name 'title' -> 'title2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X8
[ASSIGN] Result: title2 := X8

[ASSIGN] Evaluating: description2 := input()
[SEE] Mapping base name 'description' -> 'description2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X9
[ASSIGN] Result: description2 := X9

[ASSIGN] Evaluating: category2 := input()
[SEE] Mapping base name 'category' -> 'category2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X10
[ASSIGN] Result: category2 := X10

[ASSIGN] Evaluating: price2 := input()
[SEE] Mapping base name 'price' -> 'price2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X11
[ASSIGN] Result: price2 := X11

[ASSIGN] Evaluating: quantity2 := input()
[SEE] Mapping base name 'quantity' -> 'quantity2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X12
[ASSIGN] Result: quantity2 := X12
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_0 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_0'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_P_0
[ASSIGN] Result: tmp_P_0 := {}

[ASSIGN] Evaluating: P_old := tmp_P_0
  [EVAL] Var lookup: tmp_P_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: P_old := {}
[SEE] API call 'get_Sellers' ready for actual execution

[ASSIGN] Evaluating: tmp_Sellers_0 := get_Sellers()
[SEE] Mapping base name 'tmp_Sellers_' -> 'tmp_Sellers_0'
[API_CALL] Executing API function: get_Sellers
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Sellers
  [API_CALL] Executing function...
[GetSellersFunc] Fetching Sellers...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Sellers_0
[ASSIGN] Result: tmp_Sellers_0 := {}

[ASSIGN] Evaluating: Sellers_old := tmp_Sellers_0
  [EVAL] Var lookup: tmp_Sellers_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Sellers_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_2 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_2'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_2
[ASSIGN] Result: tmp_T_2 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_3 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_3'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_3
[ASSIGN] Result: tmp_Roles_3 := {}
[SEE] Interruption at statement 39

[ASSUME] Evaluating: AND(in(sellerEmail, dom(tmp_T_2)), =([](tmp_Roles_3, sellerEmail), SELLER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(sellerEmail, dom(tmp_T_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: X7
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_2
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X7
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_3, sellerEmail), SELLER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_3
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: X7
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X7
    [EVAL] Key not found in map
  [EVAL] Var lookup: SELLER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X7) SELLER)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'createProduct' with symbolic arguments - interruption point
[SEE] Interruption at statement 40

[ASSIGN] Evaluating: _result2 := createProduct(sellerEmail, title, description, category, price, quantity)
[SEE] Mapping base name '_result' -> '_result2'
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: X7
  [EVAL] Var lookup: title
    [EVAL] Resolved base name 'title' -> 'title2'
    [EVAL] Found in sigma: X8
  [EVAL] Var lookup: description
    [EVAL] Resolved base name 'description' -> 'description2'
    [EVAL] Found in sigma: X9
  [EVAL] Var lookup: category
    [EVAL] Resolved base name 'category' -> 'category2'
    [EVAL] Found in sigma: X10
  [EVAL] Var lookup: price
    [EVAL] Resolved base name 'price' -> 'price2'
    [EVAL] Found in sigma: X11
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity2'
    [EVAL] Found in sigma: X12
[API_CALL] createProduct has symbolic arguments - skipping actual execution
  [API_ARG 0] X7 (symbolic: 1)
  [API_ARG 1] X8 (symbolic: 1)
  [API_ARG 2] X9 (symbolic: 1)
  [API_ARG 3] X10 (symbolic: 1)
  [API_ARG 4] X11 (symbolic: 1)
  [API_ARG 5] X12 (symbolic: 1)
[ASSIGN] Result: _result2 := -1 (symbolic placeholder)
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_1 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_1'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_P_1
[ASSIGN] Result: tmp_P_1 := {}
[SEE] API call 'get_Sellers' ready for actual execution

[ASSIGN] Evaluating: tmp_Sellers_1 := get_Sellers()
[SEE] Mapping base name 'tmp_Sellers_' -> 'tmp_Sellers_1'
[API_CALL] Executing API function: get_Sellers
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Sellers
  [API_CALL] Executing function...
[GetSellersFunc] Fetching Sellers...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Sellers_1
[ASSIGN] Result: tmp_Sellers_1 := {}
[SEE] Interruption at statement 43

[ASSERT] Evaluating: AND(in(_result2, dom(tmp_P_1)), =([](tmp_Sellers_1, _result2), sellerEmail))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(_result2, dom(tmp_P_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result2
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_P_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Sellers_1, _result2), sellerEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Sellers_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: _result2
    [EVAL] Found in sigma: -1
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: -1
    [EVAL] Key not found in map
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: X7
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, -1) X7)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: buyerEmail3 := input()
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X13
[ASSIGN] Result: buyerEmail3 := X13

[ASSIGN] Evaluating: buyerPassword3 := input()
[SEE] Mapping base name 'buyerPassword' -> 'buyerPassword3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X14
[ASSIGN] Result: buyerPassword3 := X14

[ASSIGN] Evaluating: buyerFullName3 := input()
[SEE] Mapping base name 'buyerFullName' -> 'buyerFullName3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X15
[ASSIGN] Result: buyerFullName3 := X15
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_4 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_4'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_4
[ASSIGN] Result: tmp_Roles_4 := {}

[ASSIGN] Evaluating: Roles_old := tmp_Roles_4
  [EVAL] Var lookup: tmp_Roles_4
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Roles_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_5 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_5'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_5
[ASSIGN] Result: tmp_U_5 := {}

[ASSIGN] Evaluating: U_old := tmp_U_5
  [EVAL] Var lookup: tmp_U_5
    [EVAL] Found in sigma: {}
[ASSIGN] Result: U_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_6 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_6'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_6
[ASSIGN] Result: tmp_U_6 := {}

[ASSUME] Evaluating: not_in(buyerEmail, dom(tmp_U_6))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail3'
    [EVAL] Found in sigma: X13
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_6
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
[ASSUME] Adding constraint: true
[SEE] API call 'registerBuyer' with symbolic arguments - interruption point
[SEE] Interruption at statement 53

[ASSIGN] Evaluating: _result3 := registerBuyer(buyerEmail, buyerPassword, buyerFullName)
[SEE] Mapping base name '_result' -> '_result3'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail3'
    [EVAL] Found in sigma: X13
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword3'
    [EVAL] Found in sigma: X14
  [EVAL] Var lookup: buyerFullName
    [EVAL] Resolved base name 'buyerFullName' -> 'buyerFullName3'
    [EVAL] Found in sigma: X15
[API_CALL] registerBuyer has symbolic arguments - skipping actual execution
  [API_ARG 0] X13 (symbolic: 1)
  [API_ARG 1] X14 (symbolic: 1)
  [API_ARG 2] X15 (symbolic: 1)
[ASSIGN] Result: _result3 := -1 (symbolic placeholder)
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_7 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_7'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_7
[ASSIGN] Result: tmp_U_7 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_5 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_5'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_5
[ASSIGN] Result: tmp_Roles_5 := {}
[SEE] Interruption at statement 56

[ASSERT] Evaluating: AND(=([](tmp_U_7, buyerEmail), buyerPassword), =([](tmp_Roles_5, buyerEmail), BUYER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: =([](tmp_U_7, buyerEmail), buyerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_7
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail3'
    [EVAL] Found in sigma: X13
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X13
    [EVAL] Key not found in map
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword3'
    [EVAL] Found in sigma: X14
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[0] result: (= []({}, X13) X14)
    [EVAL] Arg[1]: =([](tmp_Roles_5, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_5
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail3'
    [EVAL] Found in sigma: X13
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X13
    [EVAL] Key not found in map
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X13) BUYER)
    [EVAL] FuncCall result: AND((= []({}, X13) X14), (= []({}, X13) BUYER))
[ASSERT] Result: AND((= []({}, X13) X14), (= []({}, X13) BUYER))
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: buyerEmail4 := input()
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail4'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X16
[ASSIGN] Result: buyerEmail4 := X16

[ASSIGN] Evaluating: buyerPassword4 := input()
[SEE] Mapping base name 'buyerPassword' -> 'buyerPassword4'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X17
[ASSIGN] Result: buyerPassword4 := X17
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_3 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_3'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_3
[ASSIGN] Result: tmp_T_3 := {}

[ASSIGN] Evaluating: T_old := tmp_T_3
  [EVAL] Var lookup: tmp_T_3
    [EVAL] Found in sigma: {}
[ASSIGN] Result: T_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_8 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_8'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_8
[ASSIGN] Result: tmp_U_8 := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_9 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_9'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_9
[ASSIGN] Result: tmp_U_9 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_6 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_6'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_6
[ASSIGN] Result: tmp_Roles_6 := {}
[SEE] Interruption at statement 64

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_U_8)), =([](tmp_U_9, buyerEmail), buyerPassword), =([](tmp_Roles_6, buyerEmail), BUYER))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_U_8))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail4'
    [EVAL] Found in sigma: X16
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_8
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X16
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_U_9, buyerEmail), buyerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_9
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail4'
    [EVAL] Found in sigma: X16
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X16
    [EVAL] Key not found in map
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword4'
    [EVAL] Found in sigma: X17
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X16) X17)
    [EVAL] Arg[2]: =([](tmp_Roles_6, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_6
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail4'
    [EVAL] Found in sigma: X16
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X16
    [EVAL] Key not found in map
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[2] result: (= []({}, X16) BUYER)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'login' with symbolic arguments - interruption point
[SEE] Interruption at statement 65

[ASSIGN] Evaluating: _result4 := login(buyerEmail, buyerPassword)
[SEE] Mapping base name '_result' -> '_result4'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail4'
    [EVAL] Found in sigma: X16
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword4'
    [EVAL] Found in sigma: X17
[API_CALL] login has symbolic arguments - skipping actual execution
  [API_ARG 0] X16 (symbolic: 1)
  [API_ARG 1] X17 (symbolic: 1)
[ASSIGN] Result: _result4 := -1 (symbolic placeholder)
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_4 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_4'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_4
[ASSIGN] Result: tmp_T_4 := {}

[ASSERT] Evaluating: =([](tmp_T_4, buyerEmail), _result4)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_T_4
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail4'
    [EVAL] Found in sigma: X16
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X16
    [EVAL] Key not found in map
  [EVAL] Var lookup: _result4
    [EVAL] Found in sigma: -1
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
[ASSERT] Result: (= []({}, X16) -1)
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: buyerEmail5 := input()
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail5'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X18
[ASSIGN] Result: buyerEmail5 := X18

[ASSIGN] Evaluating: productId5 := input()
[SEE] Mapping base name 'productId' -> 'productId5'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X19
[ASSIGN] Result: productId5 := X19

[ASSIGN] Evaluating: quantity5 := input()
[SEE] Mapping base name 'quantity' -> 'quantity5'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X20
[ASSIGN] Result: quantity5 := X20
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_0 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_0'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_0
[ASSIGN] Result: tmp_C_0 := {}

[ASSIGN] Evaluating: C_old := tmp_C_0
  [EVAL] Var lookup: tmp_C_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: C_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_5 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_5'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_5
[ASSIGN] Result: tmp_T_5 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_7 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_7'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_7
[ASSIGN] Result: tmp_Roles_7 := {}
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_2 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_2'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_P_2
[ASSIGN] Result: tmp_P_2 := {}
[SEE] Interruption at statement 76

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_T_5)), =([](tmp_Roles_7, buyerEmail), BUYER), in(productId, dom(tmp_P_2)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_T_5))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail5'
    [EVAL] Found in sigma: X18
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_5
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X18
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_7, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_7
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail5'
    [EVAL] Found in sigma: X18
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X18
    [EVAL] Key not found in map
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X18) BUYER)
    [EVAL] Arg[2]: in(productId, dom(tmp_P_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: productId
    [EVAL] Resolved base name 'productId' -> 'productId5'
    [EVAL] Found in sigma: X19
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_P_2
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X19
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'addToCart' with symbolic arguments - interruption point
[SEE] Interruption at statement 77

[ASSIGN] Evaluating: _result5 := addToCart(buyerEmail, productId, quantity)
[SEE] Mapping base name '_result' -> '_result5'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail5'
    [EVAL] Found in sigma: X18
  [EVAL] Var lookup: productId
    [EVAL] Resolved base name 'productId' -> 'productId5'
    [EVAL] Found in sigma: X19
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity5'
    [EVAL] Found in sigma: X20
[API_CALL] addToCart has symbolic arguments - skipping actual execution
  [API_ARG 0] X18 (symbolic: 1)
  [API_ARG 1] X19 (symbolic: 1)
  [API_ARG 2] X20 (symbolic: 1)
[ASSIGN] Result: _result5 := -1 (symbolic placeholder)
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_1 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_1'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_1
[ASSIGN] Result: tmp_C_1 := {}

[ASSERT] Evaluating: in(buyerEmail, dom(tmp_C_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail5'
    [EVAL] Found in sigma: X18
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X18
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: buyerEmail6 := input()
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail6'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X21
[ASSIGN] Result: buyerEmail6 := X21

[ASSIGN] Evaluating: productId6 := input()
[SEE] Mapping base name 'productId' -> 'productId6'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X22
[ASSIGN] Result: productId6 := X22

[ASSIGN] Evaluating: orderId6 := input()
[SEE] Mapping base name 'orderId' -> 'orderId6'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X23
[ASSIGN] Result: orderId6 := X23

[ASSIGN] Evaluating: rating6 := input()
[SEE] Mapping base name 'rating' -> 'rating6'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X24
[ASSIGN] Result: rating6 := X24

[ASSIGN] Evaluating: comment6 := input()
[SEE] Mapping base name 'comment' -> 'comment6'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X25
[ASSIGN] Result: comment6 := X25
[SEE] API call 'get_Rev' ready for actual execution

[ASSIGN] Evaluating: tmp_Rev_0 := get_Rev()
[SEE] Mapping base name 'tmp_Rev_' -> 'tmp_Rev_0'
[API_CALL] Executing API function: get_Rev
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Rev
  [API_CALL] Executing function...
[GetRevFunc] Fetching Rev...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Rev_0
[ASSIGN] Result: tmp_Rev_0 := {}

[ASSIGN] Evaluating: Rev_old := tmp_Rev_0
  [EVAL] Var lookup: tmp_Rev_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Rev_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_6 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_6'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_6
[ASSIGN] Result: tmp_T_6 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_8 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_8'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_8
[ASSIGN] Result: tmp_Roles_8 := {}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_0 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_0'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O (Orders)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_0
[ASSIGN] Result: tmp_O_0 := {}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_1 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_1'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O (Orders)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_1
[ASSIGN] Result: tmp_O_1 := {}
[SEE] Interruption at statement 91

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_T_6)), =([](tmp_Roles_8, buyerEmail), BUYER), in(orderId, dom(tmp_O_0)), =([](tmp_O_1, orderId), buyerEmail))
  [EVAL] FuncCall: AND with 4 args
    [EVAL] N-ary AND with 4 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_T_6))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail6'
    [EVAL] Found in sigma: X21
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_6
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X21
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_8, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_8
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail6'
    [EVAL] Found in sigma: X21
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X21
    [EVAL] Key not found in map
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X21) BUYER)
    [EVAL] Arg[2]: in(orderId, dom(tmp_O_0))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId6'
    [EVAL] Found in sigma: X23
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_0
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X23
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] Arg[3]: =([](tmp_O_1, orderId), buyerEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_O_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId6'
    [EVAL] Found in sigma: X23
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X23
    [EVAL] Key not found in map
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail6'
    [EVAL] Found in sigma: X21
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[3] result: (= []({}, X23) X21)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'createReview' with symbolic arguments - interruption point
[SEE] Interruption at statement 92

[ASSIGN] Evaluating: _result6 := createReview(buyerEmail, productId, orderId, rating, comment)
[SEE] Mapping base name '_result' -> '_result6'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail6'
    [EVAL] Found in sigma: X21
  [EVAL] Var lookup: productId
    [EVAL] Resolved base name 'productId' -> 'productId6'
    [EVAL] Found in sigma: X22
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId6'
    [EVAL] Found in sigma: X23
  [EVAL] Var lookup: rating
    [EVAL] Resolved base name 'rating' -> 'rating6'
    [EVAL] Found in sigma: X24
  [EVAL] Var lookup: comment
    [EVAL] Resolved base name 'comment' -> 'comment6'
    [EVAL] Found in sigma: X25
[API_CALL] createReview has symbolic arguments - skipping actual execution
  [API_ARG 0] X21 (symbolic: 1)
  [API_ARG 1] X22 (symbolic: 1)
  [API_ARG 2] X23 (symbolic: 1)
  [API_ARG 3] X24 (symbolic: 1)
  [API_ARG 4] X25 (symbolic: 1)
[ASSIGN] Result: _result6 := -1 (symbolic placeholder)
[SEE] API call 'get_Rev' ready for actual execution

[ASSIGN] Evaluating: tmp_Rev_1 := get_Rev()
[SEE] Mapping base name 'tmp_Rev_' -> 'tmp_Rev_1'
[API_CALL] Executing API function: get_Rev
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Rev
  [API_CALL] Executing function...
[GetRevFunc] Fetching Rev...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Rev_1
[ASSIGN] Result: tmp_Rev_1 := {}

[ASSERT] Evaluating: in(_result6, dom(tmp_Rev_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result6
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_Rev_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[SEE] Path Constraint: And(true, And(true, And(AND((= []({}, X0) X1), (= []({}, X0) SELLER)), And(false, And((= []({}, X5) -1), And(false, And(true, And(AND((= []({}, X13) X14), (= []({}, X13) BUYER)), And(false, And((= []({}, X16) -1), And(false, false)))))))))))

[UNSAT-CHECK] Path constraint contains FALSE - checking dependencies...

[DEPENDENCY-CHECK] Analyzing sequence for true UNSAT...
[DEPENDENCY-CHECK] ✗ Operation 'createReviewOk' requires state 'O' but no prior operation produces it.
[DEPENDENCY-CHECK] Sequence is TRULY UNSAT.

>>> generateCTC: UNSAT DETECTED!
>>> Precondition cannot be satisfied with current database state.
>>> This test sequence requires prerequisite operations.

[RESULT] UNSAT - Test preconditions cannot be satisfied

⊘ [UNSAT] Test 30: Create Review - No Order Placed (Depth=7) UNSAT: Preconditions not satisfiable

