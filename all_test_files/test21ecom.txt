
╔════════════════════════════════════════╗
║  TESTGEN - E-COMMERCE TEST SUITE       ║
║  Total Tests: 30 (21 SAT, 9 UNSAT)     ║
╚════════════════════════════════════════╝


========================================
TEST: [SAT] Test 21: Deep E-Commerce Workflow (Depth=15)
MODE: Full Pipeline (With Backend)
DEPTH: 15 API calls
========================================

[EcommerceFunctionFactory] Initialized with baseUrl: http://localhost:3000
[RewriteGlobalsVisitor] Detected 10 globals: C O OrderStatus P Rev Roles Sellers Stock T U 
[RewriteGlobalsVisitor] Generated 0 statements in rewritten program

=== TEST-API ATC (After Rewrite) ===
=== Program ===
Statement 0: _ := reset()
Statement 1: sellerEmail0 := input()
Statement 2: sellerPassword0 := input()
Statement 3: sellerFullName0 := input()
Statement 4: storeName0 := input()
Statement 5: storeDescription0 := input()
Statement 6: tmp_Roles_0 := get_Roles()
Statement 7: Roles_old := tmp_Roles_0
Statement 8: tmp_U_0 := get_U()
Statement 9: U_old := tmp_U_0
Statement 10: tmp_U_1 := get_U()
Statement 11: assume(not_in(sellerEmail, dom(tmp_U_1)))
Statement 12: _result0 := registerSeller(sellerEmail, sellerPassword, sellerFullName, storeName, storeDescription)
Statement 13: tmp_U_2 := get_U()
Statement 14: tmp_Roles_1 := get_Roles()
Statement 15: assert(AND(=([](tmp_U_2, sellerEmail), sellerPassword), =([](tmp_Roles_1, sellerEmail), SELLER)))
Statement 16: sellerEmail1 := input()
Statement 17: sellerPassword1 := input()
Statement 18: tmp_T_0 := get_T()
Statement 19: T_old := tmp_T_0
Statement 20: tmp_U_3 := get_U()
Statement 21: tmp_U_4 := get_U()
Statement 22: tmp_Roles_2 := get_Roles()
Statement 23: assume(AND(in(sellerEmail, dom(tmp_U_3)), =([](tmp_U_4, sellerEmail), sellerPassword), =([](tmp_Roles_2, sellerEmail), SELLER)))
Statement 24: _result1 := login(sellerEmail, sellerPassword)
Statement 25: tmp_T_1 := get_T()
Statement 26: assert(=([](tmp_T_1, sellerEmail), _result1))
Statement 27: sellerEmail2 := input()
Statement 28: title2 := input()
Statement 29: description2 := input()
Statement 30: category2 := input()
Statement 31: price2 := input()
Statement 32: quantity2 := input()
Statement 33: tmp_P_0 := get_P()
Statement 34: P_old := tmp_P_0
Statement 35: tmp_Sellers_0 := get_Sellers()
Statement 36: Sellers_old := tmp_Sellers_0
Statement 37: tmp_T_2 := get_T()
Statement 38: tmp_Roles_3 := get_Roles()
Statement 39: assume(AND(in(sellerEmail, dom(tmp_T_2)), =([](tmp_Roles_3, sellerEmail), SELLER)))
Statement 40: _result2 := createProduct(sellerEmail, title, description, category, price, quantity)
Statement 41: tmp_P_1 := get_P()
Statement 42: tmp_Sellers_1 := get_Sellers()
Statement 43: assert(AND(in(_result2, dom(tmp_P_1)), =([](tmp_Sellers_1, _result2), sellerEmail)))
Statement 44: sellerEmail3 := input()
Statement 45: title3 := input()
Statement 46: description3 := input()
Statement 47: category3 := input()
Statement 48: price3 := input()
Statement 49: quantity3 := input()
Statement 50: tmp_P_2 := get_P()
Statement 51: P_old := tmp_P_2
Statement 52: tmp_Sellers_2 := get_Sellers()
Statement 53: Sellers_old := tmp_Sellers_2
Statement 54: tmp_T_3 := get_T()
Statement 55: tmp_Roles_4 := get_Roles()
Statement 56: assume(AND(in(sellerEmail, dom(tmp_T_3)), =([](tmp_Roles_4, sellerEmail), SELLER)))
Statement 57: _result3 := createProduct(sellerEmail, title, description, category, price, quantity)
Statement 58: tmp_P_3 := get_P()
Statement 59: tmp_Sellers_3 := get_Sellers()
Statement 60: assert(AND(in(_result3, dom(tmp_P_3)), =([](tmp_Sellers_3, _result3), sellerEmail)))
Statement 61: sellerEmail4 := input()
Statement 62: title4 := input()
Statement 63: description4 := input()
Statement 64: category4 := input()
Statement 65: price4 := input()
Statement 66: quantity4 := input()
Statement 67: tmp_P_4 := get_P()
Statement 68: P_old := tmp_P_4
Statement 69: tmp_Sellers_4 := get_Sellers()
Statement 70: Sellers_old := tmp_Sellers_4
Statement 71: tmp_T_4 := get_T()
Statement 72: tmp_Roles_5 := get_Roles()
Statement 73: assume(AND(in(sellerEmail, dom(tmp_T_4)), =([](tmp_Roles_5, sellerEmail), SELLER)))
Statement 74: _result4 := createProduct(sellerEmail, title, description, category, price, quantity)
Statement 75: tmp_P_5 := get_P()
Statement 76: tmp_Sellers_5 := get_Sellers()
Statement 77: assert(AND(in(_result4, dom(tmp_P_5)), =([](tmp_Sellers_5, _result4), sellerEmail)))
Statement 78: buyerEmail5 := input()
Statement 79: buyerPassword5 := input()
Statement 80: buyerFullName5 := input()
Statement 81: tmp_Roles_6 := get_Roles()
Statement 82: Roles_old := tmp_Roles_6
Statement 83: tmp_U_5 := get_U()
Statement 84: U_old := tmp_U_5
Statement 85: tmp_U_6 := get_U()
Statement 86: assume(not_in(buyerEmail, dom(tmp_U_6)))
Statement 87: _result5 := registerBuyer(buyerEmail, buyerPassword, buyerFullName)
Statement 88: tmp_U_7 := get_U()
Statement 89: tmp_Roles_7 := get_Roles()
Statement 90: assert(AND(=([](tmp_U_7, buyerEmail), buyerPassword), =([](tmp_Roles_7, buyerEmail), BUYER)))
Statement 91: buyerEmail6 := input()
Statement 92: buyerPassword6 := input()
Statement 93: tmp_T_5 := get_T()
Statement 94: T_old := tmp_T_5
Statement 95: tmp_U_8 := get_U()
Statement 96: tmp_U_9 := get_U()
Statement 97: tmp_Roles_8 := get_Roles()
Statement 98: assume(AND(in(buyerEmail, dom(tmp_U_8)), =([](tmp_U_9, buyerEmail), buyerPassword), =([](tmp_Roles_8, buyerEmail), BUYER)))
Statement 99: _result6 := login(buyerEmail, buyerPassword)
Statement 100: tmp_T_6 := get_T()
Statement 101: assert(=([](tmp_T_6, buyerEmail), _result6))
Statement 102: assume(1)
Statement 103: _result7 := getAllProducts()
Statement 104: assert()
Statement 105: buyerEmail8 := input()
Statement 106: productId8 := input()
Statement 107: quantity8 := input()
Statement 108: tmp_C_0 := get_C()
Statement 109: C_old := tmp_C_0
Statement 110: tmp_T_7 := get_T()
Statement 111: tmp_Roles_9 := get_Roles()
Statement 112: tmp_P_6 := get_P()
Statement 113: assume(AND(in(buyerEmail, dom(tmp_T_7)), =([](tmp_Roles_9, buyerEmail), BUYER), in(productId, dom(tmp_P_6))))
Statement 114: _result8 := addToCart(buyerEmail, productId, quantity)
Statement 115: tmp_C_1 := get_C()
Statement 116: assert(in(buyerEmail, dom(tmp_C_1)))
Statement 117: buyerEmail9 := input()
Statement 118: productId9 := input()
Statement 119: quantity9 := input()
Statement 120: tmp_C_2 := get_C()
Statement 121: C_old := tmp_C_2
Statement 122: tmp_T_8 := get_T()
Statement 123: tmp_Roles_10 := get_Roles()
Statement 124: tmp_P_7 := get_P()
Statement 125: assume(AND(in(buyerEmail, dom(tmp_T_8)), =([](tmp_Roles_10, buyerEmail), BUYER), in(productId, dom(tmp_P_7))))
Statement 126: _result9 := addToCart(buyerEmail, productId, quantity)
Statement 127: tmp_C_3 := get_C()
Statement 128: assert(in(buyerEmail, dom(tmp_C_3)))
Statement 129: buyerEmail10 := input()
Statement 130: shippingAddress10 := input()
Statement 131: paymentMethod10 := input()
Statement 132: tmp_C_4 := get_C()
Statement 133: C_old := tmp_C_4
Statement 134: tmp_O_0 := get_O()
Statement 135: O_old := tmp_O_0
Statement 136: tmp_OrderStatus_0 := get_OrderStatus()
Statement 137: OrderStatus_old := tmp_OrderStatus_0
Statement 138: tmp_T_9 := get_T()
Statement 139: tmp_Roles_11 := get_Roles()
Statement 140: tmp_C_5 := get_C()
Statement 141: assume(AND(in(buyerEmail, dom(tmp_T_9)), =([](tmp_Roles_11, buyerEmail), BUYER), in(buyerEmail, dom(tmp_C_5))))
Statement 142: _result10 := createOrder(buyerEmail, shippingAddress, paymentMethod)
Statement 143: tmp_O_1 := get_O()
Statement 144: tmp_OrderStatus_1 := get_OrderStatus()
Statement 145: tmp_C_6 := get_C()
Statement 146: assert(AND(in(_result10, dom(tmp_O_1)), =([](tmp_OrderStatus_1, _result10), PENDING), not_in(buyerEmail, dom(tmp_C_6))))
Statement 147: buyerEmail11 := input()
Statement 148: productId11 := input()
Statement 149: orderId11 := input()
Statement 150: rating11 := input()
Statement 151: comment11 := input()
Statement 152: tmp_Rev_0 := get_Rev()
Statement 153: Rev_old := tmp_Rev_0
Statement 154: tmp_T_10 := get_T()
Statement 155: tmp_Roles_12 := get_Roles()
Statement 156: tmp_O_2 := get_O()
Statement 157: tmp_O_3 := get_O()
Statement 158: assume(AND(in(buyerEmail, dom(tmp_T_10)), =([](tmp_Roles_12, buyerEmail), BUYER), in(orderId, dom(tmp_O_2)), =([](tmp_O_3, orderId), buyerEmail)))
Statement 159: _result11 := createReview(buyerEmail, productId, orderId, rating, comment)
Statement 160: tmp_Rev_1 := get_Rev()
Statement 161: assert(in(_result11, dom(tmp_Rev_1)))
Statement 162: buyerEmail12 := input()
Statement 163: productId12 := input()
Statement 164: quantity12 := input()
Statement 165: tmp_C_7 := get_C()
Statement 166: C_old := tmp_C_7
Statement 167: tmp_T_11 := get_T()
Statement 168: tmp_Roles_13 := get_Roles()
Statement 169: tmp_P_8 := get_P()
Statement 170: assume(AND(in(buyerEmail, dom(tmp_T_11)), =([](tmp_Roles_13, buyerEmail), BUYER), in(productId, dom(tmp_P_8))))
Statement 171: _result12 := addToCart(buyerEmail, productId, quantity)
Statement 172: tmp_C_8 := get_C()
Statement 173: assert(in(buyerEmail, dom(tmp_C_8)))
Statement 174: buyerEmail13 := input()
Statement 175: shippingAddress13 := input()
Statement 176: paymentMethod13 := input()
Statement 177: tmp_C_9 := get_C()
Statement 178: C_old := tmp_C_9
Statement 179: tmp_O_4 := get_O()
Statement 180: O_old := tmp_O_4
Statement 181: tmp_OrderStatus_2 := get_OrderStatus()
Statement 182: OrderStatus_old := tmp_OrderStatus_2
Statement 183: tmp_T_12 := get_T()
Statement 184: tmp_Roles_14 := get_Roles()
Statement 185: tmp_C_10 := get_C()
Statement 186: assume(AND(in(buyerEmail, dom(tmp_T_12)), =([](tmp_Roles_14, buyerEmail), BUYER), in(buyerEmail, dom(tmp_C_10))))
Statement 187: _result13 := createOrder(buyerEmail, shippingAddress, paymentMethod)
Statement 188: tmp_O_5 := get_O()
Statement 189: tmp_OrderStatus_3 := get_OrderStatus()
Statement 190: tmp_C_11 := get_C()
Statement 191: assert(AND(in(_result13, dom(tmp_O_5)), =([](tmp_OrderStatus_3, _result13), PENDING), not_in(buyerEmail, dom(tmp_C_11))))
Statement 192: buyerEmail14 := input()
Statement 193: productId14 := input()
Statement 194: orderId14 := input()
Statement 195: rating14 := input()
Statement 196: comment14 := input()
Statement 197: tmp_Rev_2 := get_Rev()
Statement 198: Rev_old := tmp_Rev_2
Statement 199: tmp_T_13 := get_T()
Statement 200: tmp_Roles_15 := get_Roles()
Statement 201: tmp_O_6 := get_O()
Statement 202: tmp_O_7 := get_O()
Statement 203: assume(AND(in(buyerEmail, dom(tmp_T_13)), =([](tmp_Roles_15, buyerEmail), BUYER), in(orderId, dom(tmp_O_6)), =([](tmp_O_7, orderId), buyerEmail)))
Statement 204: _result14 := createReview(buyerEmail, productId, orderId, rating, comment)
Statement 205: tmp_Rev_3 := get_Rev()
Statement 206: assert(in(_result14, dom(tmp_Rev_3)))
=== End Program ===

========================================
>>> generateCTC: Starting iteration
========================================
>>> generateCTC: Program needs processing
>>> generateCTC: Concrete values provided: 0
>>> generateCTC: Is abstract: 1
>>> generateCTC: Has placeholders: 0

>>> generateCTC: STEP 1 - Rewriting ATC with concrete values

>>> generateCTC: STEP 2 - Running symbolic execution
[SEE] API call 'reset' ready for actual execution

[ASSIGN] Evaluating: _ := reset()
[API_CALL] Executing API function: reset
  [API_CALL] Getting function from factory...
[Factory] Creating function: reset
  [API_CALL] Executing function...
[ResetFunc] Clearing all collections...
[HttpClient] POST /api/test/reset -> 200
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _
[ASSIGN] Result: _ := 200

[ASSIGN] Evaluating: sellerEmail0 := input()
[SEE] Mapping base name 'sellerEmail' -> 'sellerEmail0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X0
[ASSIGN] Result: sellerEmail0 := X0

[ASSIGN] Evaluating: sellerPassword0 := input()
[SEE] Mapping base name 'sellerPassword' -> 'sellerPassword0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X1
[ASSIGN] Result: sellerPassword0 := X1

[ASSIGN] Evaluating: sellerFullName0 := input()
[SEE] Mapping base name 'sellerFullName' -> 'sellerFullName0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X2
[ASSIGN] Result: sellerFullName0 := X2

[ASSIGN] Evaluating: storeName0 := input()
[SEE] Mapping base name 'storeName' -> 'storeName0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X3
[ASSIGN] Result: storeName0 := X3

[ASSIGN] Evaluating: storeDescription0 := input()
[SEE] Mapping base name 'storeDescription' -> 'storeDescription0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X4
[ASSIGN] Result: storeDescription0 := X4
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_0 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_0'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_0
[ASSIGN] Result: tmp_Roles_0 := {}

[ASSIGN] Evaluating: Roles_old := tmp_Roles_0
  [EVAL] Var lookup: tmp_Roles_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Roles_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_0 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_0'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_0
[ASSIGN] Result: tmp_U_0 := {}

[ASSIGN] Evaluating: U_old := tmp_U_0
  [EVAL] Var lookup: tmp_U_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: U_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_1 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_1'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_1
[ASSIGN] Result: tmp_U_1 := {}

[ASSUME] Evaluating: not_in(sellerEmail, dom(tmp_U_1))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail0'
    [EVAL] Found in sigma: X0
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
[ASSUME] Adding constraint: true
[SEE] API call 'registerSeller' with symbolic arguments - interruption point
[SEE] Interruption at statement 12

[ASSIGN] Evaluating: _result0 := registerSeller(sellerEmail, sellerPassword, sellerFullName, storeName, storeDescription)
[SEE] Mapping base name '_result' -> '_result0'
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail0'
    [EVAL] Found in sigma: X0
  [EVAL] Var lookup: sellerPassword
    [EVAL] Resolved base name 'sellerPassword' -> 'sellerPassword0'
    [EVAL] Found in sigma: X1
  [EVAL] Var lookup: sellerFullName
    [EVAL] Resolved base name 'sellerFullName' -> 'sellerFullName0'
    [EVAL] Found in sigma: X2
  [EVAL] Var lookup: storeName
    [EVAL] Resolved base name 'storeName' -> 'storeName0'
    [EVAL] Found in sigma: X3
  [EVAL] Var lookup: storeDescription
    [EVAL] Resolved base name 'storeDescription' -> 'storeDescription0'
    [EVAL] Found in sigma: X4
[API_CALL] registerSeller has symbolic arguments - skipping actual execution
  [API_ARG 0] X0 (symbolic: 1)
  [API_ARG 1] X1 (symbolic: 1)
  [API_ARG 2] X2 (symbolic: 1)
  [API_ARG 3] X3 (symbolic: 1)
  [API_ARG 4] X4 (symbolic: 1)
[ASSIGN] Result: _result0 := -1 (symbolic placeholder)
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_2 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_2'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_2
[ASSIGN] Result: tmp_U_2 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_1 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_1'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_1
[ASSIGN] Result: tmp_Roles_1 := {}
[SEE] Interruption at statement 15

[ASSERT] Evaluating: AND(=([](tmp_U_2, sellerEmail), sellerPassword), =([](tmp_Roles_1, sellerEmail), SELLER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: =([](tmp_U_2, sellerEmail), sellerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_2
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail0'
    [EVAL] Found in sigma: X0
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X0
    [EVAL] Key not found in map
  [EVAL] Var lookup: sellerPassword
    [EVAL] Resolved base name 'sellerPassword' -> 'sellerPassword0'
    [EVAL] Found in sigma: X1
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[0] result: (= []({}, X0) X1)
    [EVAL] Arg[1]: =([](tmp_Roles_1, sellerEmail), SELLER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail0'
    [EVAL] Found in sigma: X0
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X0
    [EVAL] Key not found in map
  [EVAL] Var lookup: SELLER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X0) SELLER)
    [EVAL] FuncCall result: AND((= []({}, X0) X1), (= []({}, X0) SELLER))
[ASSERT] Result: AND((= []({}, X0) X1), (= []({}, X0) SELLER))
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: sellerEmail1 := input()
[SEE] Mapping base name 'sellerEmail' -> 'sellerEmail1'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X5
[ASSIGN] Result: sellerEmail1 := X5

[ASSIGN] Evaluating: sellerPassword1 := input()
[SEE] Mapping base name 'sellerPassword' -> 'sellerPassword1'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X6
[ASSIGN] Result: sellerPassword1 := X6
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_0 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_0'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_0
[ASSIGN] Result: tmp_T_0 := {}

[ASSIGN] Evaluating: T_old := tmp_T_0
  [EVAL] Var lookup: tmp_T_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: T_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_3 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_3'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_3
[ASSIGN] Result: tmp_U_3 := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_4 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_4'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_4
[ASSIGN] Result: tmp_U_4 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_2 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_2'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_2
[ASSIGN] Result: tmp_Roles_2 := {}
[SEE] Interruption at statement 23

[ASSUME] Evaluating: AND(in(sellerEmail, dom(tmp_U_3)), =([](tmp_U_4, sellerEmail), sellerPassword), =([](tmp_Roles_2, sellerEmail), SELLER))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(sellerEmail, dom(tmp_U_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail1'
    [EVAL] Found in sigma: X5
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X5
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_U_4, sellerEmail), sellerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_4
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail1'
    [EVAL] Found in sigma: X5
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X5
    [EVAL] Key not found in map
  [EVAL] Var lookup: sellerPassword
    [EVAL] Resolved base name 'sellerPassword' -> 'sellerPassword1'
    [EVAL] Found in sigma: X6
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X5) X6)
    [EVAL] Arg[2]: =([](tmp_Roles_2, sellerEmail), SELLER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_2
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail1'
    [EVAL] Found in sigma: X5
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X5
    [EVAL] Key not found in map
  [EVAL] Var lookup: SELLER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[2] result: (= []({}, X5) SELLER)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'login' with symbolic arguments - interruption point
[SEE] Interruption at statement 24

[ASSIGN] Evaluating: _result1 := login(sellerEmail, sellerPassword)
[SEE] Mapping base name '_result' -> '_result1'
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail1'
    [EVAL] Found in sigma: X5
  [EVAL] Var lookup: sellerPassword
    [EVAL] Resolved base name 'sellerPassword' -> 'sellerPassword1'
    [EVAL] Found in sigma: X6
[API_CALL] login has symbolic arguments - skipping actual execution
  [API_ARG 0] X5 (symbolic: 1)
  [API_ARG 1] X6 (symbolic: 1)
[ASSIGN] Result: _result1 := -1 (symbolic placeholder)
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_1 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_1'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_1
[ASSIGN] Result: tmp_T_1 := {}

[ASSERT] Evaluating: =([](tmp_T_1, sellerEmail), _result1)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_T_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail1'
    [EVAL] Found in sigma: X5
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X5
    [EVAL] Key not found in map
  [EVAL] Var lookup: _result1
    [EVAL] Found in sigma: -1
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
[ASSERT] Result: (= []({}, X5) -1)
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: sellerEmail2 := input()
[SEE] Mapping base name 'sellerEmail' -> 'sellerEmail2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X7
[ASSIGN] Result: sellerEmail2 := X7

[ASSIGN] Evaluating: title2 := input()
[SEE] Mapping base name 'title' -> 'title2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X8
[ASSIGN] Result: title2 := X8

[ASSIGN] Evaluating: description2 := input()
[SEE] Mapping base name 'description' -> 'description2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X9
[ASSIGN] Result: description2 := X9

[ASSIGN] Evaluating: category2 := input()
[SEE] Mapping base name 'category' -> 'category2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X10
[ASSIGN] Result: category2 := X10

[ASSIGN] Evaluating: price2 := input()
[SEE] Mapping base name 'price' -> 'price2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X11
[ASSIGN] Result: price2 := X11

[ASSIGN] Evaluating: quantity2 := input()
[SEE] Mapping base name 'quantity' -> 'quantity2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X12
[ASSIGN] Result: quantity2 := X12
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_0 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_0'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_P_0
[ASSIGN] Result: tmp_P_0 := {}

[ASSIGN] Evaluating: P_old := tmp_P_0
  [EVAL] Var lookup: tmp_P_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: P_old := {}
[SEE] API call 'get_Sellers' ready for actual execution

[ASSIGN] Evaluating: tmp_Sellers_0 := get_Sellers()
[SEE] Mapping base name 'tmp_Sellers_' -> 'tmp_Sellers_0'
[API_CALL] Executing API function: get_Sellers
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Sellers
  [API_CALL] Executing function...
[GetSellersFunc] Fetching Sellers...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Sellers_0
[ASSIGN] Result: tmp_Sellers_0 := {}

[ASSIGN] Evaluating: Sellers_old := tmp_Sellers_0
  [EVAL] Var lookup: tmp_Sellers_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Sellers_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_2 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_2'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_2
[ASSIGN] Result: tmp_T_2 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_3 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_3'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_3
[ASSIGN] Result: tmp_Roles_3 := {}
[SEE] Interruption at statement 39

[ASSUME] Evaluating: AND(in(sellerEmail, dom(tmp_T_2)), =([](tmp_Roles_3, sellerEmail), SELLER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(sellerEmail, dom(tmp_T_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: X7
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_2
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X7
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_3, sellerEmail), SELLER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_3
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: X7
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X7
    [EVAL] Key not found in map
  [EVAL] Var lookup: SELLER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X7) SELLER)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'createProduct' with symbolic arguments - interruption point
[SEE] Interruption at statement 40

[ASSIGN] Evaluating: _result2 := createProduct(sellerEmail, title, description, category, price, quantity)
[SEE] Mapping base name '_result' -> '_result2'
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: X7
  [EVAL] Var lookup: title
    [EVAL] Resolved base name 'title' -> 'title2'
    [EVAL] Found in sigma: X8
  [EVAL] Var lookup: description
    [EVAL] Resolved base name 'description' -> 'description2'
    [EVAL] Found in sigma: X9
  [EVAL] Var lookup: category
    [EVAL] Resolved base name 'category' -> 'category2'
    [EVAL] Found in sigma: X10
  [EVAL] Var lookup: price
    [EVAL] Resolved base name 'price' -> 'price2'
    [EVAL] Found in sigma: X11
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity2'
    [EVAL] Found in sigma: X12
[API_CALL] createProduct has symbolic arguments - skipping actual execution
  [API_ARG 0] X7 (symbolic: 1)
  [API_ARG 1] X8 (symbolic: 1)
  [API_ARG 2] X9 (symbolic: 1)
  [API_ARG 3] X10 (symbolic: 1)
  [API_ARG 4] X11 (symbolic: 1)
  [API_ARG 5] X12 (symbolic: 1)
[ASSIGN] Result: _result2 := -1 (symbolic placeholder)
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_1 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_1'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_P_1
[ASSIGN] Result: tmp_P_1 := {}
[SEE] API call 'get_Sellers' ready for actual execution

[ASSIGN] Evaluating: tmp_Sellers_1 := get_Sellers()
[SEE] Mapping base name 'tmp_Sellers_' -> 'tmp_Sellers_1'
[API_CALL] Executing API function: get_Sellers
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Sellers
  [API_CALL] Executing function...
[GetSellersFunc] Fetching Sellers...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Sellers_1
[ASSIGN] Result: tmp_Sellers_1 := {}
[SEE] Interruption at statement 43

[ASSERT] Evaluating: AND(in(_result2, dom(tmp_P_1)), =([](tmp_Sellers_1, _result2), sellerEmail))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(_result2, dom(tmp_P_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result2
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_P_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Sellers_1, _result2), sellerEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Sellers_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: _result2
    [EVAL] Found in sigma: -1
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: -1
    [EVAL] Key not found in map
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: X7
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, -1) X7)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: sellerEmail3 := input()
[SEE] Mapping base name 'sellerEmail' -> 'sellerEmail3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X13
[ASSIGN] Result: sellerEmail3 := X13

[ASSIGN] Evaluating: title3 := input()
[SEE] Mapping base name 'title' -> 'title3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X14
[ASSIGN] Result: title3 := X14

[ASSIGN] Evaluating: description3 := input()
[SEE] Mapping base name 'description' -> 'description3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X15
[ASSIGN] Result: description3 := X15

[ASSIGN] Evaluating: category3 := input()
[SEE] Mapping base name 'category' -> 'category3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X16
[ASSIGN] Result: category3 := X16

[ASSIGN] Evaluating: price3 := input()
[SEE] Mapping base name 'price' -> 'price3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X17
[ASSIGN] Result: price3 := X17

[ASSIGN] Evaluating: quantity3 := input()
[SEE] Mapping base name 'quantity' -> 'quantity3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X18
[ASSIGN] Result: quantity3 := X18
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_2 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_2'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_P_2
[ASSIGN] Result: tmp_P_2 := {}

[ASSIGN] Evaluating: P_old := tmp_P_2
  [EVAL] Var lookup: tmp_P_2
    [EVAL] Found in sigma: {}
[ASSIGN] Result: P_old := {}
[SEE] API call 'get_Sellers' ready for actual execution

[ASSIGN] Evaluating: tmp_Sellers_2 := get_Sellers()
[SEE] Mapping base name 'tmp_Sellers_' -> 'tmp_Sellers_2'
[API_CALL] Executing API function: get_Sellers
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Sellers
  [API_CALL] Executing function...
[GetSellersFunc] Fetching Sellers...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Sellers_2
[ASSIGN] Result: tmp_Sellers_2 := {}

[ASSIGN] Evaluating: Sellers_old := tmp_Sellers_2
  [EVAL] Var lookup: tmp_Sellers_2
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Sellers_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_3 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_3'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_3
[ASSIGN] Result: tmp_T_3 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_4 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_4'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_4
[ASSIGN] Result: tmp_Roles_4 := {}
[SEE] Interruption at statement 56

[ASSUME] Evaluating: AND(in(sellerEmail, dom(tmp_T_3)), =([](tmp_Roles_4, sellerEmail), SELLER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(sellerEmail, dom(tmp_T_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail3'
    [EVAL] Found in sigma: X13
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X13
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_4, sellerEmail), SELLER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_4
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail3'
    [EVAL] Found in sigma: X13
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X13
    [EVAL] Key not found in map
  [EVAL] Var lookup: SELLER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X13) SELLER)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'createProduct' with symbolic arguments - interruption point
[SEE] Interruption at statement 57

[ASSIGN] Evaluating: _result3 := createProduct(sellerEmail, title, description, category, price, quantity)
[SEE] Mapping base name '_result' -> '_result3'
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail3'
    [EVAL] Found in sigma: X13
  [EVAL] Var lookup: title
    [EVAL] Resolved base name 'title' -> 'title3'
    [EVAL] Found in sigma: X14
  [EVAL] Var lookup: description
    [EVAL] Resolved base name 'description' -> 'description3'
    [EVAL] Found in sigma: X15
  [EVAL] Var lookup: category
    [EVAL] Resolved base name 'category' -> 'category3'
    [EVAL] Found in sigma: X16
  [EVAL] Var lookup: price
    [EVAL] Resolved base name 'price' -> 'price3'
    [EVAL] Found in sigma: X17
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity3'
    [EVAL] Found in sigma: X18
[API_CALL] createProduct has symbolic arguments - skipping actual execution
  [API_ARG 0] X13 (symbolic: 1)
  [API_ARG 1] X14 (symbolic: 1)
  [API_ARG 2] X15 (symbolic: 1)
  [API_ARG 3] X16 (symbolic: 1)
  [API_ARG 4] X17 (symbolic: 1)
  [API_ARG 5] X18 (symbolic: 1)
[ASSIGN] Result: _result3 := -1 (symbolic placeholder)
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_3 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_3'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_P_3
[ASSIGN] Result: tmp_P_3 := {}
[SEE] API call 'get_Sellers' ready for actual execution

[ASSIGN] Evaluating: tmp_Sellers_3 := get_Sellers()
[SEE] Mapping base name 'tmp_Sellers_' -> 'tmp_Sellers_3'
[API_CALL] Executing API function: get_Sellers
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Sellers
  [API_CALL] Executing function...
[GetSellersFunc] Fetching Sellers...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Sellers_3
[ASSIGN] Result: tmp_Sellers_3 := {}
[SEE] Interruption at statement 60

[ASSERT] Evaluating: AND(in(_result3, dom(tmp_P_3)), =([](tmp_Sellers_3, _result3), sellerEmail))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(_result3, dom(tmp_P_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result3
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_P_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Sellers_3, _result3), sellerEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Sellers_3
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: _result3
    [EVAL] Found in sigma: -1
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: -1
    [EVAL] Key not found in map
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail3'
    [EVAL] Found in sigma: X13
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, -1) X13)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: sellerEmail4 := input()
[SEE] Mapping base name 'sellerEmail' -> 'sellerEmail4'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X19
[ASSIGN] Result: sellerEmail4 := X19

[ASSIGN] Evaluating: title4 := input()
[SEE] Mapping base name 'title' -> 'title4'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X20
[ASSIGN] Result: title4 := X20

[ASSIGN] Evaluating: description4 := input()
[SEE] Mapping base name 'description' -> 'description4'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X21
[ASSIGN] Result: description4 := X21

[ASSIGN] Evaluating: category4 := input()
[SEE] Mapping base name 'category' -> 'category4'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X22
[ASSIGN] Result: category4 := X22

[ASSIGN] Evaluating: price4 := input()
[SEE] Mapping base name 'price' -> 'price4'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X23
[ASSIGN] Result: price4 := X23

[ASSIGN] Evaluating: quantity4 := input()
[SEE] Mapping base name 'quantity' -> 'quantity4'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X24
[ASSIGN] Result: quantity4 := X24
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_4 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_4'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_P_4
[ASSIGN] Result: tmp_P_4 := {}

[ASSIGN] Evaluating: P_old := tmp_P_4
  [EVAL] Var lookup: tmp_P_4
    [EVAL] Found in sigma: {}
[ASSIGN] Result: P_old := {}
[SEE] API call 'get_Sellers' ready for actual execution

[ASSIGN] Evaluating: tmp_Sellers_4 := get_Sellers()
[SEE] Mapping base name 'tmp_Sellers_' -> 'tmp_Sellers_4'
[API_CALL] Executing API function: get_Sellers
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Sellers
  [API_CALL] Executing function...
[GetSellersFunc] Fetching Sellers...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Sellers_4
[ASSIGN] Result: tmp_Sellers_4 := {}

[ASSIGN] Evaluating: Sellers_old := tmp_Sellers_4
  [EVAL] Var lookup: tmp_Sellers_4
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Sellers_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_4 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_4'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_4
[ASSIGN] Result: tmp_T_4 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_5 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_5'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_5
[ASSIGN] Result: tmp_Roles_5 := {}
[SEE] Interruption at statement 73

[ASSUME] Evaluating: AND(in(sellerEmail, dom(tmp_T_4)), =([](tmp_Roles_5, sellerEmail), SELLER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(sellerEmail, dom(tmp_T_4))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail4'
    [EVAL] Found in sigma: X19
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_4
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X19
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_5, sellerEmail), SELLER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_5
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail4'
    [EVAL] Found in sigma: X19
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X19
    [EVAL] Key not found in map
  [EVAL] Var lookup: SELLER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X19) SELLER)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'createProduct' with symbolic arguments - interruption point
[SEE] Interruption at statement 74

[ASSIGN] Evaluating: _result4 := createProduct(sellerEmail, title, description, category, price, quantity)
[SEE] Mapping base name '_result' -> '_result4'
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail4'
    [EVAL] Found in sigma: X19
  [EVAL] Var lookup: title
    [EVAL] Resolved base name 'title' -> 'title4'
    [EVAL] Found in sigma: X20
  [EVAL] Var lookup: description
    [EVAL] Resolved base name 'description' -> 'description4'
    [EVAL] Found in sigma: X21
  [EVAL] Var lookup: category
    [EVAL] Resolved base name 'category' -> 'category4'
    [EVAL] Found in sigma: X22
  [EVAL] Var lookup: price
    [EVAL] Resolved base name 'price' -> 'price4'
    [EVAL] Found in sigma: X23
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity4'
    [EVAL] Found in sigma: X24
[API_CALL] createProduct has symbolic arguments - skipping actual execution
  [API_ARG 0] X19 (symbolic: 1)
  [API_ARG 1] X20 (symbolic: 1)
  [API_ARG 2] X21 (symbolic: 1)
  [API_ARG 3] X22 (symbolic: 1)
  [API_ARG 4] X23 (symbolic: 1)
  [API_ARG 5] X24 (symbolic: 1)
[ASSIGN] Result: _result4 := -1 (symbolic placeholder)
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_5 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_5'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_P_5
[ASSIGN] Result: tmp_P_5 := {}
[SEE] API call 'get_Sellers' ready for actual execution

[ASSIGN] Evaluating: tmp_Sellers_5 := get_Sellers()
[SEE] Mapping base name 'tmp_Sellers_' -> 'tmp_Sellers_5'
[API_CALL] Executing API function: get_Sellers
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Sellers
  [API_CALL] Executing function...
[GetSellersFunc] Fetching Sellers...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Sellers_5
[ASSIGN] Result: tmp_Sellers_5 := {}
[SEE] Interruption at statement 77

[ASSERT] Evaluating: AND(in(_result4, dom(tmp_P_5)), =([](tmp_Sellers_5, _result4), sellerEmail))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(_result4, dom(tmp_P_5))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result4
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_P_5
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Sellers_5, _result4), sellerEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Sellers_5
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: _result4
    [EVAL] Found in sigma: -1
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: -1
    [EVAL] Key not found in map
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail4'
    [EVAL] Found in sigma: X19
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, -1) X19)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: buyerEmail5 := input()
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail5'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X25
[ASSIGN] Result: buyerEmail5 := X25

[ASSIGN] Evaluating: buyerPassword5 := input()
[SEE] Mapping base name 'buyerPassword' -> 'buyerPassword5'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X26
[ASSIGN] Result: buyerPassword5 := X26

[ASSIGN] Evaluating: buyerFullName5 := input()
[SEE] Mapping base name 'buyerFullName' -> 'buyerFullName5'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X27
[ASSIGN] Result: buyerFullName5 := X27
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_6 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_6'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_6
[ASSIGN] Result: tmp_Roles_6 := {}

[ASSIGN] Evaluating: Roles_old := tmp_Roles_6
  [EVAL] Var lookup: tmp_Roles_6
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Roles_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_5 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_5'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_5
[ASSIGN] Result: tmp_U_5 := {}

[ASSIGN] Evaluating: U_old := tmp_U_5
  [EVAL] Var lookup: tmp_U_5
    [EVAL] Found in sigma: {}
[ASSIGN] Result: U_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_6 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_6'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_6
[ASSIGN] Result: tmp_U_6 := {}

[ASSUME] Evaluating: not_in(buyerEmail, dom(tmp_U_6))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail5'
    [EVAL] Found in sigma: X25
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_6
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
[ASSUME] Adding constraint: true
[SEE] API call 'registerBuyer' with symbolic arguments - interruption point
[SEE] Interruption at statement 87

[ASSIGN] Evaluating: _result5 := registerBuyer(buyerEmail, buyerPassword, buyerFullName)
[SEE] Mapping base name '_result' -> '_result5'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail5'
    [EVAL] Found in sigma: X25
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword5'
    [EVAL] Found in sigma: X26
  [EVAL] Var lookup: buyerFullName
    [EVAL] Resolved base name 'buyerFullName' -> 'buyerFullName5'
    [EVAL] Found in sigma: X27
[API_CALL] registerBuyer has symbolic arguments - skipping actual execution
  [API_ARG 0] X25 (symbolic: 1)
  [API_ARG 1] X26 (symbolic: 1)
  [API_ARG 2] X27 (symbolic: 1)
[ASSIGN] Result: _result5 := -1 (symbolic placeholder)
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_7 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_7'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_7
[ASSIGN] Result: tmp_U_7 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_7 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_7'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_7
[ASSIGN] Result: tmp_Roles_7 := {}
[SEE] Interruption at statement 90

[ASSERT] Evaluating: AND(=([](tmp_U_7, buyerEmail), buyerPassword), =([](tmp_Roles_7, buyerEmail), BUYER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: =([](tmp_U_7, buyerEmail), buyerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_7
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail5'
    [EVAL] Found in sigma: X25
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X25
    [EVAL] Key not found in map
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword5'
    [EVAL] Found in sigma: X26
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[0] result: (= []({}, X25) X26)
    [EVAL] Arg[1]: =([](tmp_Roles_7, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_7
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail5'
    [EVAL] Found in sigma: X25
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X25
    [EVAL] Key not found in map
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X25) BUYER)
    [EVAL] FuncCall result: AND((= []({}, X25) X26), (= []({}, X25) BUYER))
[ASSERT] Result: AND((= []({}, X25) X26), (= []({}, X25) BUYER))
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: buyerEmail6 := input()
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail6'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X28
[ASSIGN] Result: buyerEmail6 := X28

[ASSIGN] Evaluating: buyerPassword6 := input()
[SEE] Mapping base name 'buyerPassword' -> 'buyerPassword6'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X29
[ASSIGN] Result: buyerPassword6 := X29
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_5 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_5'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_5
[ASSIGN] Result: tmp_T_5 := {}

[ASSIGN] Evaluating: T_old := tmp_T_5
  [EVAL] Var lookup: tmp_T_5
    [EVAL] Found in sigma: {}
[ASSIGN] Result: T_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_8 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_8'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_8
[ASSIGN] Result: tmp_U_8 := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_9 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_9'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_9
[ASSIGN] Result: tmp_U_9 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_8 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_8'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_8
[ASSIGN] Result: tmp_Roles_8 := {}
[SEE] Interruption at statement 98

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_U_8)), =([](tmp_U_9, buyerEmail), buyerPassword), =([](tmp_Roles_8, buyerEmail), BUYER))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_U_8))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail6'
    [EVAL] Found in sigma: X28
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_8
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X28
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_U_9, buyerEmail), buyerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_9
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail6'
    [EVAL] Found in sigma: X28
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X28
    [EVAL] Key not found in map
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword6'
    [EVAL] Found in sigma: X29
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X28) X29)
    [EVAL] Arg[2]: =([](tmp_Roles_8, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_8
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail6'
    [EVAL] Found in sigma: X28
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X28
    [EVAL] Key not found in map
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[2] result: (= []({}, X28) BUYER)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'login' with symbolic arguments - interruption point
[SEE] Interruption at statement 99

[ASSIGN] Evaluating: _result6 := login(buyerEmail, buyerPassword)
[SEE] Mapping base name '_result' -> '_result6'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail6'
    [EVAL] Found in sigma: X28
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword6'
    [EVAL] Found in sigma: X29
[API_CALL] login has symbolic arguments - skipping actual execution
  [API_ARG 0] X28 (symbolic: 1)
  [API_ARG 1] X29 (symbolic: 1)
[ASSIGN] Result: _result6 := -1 (symbolic placeholder)
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_6 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_6'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_6
[ASSIGN] Result: tmp_T_6 := {}

[ASSERT] Evaluating: =([](tmp_T_6, buyerEmail), _result6)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_T_6
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail6'
    [EVAL] Found in sigma: X28
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X28
    [EVAL] Key not found in map
  [EVAL] Var lookup: _result6
    [EVAL] Found in sigma: -1
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
[ASSERT] Result: (= []({}, X28) -1)
[ASSERT] Adding to path constraints (not fully concrete)

[ASSUME] Evaluating: 1
  [EVAL] Num: 1
[ASSUME] Adding constraint: 1
[SEE] API call 'getAllProducts' ready for actual execution

[ASSIGN] Evaluating: _result7 := getAllProducts()
[SEE] Mapping base name '_result' -> '_result7'
[API_CALL] Executing API function: getAllProducts
  [API_CALL] Getting function from factory...
[Factory] Creating function: getAllProducts
  [API_CALL] Executing function...
[GetAllProductsFunc] Fetching all products...
[GetAllProductsFunc] Found 0 products
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _result7
[ASSIGN] Result: _result7 := 200

[ASSERT] Empty assertion, PASSED

[ASSIGN] Evaluating: buyerEmail8 := input()
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail8'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X30
[ASSIGN] Result: buyerEmail8 := X30

[ASSIGN] Evaluating: productId8 := input()
[SEE] Mapping base name 'productId' -> 'productId8'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X31
[ASSIGN] Result: productId8 := X31

[ASSIGN] Evaluating: quantity8 := input()
[SEE] Mapping base name 'quantity' -> 'quantity8'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X32
[ASSIGN] Result: quantity8 := X32
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_0 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_0'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_0
[ASSIGN] Result: tmp_C_0 := {}

[ASSIGN] Evaluating: C_old := tmp_C_0
  [EVAL] Var lookup: tmp_C_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: C_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_7 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_7'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_7
[ASSIGN] Result: tmp_T_7 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_9 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_9'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_9
[ASSIGN] Result: tmp_Roles_9 := {}
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_6 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_6'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_P_6
[ASSIGN] Result: tmp_P_6 := {}
[SEE] Interruption at statement 113

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_T_7)), =([](tmp_Roles_9, buyerEmail), BUYER), in(productId, dom(tmp_P_6)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_T_7))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail8'
    [EVAL] Found in sigma: X30
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_7
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X30
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_9, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_9
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail8'
    [EVAL] Found in sigma: X30
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X30
    [EVAL] Key not found in map
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X30) BUYER)
    [EVAL] Arg[2]: in(productId, dom(tmp_P_6))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: productId
    [EVAL] Resolved base name 'productId' -> 'productId8'
    [EVAL] Found in sigma: X31
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_P_6
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X31
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'addToCart' with symbolic arguments - interruption point
[SEE] Interruption at statement 114

[ASSIGN] Evaluating: _result8 := addToCart(buyerEmail, productId, quantity)
[SEE] Mapping base name '_result' -> '_result8'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail8'
    [EVAL] Found in sigma: X30
  [EVAL] Var lookup: productId
    [EVAL] Resolved base name 'productId' -> 'productId8'
    [EVAL] Found in sigma: X31
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity8'
    [EVAL] Found in sigma: X32
[API_CALL] addToCart has symbolic arguments - skipping actual execution
  [API_ARG 0] X30 (symbolic: 1)
  [API_ARG 1] X31 (symbolic: 1)
  [API_ARG 2] X32 (symbolic: 1)
[ASSIGN] Result: _result8 := -1 (symbolic placeholder)
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_1 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_1'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_1
[ASSIGN] Result: tmp_C_1 := {}

[ASSERT] Evaluating: in(buyerEmail, dom(tmp_C_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail8'
    [EVAL] Found in sigma: X30
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X30
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: buyerEmail9 := input()
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail9'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X33
[ASSIGN] Result: buyerEmail9 := X33

[ASSIGN] Evaluating: productId9 := input()
[SEE] Mapping base name 'productId' -> 'productId9'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X34
[ASSIGN] Result: productId9 := X34

[ASSIGN] Evaluating: quantity9 := input()
[SEE] Mapping base name 'quantity' -> 'quantity9'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X35
[ASSIGN] Result: quantity9 := X35
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_2 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_2'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_2
[ASSIGN] Result: tmp_C_2 := {}

[ASSIGN] Evaluating: C_old := tmp_C_2
  [EVAL] Var lookup: tmp_C_2
    [EVAL] Found in sigma: {}
[ASSIGN] Result: C_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_8 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_8'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_8
[ASSIGN] Result: tmp_T_8 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_10 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_10'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_10
[ASSIGN] Result: tmp_Roles_10 := {}
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_7 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_7'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_P_7
[ASSIGN] Result: tmp_P_7 := {}
[SEE] Interruption at statement 125

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_T_8)), =([](tmp_Roles_10, buyerEmail), BUYER), in(productId, dom(tmp_P_7)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_T_8))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail9'
    [EVAL] Found in sigma: X33
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_8
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X33
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_10, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_10
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail9'
    [EVAL] Found in sigma: X33
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X33
    [EVAL] Key not found in map
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X33) BUYER)
    [EVAL] Arg[2]: in(productId, dom(tmp_P_7))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: productId
    [EVAL] Resolved base name 'productId' -> 'productId9'
    [EVAL] Found in sigma: X34
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_P_7
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X34
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'addToCart' with symbolic arguments - interruption point
[SEE] Interruption at statement 126

[ASSIGN] Evaluating: _result9 := addToCart(buyerEmail, productId, quantity)
[SEE] Mapping base name '_result' -> '_result9'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail9'
    [EVAL] Found in sigma: X33
  [EVAL] Var lookup: productId
    [EVAL] Resolved base name 'productId' -> 'productId9'
    [EVAL] Found in sigma: X34
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity9'
    [EVAL] Found in sigma: X35
[API_CALL] addToCart has symbolic arguments - skipping actual execution
  [API_ARG 0] X33 (symbolic: 1)
  [API_ARG 1] X34 (symbolic: 1)
  [API_ARG 2] X35 (symbolic: 1)
[ASSIGN] Result: _result9 := -1 (symbolic placeholder)
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_3 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_3'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_3
[ASSIGN] Result: tmp_C_3 := {}

[ASSERT] Evaluating: in(buyerEmail, dom(tmp_C_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail9'
    [EVAL] Found in sigma: X33
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X33
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: buyerEmail10 := input()
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail10'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X36
[ASSIGN] Result: buyerEmail10 := X36

[ASSIGN] Evaluating: shippingAddress10 := input()
[SEE] Mapping base name 'shippingAddress' -> 'shippingAddress10'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X37
[ASSIGN] Result: shippingAddress10 := X37

[ASSIGN] Evaluating: paymentMethod10 := input()
[SEE] Mapping base name 'paymentMethod' -> 'paymentMethod10'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X38
[ASSIGN] Result: paymentMethod10 := X38
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_4 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_4'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_4
[ASSIGN] Result: tmp_C_4 := {}

[ASSIGN] Evaluating: C_old := tmp_C_4
  [EVAL] Var lookup: tmp_C_4
    [EVAL] Found in sigma: {}
[ASSIGN] Result: C_old := {}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_0 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_0'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O (Orders)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_0
[ASSIGN] Result: tmp_O_0 := {}

[ASSIGN] Evaluating: O_old := tmp_O_0
  [EVAL] Var lookup: tmp_O_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: O_old := {}
[SEE] API call 'get_OrderStatus' ready for actual execution

[ASSIGN] Evaluating: tmp_OrderStatus_0 := get_OrderStatus()
[SEE] Mapping base name 'tmp_OrderStatus_' -> 'tmp_OrderStatus_0'
[API_CALL] Executing API function: get_OrderStatus
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_OrderStatus
  [API_CALL] Executing function...
[GetOrderStatusFunc] Fetching OrderStatus...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_OrderStatus_0
[ASSIGN] Result: tmp_OrderStatus_0 := {}

[ASSIGN] Evaluating: OrderStatus_old := tmp_OrderStatus_0
  [EVAL] Var lookup: tmp_OrderStatus_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: OrderStatus_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_9 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_9'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_9
[ASSIGN] Result: tmp_T_9 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_11 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_11'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_11
[ASSIGN] Result: tmp_Roles_11 := {}
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_5 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_5'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_5
[ASSIGN] Result: tmp_C_5 := {}
[SEE] Interruption at statement 141

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_T_9)), =([](tmp_Roles_11, buyerEmail), BUYER), in(buyerEmail, dom(tmp_C_5)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_T_9))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail10'
    [EVAL] Found in sigma: X36
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_9
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X36
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_11, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_11
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail10'
    [EVAL] Found in sigma: X36
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X36
    [EVAL] Key not found in map
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X36) BUYER)
    [EVAL] Arg[2]: in(buyerEmail, dom(tmp_C_5))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail10'
    [EVAL] Found in sigma: X36
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_5
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X36
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'createOrder' with symbolic arguments - interruption point
[SEE] Interruption at statement 142

[ASSIGN] Evaluating: _result10 := createOrder(buyerEmail, shippingAddress, paymentMethod)
[SEE] Mapping base name '_result' -> '_result10'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail10'
    [EVAL] Found in sigma: X36
  [EVAL] Var lookup: shippingAddress
    [EVAL] Resolved base name 'shippingAddress' -> 'shippingAddress10'
    [EVAL] Found in sigma: X37
  [EVAL] Var lookup: paymentMethod
    [EVAL] Resolved base name 'paymentMethod' -> 'paymentMethod10'
    [EVAL] Found in sigma: X38
[API_CALL] createOrder has symbolic arguments - skipping actual execution
  [API_ARG 0] X36 (symbolic: 1)
  [API_ARG 1] X37 (symbolic: 1)
  [API_ARG 2] X38 (symbolic: 1)
[ASSIGN] Result: _result10 := -1 (symbolic placeholder)
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_1 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_1'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O (Orders)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_1
[ASSIGN] Result: tmp_O_1 := {}
[SEE] API call 'get_OrderStatus' ready for actual execution

[ASSIGN] Evaluating: tmp_OrderStatus_1 := get_OrderStatus()
[SEE] Mapping base name 'tmp_OrderStatus_' -> 'tmp_OrderStatus_1'
[API_CALL] Executing API function: get_OrderStatus
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_OrderStatus
  [API_CALL] Executing function...
[GetOrderStatusFunc] Fetching OrderStatus...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_OrderStatus_1
[ASSIGN] Result: tmp_OrderStatus_1 := {}
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_6 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_6'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_6
[ASSIGN] Result: tmp_C_6 := {}
[SEE] Interruption at statement 146

[ASSERT] Evaluating: AND(in(_result10, dom(tmp_O_1)), =([](tmp_OrderStatus_1, _result10), PENDING), not_in(buyerEmail, dom(tmp_C_6)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(_result10, dom(tmp_O_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result10
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_OrderStatus_1, _result10), PENDING)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_OrderStatus_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: _result10
    [EVAL] Found in sigma: -1
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: -1
    [EVAL] Key not found in map
  [EVAL] Var lookup: PENDING
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, -1) PENDING)
    [EVAL] Arg[2]: not_in(buyerEmail, dom(tmp_C_6))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail10'
    [EVAL] Found in sigma: X36
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_6
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
    [EVAL] Arg[2] result: true
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: buyerEmail11 := input()
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail11'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X39
[ASSIGN] Result: buyerEmail11 := X39

[ASSIGN] Evaluating: productId11 := input()
[SEE] Mapping base name 'productId' -> 'productId11'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X40
[ASSIGN] Result: productId11 := X40

[ASSIGN] Evaluating: orderId11 := input()
[SEE] Mapping base name 'orderId' -> 'orderId11'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X41
[ASSIGN] Result: orderId11 := X41

[ASSIGN] Evaluating: rating11 := input()
[SEE] Mapping base name 'rating' -> 'rating11'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X42
[ASSIGN] Result: rating11 := X42

[ASSIGN] Evaluating: comment11 := input()
[SEE] Mapping base name 'comment' -> 'comment11'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X43
[ASSIGN] Result: comment11 := X43
[SEE] API call 'get_Rev' ready for actual execution

[ASSIGN] Evaluating: tmp_Rev_0 := get_Rev()
[SEE] Mapping base name 'tmp_Rev_' -> 'tmp_Rev_0'
[API_CALL] Executing API function: get_Rev
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Rev
  [API_CALL] Executing function...
[GetRevFunc] Fetching Rev...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Rev_0
[ASSIGN] Result: tmp_Rev_0 := {}

[ASSIGN] Evaluating: Rev_old := tmp_Rev_0
  [EVAL] Var lookup: tmp_Rev_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Rev_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_10 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_10'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_10
[ASSIGN] Result: tmp_T_10 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_12 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_12'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_12
[ASSIGN] Result: tmp_Roles_12 := {}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_2 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_2'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O (Orders)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_2
[ASSIGN] Result: tmp_O_2 := {}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_3 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_3'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O (Orders)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_3
[ASSIGN] Result: tmp_O_3 := {}
[SEE] Interruption at statement 158

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_T_10)), =([](tmp_Roles_12, buyerEmail), BUYER), in(orderId, dom(tmp_O_2)), =([](tmp_O_3, orderId), buyerEmail))
  [EVAL] FuncCall: AND with 4 args
    [EVAL] N-ary AND with 4 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_T_10))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail11'
    [EVAL] Found in sigma: X39
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_10
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X39
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_12, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_12
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail11'
    [EVAL] Found in sigma: X39
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X39
    [EVAL] Key not found in map
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X39) BUYER)
    [EVAL] Arg[2]: in(orderId, dom(tmp_O_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId11'
    [EVAL] Found in sigma: X41
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_2
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X41
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] Arg[3]: =([](tmp_O_3, orderId), buyerEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_O_3
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId11'
    [EVAL] Found in sigma: X41
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X41
    [EVAL] Key not found in map
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail11'
    [EVAL] Found in sigma: X39
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[3] result: (= []({}, X41) X39)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'createReview' with symbolic arguments - interruption point
[SEE] Interruption at statement 159

[ASSIGN] Evaluating: _result11 := createReview(buyerEmail, productId, orderId, rating, comment)
[SEE] Mapping base name '_result' -> '_result11'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail11'
    [EVAL] Found in sigma: X39
  [EVAL] Var lookup: productId
    [EVAL] Resolved base name 'productId' -> 'productId11'
    [EVAL] Found in sigma: X40
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId11'
    [EVAL] Found in sigma: X41
  [EVAL] Var lookup: rating
    [EVAL] Resolved base name 'rating' -> 'rating11'
    [EVAL] Found in sigma: X42
  [EVAL] Var lookup: comment
    [EVAL] Resolved base name 'comment' -> 'comment11'
    [EVAL] Found in sigma: X43
[API_CALL] createReview has symbolic arguments - skipping actual execution
  [API_ARG 0] X39 (symbolic: 1)
  [API_ARG 1] X40 (symbolic: 1)
  [API_ARG 2] X41 (symbolic: 1)
  [API_ARG 3] X42 (symbolic: 1)
  [API_ARG 4] X43 (symbolic: 1)
[ASSIGN] Result: _result11 := -1 (symbolic placeholder)
[SEE] API call 'get_Rev' ready for actual execution

[ASSIGN] Evaluating: tmp_Rev_1 := get_Rev()
[SEE] Mapping base name 'tmp_Rev_' -> 'tmp_Rev_1'
[API_CALL] Executing API function: get_Rev
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Rev
  [API_CALL] Executing function...
[GetRevFunc] Fetching Rev...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Rev_1
[ASSIGN] Result: tmp_Rev_1 := {}

[ASSERT] Evaluating: in(_result11, dom(tmp_Rev_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result11
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_Rev_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: buyerEmail12 := input()
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail12'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X44
[ASSIGN] Result: buyerEmail12 := X44

[ASSIGN] Evaluating: productId12 := input()
[SEE] Mapping base name 'productId' -> 'productId12'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X45
[ASSIGN] Result: productId12 := X45

[ASSIGN] Evaluating: quantity12 := input()
[SEE] Mapping base name 'quantity' -> 'quantity12'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X46
[ASSIGN] Result: quantity12 := X46
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_7 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_7'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_7
[ASSIGN] Result: tmp_C_7 := {}

[ASSIGN] Evaluating: C_old := tmp_C_7
  [EVAL] Var lookup: tmp_C_7
    [EVAL] Found in sigma: {}
[ASSIGN] Result: C_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_11 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_11'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_11
[ASSIGN] Result: tmp_T_11 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_13 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_13'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_13
[ASSIGN] Result: tmp_Roles_13 := {}
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_8 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_8'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_P_8
[ASSIGN] Result: tmp_P_8 := {}
[SEE] Interruption at statement 170

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_T_11)), =([](tmp_Roles_13, buyerEmail), BUYER), in(productId, dom(tmp_P_8)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_T_11))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail12'
    [EVAL] Found in sigma: X44
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_11
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X44
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_13, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_13
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail12'
    [EVAL] Found in sigma: X44
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X44
    [EVAL] Key not found in map
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X44) BUYER)
    [EVAL] Arg[2]: in(productId, dom(tmp_P_8))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: productId
    [EVAL] Resolved base name 'productId' -> 'productId12'
    [EVAL] Found in sigma: X45
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_P_8
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X45
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'addToCart' with symbolic arguments - interruption point
[SEE] Interruption at statement 171

[ASSIGN] Evaluating: _result12 := addToCart(buyerEmail, productId, quantity)
[SEE] Mapping base name '_result' -> '_result12'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail12'
    [EVAL] Found in sigma: X44
  [EVAL] Var lookup: productId
    [EVAL] Resolved base name 'productId' -> 'productId12'
    [EVAL] Found in sigma: X45
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity12'
    [EVAL] Found in sigma: X46
[API_CALL] addToCart has symbolic arguments - skipping actual execution
  [API_ARG 0] X44 (symbolic: 1)
  [API_ARG 1] X45 (symbolic: 1)
  [API_ARG 2] X46 (symbolic: 1)
[ASSIGN] Result: _result12 := -1 (symbolic placeholder)
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_8 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_8'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_8
[ASSIGN] Result: tmp_C_8 := {}

[ASSERT] Evaluating: in(buyerEmail, dom(tmp_C_8))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail12'
    [EVAL] Found in sigma: X44
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_8
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X44
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: buyerEmail13 := input()
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail13'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X47
[ASSIGN] Result: buyerEmail13 := X47

[ASSIGN] Evaluating: shippingAddress13 := input()
[SEE] Mapping base name 'shippingAddress' -> 'shippingAddress13'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X48
[ASSIGN] Result: shippingAddress13 := X48

[ASSIGN] Evaluating: paymentMethod13 := input()
[SEE] Mapping base name 'paymentMethod' -> 'paymentMethod13'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X49
[ASSIGN] Result: paymentMethod13 := X49
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_9 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_9'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_9
[ASSIGN] Result: tmp_C_9 := {}

[ASSIGN] Evaluating: C_old := tmp_C_9
  [EVAL] Var lookup: tmp_C_9
    [EVAL] Found in sigma: {}
[ASSIGN] Result: C_old := {}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_4 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_4'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O (Orders)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_4
[ASSIGN] Result: tmp_O_4 := {}

[ASSIGN] Evaluating: O_old := tmp_O_4
  [EVAL] Var lookup: tmp_O_4
    [EVAL] Found in sigma: {}
[ASSIGN] Result: O_old := {}
[SEE] API call 'get_OrderStatus' ready for actual execution

[ASSIGN] Evaluating: tmp_OrderStatus_2 := get_OrderStatus()
[SEE] Mapping base name 'tmp_OrderStatus_' -> 'tmp_OrderStatus_2'
[API_CALL] Executing API function: get_OrderStatus
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_OrderStatus
  [API_CALL] Executing function...
[GetOrderStatusFunc] Fetching OrderStatus...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_OrderStatus_2
[ASSIGN] Result: tmp_OrderStatus_2 := {}

[ASSIGN] Evaluating: OrderStatus_old := tmp_OrderStatus_2
  [EVAL] Var lookup: tmp_OrderStatus_2
    [EVAL] Found in sigma: {}
[ASSIGN] Result: OrderStatus_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_12 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_12'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_12
[ASSIGN] Result: tmp_T_12 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_14 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_14'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_14
[ASSIGN] Result: tmp_Roles_14 := {}
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_10 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_10'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_10
[ASSIGN] Result: tmp_C_10 := {}
[SEE] Interruption at statement 186

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_T_12)), =([](tmp_Roles_14, buyerEmail), BUYER), in(buyerEmail, dom(tmp_C_10)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_T_12))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail13'
    [EVAL] Found in sigma: X47
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_12
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X47
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_14, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_14
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail13'
    [EVAL] Found in sigma: X47
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X47
    [EVAL] Key not found in map
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X47) BUYER)
    [EVAL] Arg[2]: in(buyerEmail, dom(tmp_C_10))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail13'
    [EVAL] Found in sigma: X47
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_10
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X47
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'createOrder' with symbolic arguments - interruption point
[SEE] Interruption at statement 187

[ASSIGN] Evaluating: _result13 := createOrder(buyerEmail, shippingAddress, paymentMethod)
[SEE] Mapping base name '_result' -> '_result13'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail13'
    [EVAL] Found in sigma: X47
  [EVAL] Var lookup: shippingAddress
    [EVAL] Resolved base name 'shippingAddress' -> 'shippingAddress13'
    [EVAL] Found in sigma: X48
  [EVAL] Var lookup: paymentMethod
    [EVAL] Resolved base name 'paymentMethod' -> 'paymentMethod13'
    [EVAL] Found in sigma: X49
[API_CALL] createOrder has symbolic arguments - skipping actual execution
  [API_ARG 0] X47 (symbolic: 1)
  [API_ARG 1] X48 (symbolic: 1)
  [API_ARG 2] X49 (symbolic: 1)
[ASSIGN] Result: _result13 := -1 (symbolic placeholder)
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_5 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_5'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O (Orders)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_5
[ASSIGN] Result: tmp_O_5 := {}
[SEE] API call 'get_OrderStatus' ready for actual execution

[ASSIGN] Evaluating: tmp_OrderStatus_3 := get_OrderStatus()
[SEE] Mapping base name 'tmp_OrderStatus_' -> 'tmp_OrderStatus_3'
[API_CALL] Executing API function: get_OrderStatus
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_OrderStatus
  [API_CALL] Executing function...
[GetOrderStatusFunc] Fetching OrderStatus...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_OrderStatus_3
[ASSIGN] Result: tmp_OrderStatus_3 := {}
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_11 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_11'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_11
[ASSIGN] Result: tmp_C_11 := {}
[SEE] Interruption at statement 191

[ASSERT] Evaluating: AND(in(_result13, dom(tmp_O_5)), =([](tmp_OrderStatus_3, _result13), PENDING), not_in(buyerEmail, dom(tmp_C_11)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(_result13, dom(tmp_O_5))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result13
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_5
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_OrderStatus_3, _result13), PENDING)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_OrderStatus_3
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: _result13
    [EVAL] Found in sigma: -1
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: -1
    [EVAL] Key not found in map
  [EVAL] Var lookup: PENDING
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, -1) PENDING)
    [EVAL] Arg[2]: not_in(buyerEmail, dom(tmp_C_11))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail13'
    [EVAL] Found in sigma: X47
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_11
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
    [EVAL] Arg[2] result: true
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: buyerEmail14 := input()
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail14'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X50
[ASSIGN] Result: buyerEmail14 := X50

[ASSIGN] Evaluating: productId14 := input()
[SEE] Mapping base name 'productId' -> 'productId14'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X51
[ASSIGN] Result: productId14 := X51

[ASSIGN] Evaluating: orderId14 := input()
[SEE] Mapping base name 'orderId' -> 'orderId14'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X52
[ASSIGN] Result: orderId14 := X52

[ASSIGN] Evaluating: rating14 := input()
[SEE] Mapping base name 'rating' -> 'rating14'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X53
[ASSIGN] Result: rating14 := X53

[ASSIGN] Evaluating: comment14 := input()
[SEE] Mapping base name 'comment' -> 'comment14'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X54
[ASSIGN] Result: comment14 := X54
[SEE] API call 'get_Rev' ready for actual execution

[ASSIGN] Evaluating: tmp_Rev_2 := get_Rev()
[SEE] Mapping base name 'tmp_Rev_' -> 'tmp_Rev_2'
[API_CALL] Executing API function: get_Rev
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Rev
  [API_CALL] Executing function...
[GetRevFunc] Fetching Rev...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Rev_2
[ASSIGN] Result: tmp_Rev_2 := {}

[ASSIGN] Evaluating: Rev_old := tmp_Rev_2
  [EVAL] Var lookup: tmp_Rev_2
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Rev_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_13 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_13'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_13
[ASSIGN] Result: tmp_T_13 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_15 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_15'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_15
[ASSIGN] Result: tmp_Roles_15 := {}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_6 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_6'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O (Orders)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_6
[ASSIGN] Result: tmp_O_6 := {}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_7 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_7'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O (Orders)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_7
[ASSIGN] Result: tmp_O_7 := {}
[SEE] Interruption at statement 203

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_T_13)), =([](tmp_Roles_15, buyerEmail), BUYER), in(orderId, dom(tmp_O_6)), =([](tmp_O_7, orderId), buyerEmail))
  [EVAL] FuncCall: AND with 4 args
    [EVAL] N-ary AND with 4 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_T_13))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail14'
    [EVAL] Found in sigma: X50
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_13
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X50
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_Roles_15, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_15
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail14'
    [EVAL] Found in sigma: X50
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X50
    [EVAL] Key not found in map
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X50) BUYER)
    [EVAL] Arg[2]: in(orderId, dom(tmp_O_6))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId14'
    [EVAL] Found in sigma: X52
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_6
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X52
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] Arg[3]: =([](tmp_O_7, orderId), buyerEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_O_7
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId14'
    [EVAL] Found in sigma: X52
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X52
    [EVAL] Key not found in map
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail14'
    [EVAL] Found in sigma: X50
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[3] result: (= []({}, X52) X50)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'createReview' with symbolic arguments - interruption point
[SEE] Interruption at statement 204

[ASSIGN] Evaluating: _result14 := createReview(buyerEmail, productId, orderId, rating, comment)
[SEE] Mapping base name '_result' -> '_result14'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail14'
    [EVAL] Found in sigma: X50
  [EVAL] Var lookup: productId
    [EVAL] Resolved base name 'productId' -> 'productId14'
    [EVAL] Found in sigma: X51
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId14'
    [EVAL] Found in sigma: X52
  [EVAL] Var lookup: rating
    [EVAL] Resolved base name 'rating' -> 'rating14'
    [EVAL] Found in sigma: X53
  [EVAL] Var lookup: comment
    [EVAL] Resolved base name 'comment' -> 'comment14'
    [EVAL] Found in sigma: X54
[API_CALL] createReview has symbolic arguments - skipping actual execution
  [API_ARG 0] X50 (symbolic: 1)
  [API_ARG 1] X51 (symbolic: 1)
  [API_ARG 2] X52 (symbolic: 1)
  [API_ARG 3] X53 (symbolic: 1)
  [API_ARG 4] X54 (symbolic: 1)
[ASSIGN] Result: _result14 := -1 (symbolic placeholder)
[SEE] API call 'get_Rev' ready for actual execution

[ASSIGN] Evaluating: tmp_Rev_3 := get_Rev()
[SEE] Mapping base name 'tmp_Rev_' -> 'tmp_Rev_3'
[API_CALL] Executing API function: get_Rev
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Rev
  [API_CALL] Executing function...
[GetRevFunc] Fetching Rev...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Rev_3
[ASSIGN] Result: tmp_Rev_3 := {}

[ASSERT] Evaluating: in(_result14, dom(tmp_Rev_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result14
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_Rev_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[SEE] Path Constraint: And(true, And(true, And(AND((= []({}, X0) X1), (= []({}, X0) SELLER)), And(false, And((= []({}, X5) -1), And(false, And(false, And(false, And(true, And(AND((= []({}, X25) X26), (= []({}, X25) BUYER)), And(false, And((= []({}, X28) -1), And(1, And(false, And(false, And(false, And(false, And(false, And(false, false)))))))))))))))))))

[UNSAT-CHECK] Path constraint contains FALSE - checking dependencies...

[DEPENDENCY-CHECK] Analyzing sequence for true UNSAT...
[DEPENDENCY-CHECK] ✓ All dependencies satisfied - sequence is potentially satisfiable.
>>> generateCTC: After symex - Is abstract: 1, Has placeholders: 0

>>> generateCTC: STEP 3 - Generating values with sigma lookup
    [Found existing] _ -> _
    [Found existing] tmp_Roles_ -> tmp_Roles_0
    [Found existing] Roles_old -> Roles_old
    [Found existing] tmp_U_ -> tmp_U_0
    [Found existing] U_old -> U_old
    [Found existing] _result -> _result0
    [Found existing] tmp_T_ -> tmp_T_0
    [Found existing] T_old -> T_old
    [Found existing] tmp_P_ -> tmp_P_0
    [Found existing] P_old -> P_old
    [Found existing] tmp_Sellers_ -> tmp_Sellers_0
    [Found existing] Sellers_old -> Sellers_old
    [Found existing] tmp_C_ -> tmp_C_0
    [Found existing] C_old -> C_old
    [Found existing] tmp_O_ -> tmp_O_0
    [Found existing] O_old -> O_old
    [Found existing] tmp_OrderStatus_ -> tmp_OrderStatus_0
    [Found existing] OrderStatus_old -> OrderStatus_old
    [Found existing] tmp_Rev_ -> tmp_Rev_0
    [Found existing] Rev_old -> Rev_old
    sellerEmail0 = "seller@example.com"
    sellerPassword0 = "SellerPass123!"
    sellerFullName0 = "Test Seller"
    storeName0 = "Test Store"
    storeDescription0 = "A quality test store"
    sellerEmail1 = (reusing sellerEmail) "seller@example.com"
    sellerPassword1 = (reusing sellerPassword) "SellerPass123!"
    sellerEmail2 = (reusing sellerEmail) "seller@example.com"
    title2 = "Test Product"
    description2 = "A great test product description"
    category2 = "Electronics"
    price2 = 99
    quantity2 = 2
    sellerEmail3 = (reusing sellerEmail) "seller@example.com"
    title3 = (reusing title) "Test Product"
    description3 = (reusing description) "A great test product description"
    category3 = (reusing category) "Electronics"
    price3 = (reusing price) 99
    quantity3 = (reusing quantity) 2
    sellerEmail4 = (reusing sellerEmail) "seller@example.com"
    title4 = (reusing title) "Test Product"
    description4 = (reusing description) "A great test product description"
    category4 = (reusing category) "Electronics"
    price4 = (reusing price) 99
    quantity4 = (reusing quantity) 2
    buyerEmail5 = "buyer@example.com"
    buyerPassword5 = "BuyerPass123!"
    buyerFullName5 = "Test Buyer"
    buyerEmail6 = (reusing buyerEmail) "buyer@example.com"
    buyerPassword6 = (reusing buyerPassword) "BuyerPass123!"
    buyerEmail8 = (reusing buyerEmail) "buyer@example.com"
    [findKeyFromMapInSigma] Searching for prefix: tmp_P_
    [findKeyFromMapInSigma] tmp_P_8 is empty map
    [findKeyFromMapInSigma] tmp_P_7 is empty map
    [findKeyFromMapInSigma] tmp_P_6 is empty map
    [findKeyFromMapInSigma] tmp_P_5 is empty map
    [findKeyFromMapInSigma] tmp_P_4 is empty map
    [findKeyFromMapInSigma] tmp_P_3 is empty map
    [findKeyFromMapInSigma] tmp_P_2 is empty map
    [findKeyFromMapInSigma] tmp_P_1 is empty map
    [findKeyFromMapInSigma] tmp_P_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_P_
    [DEFERRED] productId - no product in sigma yet
    productId8 = "__NEEDS_PRODUCT_ID__"
    quantity8 = (reusing quantity) 2
    buyerEmail9 = (reusing buyerEmail) "buyer@example.com"
    [findKeyFromMapInSigma] Searching for prefix: tmp_P_
    [findKeyFromMapInSigma] tmp_P_8 is empty map
    [findKeyFromMapInSigma] tmp_P_7 is empty map
    [findKeyFromMapInSigma] tmp_P_6 is empty map
    [findKeyFromMapInSigma] tmp_P_5 is empty map
    [findKeyFromMapInSigma] tmp_P_4 is empty map
    [findKeyFromMapInSigma] tmp_P_3 is empty map
    [findKeyFromMapInSigma] tmp_P_2 is empty map
    [findKeyFromMapInSigma] tmp_P_1 is empty map
    [findKeyFromMapInSigma] tmp_P_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_P_
    [DEFERRED] productId - no product in sigma yet
    productId9 = "__NEEDS_PRODUCT_ID__"
    quantity9 = (reusing quantity) 2
    buyerEmail10 = (reusing buyerEmail) "buyer@example.com"
    shippingAddress10 = "123 Test St,Test City,TS,12345,USA"
    paymentMethod10 = "card"
    buyerEmail11 = (reusing buyerEmail) "buyer@example.com"
    [findKeyFromMapInSigma] Searching for prefix: tmp_P_
    [findKeyFromMapInSigma] tmp_P_8 is empty map
    [findKeyFromMapInSigma] tmp_P_7 is empty map
    [findKeyFromMapInSigma] tmp_P_6 is empty map
    [findKeyFromMapInSigma] tmp_P_5 is empty map
    [findKeyFromMapInSigma] tmp_P_4 is empty map
    [findKeyFromMapInSigma] tmp_P_3 is empty map
    [findKeyFromMapInSigma] tmp_P_2 is empty map
    [findKeyFromMapInSigma] tmp_P_1 is empty map
    [findKeyFromMapInSigma] tmp_P_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_P_
    [DEFERRED] productId - no product in sigma yet
    productId11 = "__NEEDS_PRODUCT_ID__"
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_7 is empty map
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [DEFERRED] orderId - no order in sigma yet
    orderId11 = "__NEEDS_ORDER_ID__"
    rating11 = 5
    comment11 = "Great product, highly recommend!"
    buyerEmail12 = (reusing buyerEmail) "buyer@example.com"
    [findKeyFromMapInSigma] Searching for prefix: tmp_P_
    [findKeyFromMapInSigma] tmp_P_8 is empty map
    [findKeyFromMapInSigma] tmp_P_7 is empty map
    [findKeyFromMapInSigma] tmp_P_6 is empty map
    [findKeyFromMapInSigma] tmp_P_5 is empty map
    [findKeyFromMapInSigma] tmp_P_4 is empty map
    [findKeyFromMapInSigma] tmp_P_3 is empty map
    [findKeyFromMapInSigma] tmp_P_2 is empty map
    [findKeyFromMapInSigma] tmp_P_1 is empty map
    [findKeyFromMapInSigma] tmp_P_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_P_
    [DEFERRED] productId - no product in sigma yet
    productId12 = "__NEEDS_PRODUCT_ID__"
    quantity12 = (reusing quantity) 2
    buyerEmail13 = (reusing buyerEmail) "buyer@example.com"
    shippingAddress13 = (reusing shippingAddress) "123 Test St,Test City,TS,12345,USA"
    paymentMethod13 = (reusing paymentMethod) "card"
    buyerEmail14 = (reusing buyerEmail) "buyer@example.com"
    [findKeyFromMapInSigma] Searching for prefix: tmp_P_
    [findKeyFromMapInSigma] tmp_P_8 is empty map
    [findKeyFromMapInSigma] tmp_P_7 is empty map
    [findKeyFromMapInSigma] tmp_P_6 is empty map
    [findKeyFromMapInSigma] tmp_P_5 is empty map
    [findKeyFromMapInSigma] tmp_P_4 is empty map
    [findKeyFromMapInSigma] tmp_P_3 is empty map
    [findKeyFromMapInSigma] tmp_P_2 is empty map
    [findKeyFromMapInSigma] tmp_P_1 is empty map
    [findKeyFromMapInSigma] tmp_P_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_P_
    [DEFERRED] productId - no product in sigma yet
    productId14 = "__NEEDS_PRODUCT_ID__"
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_7 is empty map
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [DEFERRED] orderId - no order in sigma yet
    orderId14 = "__NEEDS_ORDER_ID__"
    rating14 = (reusing rating) 5
    comment14 = (reusing comment) "Great product, highly recommend!"

>>> generateCTC: STEP 4 - Resolving placeholders from sigma
    [findKeyFromMapInSigma] Searching for prefix: tmp_P_
    [findKeyFromMapInSigma] tmp_P_8 is empty map
    [findKeyFromMapInSigma] tmp_P_7 is empty map
    [findKeyFromMapInSigma] tmp_P_6 is empty map
    [findKeyFromMapInSigma] tmp_P_5 is empty map
    [findKeyFromMapInSigma] tmp_P_4 is empty map
    [findKeyFromMapInSigma] tmp_P_3 is empty map
    [findKeyFromMapInSigma] tmp_P_2 is empty map
    [findKeyFromMapInSigma] tmp_P_1 is empty map
    [findKeyFromMapInSigma] tmp_P_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_P_
    [STILL PENDING] productId8 - keeping placeholder for next iteration
    [findKeyFromMapInSigma] Searching for prefix: tmp_P_
    [findKeyFromMapInSigma] tmp_P_8 is empty map
    [findKeyFromMapInSigma] tmp_P_7 is empty map
    [findKeyFromMapInSigma] tmp_P_6 is empty map
    [findKeyFromMapInSigma] tmp_P_5 is empty map
    [findKeyFromMapInSigma] tmp_P_4 is empty map
    [findKeyFromMapInSigma] tmp_P_3 is empty map
    [findKeyFromMapInSigma] tmp_P_2 is empty map
    [findKeyFromMapInSigma] tmp_P_1 is empty map
    [findKeyFromMapInSigma] tmp_P_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_P_
    [STILL PENDING] productId9 - keeping placeholder for next iteration
    [findKeyFromMapInSigma] Searching for prefix: tmp_P_
    [findKeyFromMapInSigma] tmp_P_8 is empty map
    [findKeyFromMapInSigma] tmp_P_7 is empty map
    [findKeyFromMapInSigma] tmp_P_6 is empty map
    [findKeyFromMapInSigma] tmp_P_5 is empty map
    [findKeyFromMapInSigma] tmp_P_4 is empty map
    [findKeyFromMapInSigma] tmp_P_3 is empty map
    [findKeyFromMapInSigma] tmp_P_2 is empty map
    [findKeyFromMapInSigma] tmp_P_1 is empty map
    [findKeyFromMapInSigma] tmp_P_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_P_
    [STILL PENDING] productId11 - keeping placeholder for next iteration
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_7 is empty map
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [STILL PENDING] orderId11 - keeping placeholder for next iteration
    [findKeyFromMapInSigma] Searching for prefix: tmp_P_
    [findKeyFromMapInSigma] tmp_P_8 is empty map
    [findKeyFromMapInSigma] tmp_P_7 is empty map
    [findKeyFromMapInSigma] tmp_P_6 is empty map
    [findKeyFromMapInSigma] tmp_P_5 is empty map
    [findKeyFromMapInSigma] tmp_P_4 is empty map
    [findKeyFromMapInSigma] tmp_P_3 is empty map
    [findKeyFromMapInSigma] tmp_P_2 is empty map
    [findKeyFromMapInSigma] tmp_P_1 is empty map
    [findKeyFromMapInSigma] tmp_P_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_P_
    [STILL PENDING] productId12 - keeping placeholder for next iteration
    [findKeyFromMapInSigma] Searching for prefix: tmp_P_
    [findKeyFromMapInSigma] tmp_P_8 is empty map
    [findKeyFromMapInSigma] tmp_P_7 is empty map
    [findKeyFromMapInSigma] tmp_P_6 is empty map
    [findKeyFromMapInSigma] tmp_P_5 is empty map
    [findKeyFromMapInSigma] tmp_P_4 is empty map
    [findKeyFromMapInSigma] tmp_P_3 is empty map
    [findKeyFromMapInSigma] tmp_P_2 is empty map
    [findKeyFromMapInSigma] tmp_P_1 is empty map
    [findKeyFromMapInSigma] tmp_P_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_P_
    [STILL PENDING] productId14 - keeping placeholder for next iteration
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_7 is empty map
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [STILL PENDING] orderId14 - keeping placeholder for next iteration

>>> generateCTC: STEP 5 - Recursing with 55 concrete values

========================================
>>> generateCTC: Starting iteration
========================================
>>> generateCTC: Program needs processing
>>> generateCTC: Concrete values provided: 55
>>> generateCTC: Is abstract: 1
>>> generateCTC: Has placeholders: 0

>>> generateCTC: STEP 1 - Rewriting ATC with concrete values

>>> generateCTC: STEP 2 - Running symbolic execution
[SEE] API call 'reset' ready for actual execution

[ASSIGN] Evaluating: _ := reset()
[API_CALL] Executing API function: reset
  [API_CALL] Getting function from factory...
[Factory] Creating function: reset
  [API_CALL] Executing function...
[ResetFunc] Clearing all collections...
[HttpClient] POST /api/test/reset -> 200
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _
[ASSIGN] Result: _ := 200

[ASSIGN] Evaluating: sellerEmail0 := "seller@example.com"
[SEE] Mapping base name 'sellerEmail' -> 'sellerEmail0'
  [EVAL] String: "seller@example.com"
[ASSIGN] Result: sellerEmail0 := "seller@example.com"

[ASSIGN] Evaluating: sellerPassword0 := "SellerPass123!"
[SEE] Mapping base name 'sellerPassword' -> 'sellerPassword0'
  [EVAL] String: "SellerPass123!"
[ASSIGN] Result: sellerPassword0 := "SellerPass123!"

[ASSIGN] Evaluating: sellerFullName0 := "Test Seller"
[SEE] Mapping base name 'sellerFullName' -> 'sellerFullName0'
  [EVAL] String: "Test Seller"
[ASSIGN] Result: sellerFullName0 := "Test Seller"

[ASSIGN] Evaluating: storeName0 := "Test Store"
[SEE] Mapping base name 'storeName' -> 'storeName0'
  [EVAL] String: "Test Store"
[ASSIGN] Result: storeName0 := "Test Store"

[ASSIGN] Evaluating: storeDescription0 := "A quality test store"
[SEE] Mapping base name 'storeDescription' -> 'storeDescription0'
  [EVAL] String: "A quality test store"
[ASSIGN] Result: storeDescription0 := "A quality test store"
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_0 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_0'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_0
[ASSIGN] Result: tmp_Roles_0 := {}

[ASSIGN] Evaluating: Roles_old := tmp_Roles_0
  [EVAL] Var lookup: tmp_Roles_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Roles_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_0 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_0'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_0
[ASSIGN] Result: tmp_U_0 := {}

[ASSIGN] Evaluating: U_old := tmp_U_0
  [EVAL] Var lookup: tmp_U_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: U_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_1 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_1'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_1
[ASSIGN] Result: tmp_U_1 := {}

[ASSUME] Evaluating: not_in(sellerEmail, dom(tmp_U_1))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail0'
    [EVAL] Found in sigma: "seller@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
[ASSUME] Adding constraint: true
[SEE] API call 'registerSeller' ready for actual execution

[ASSIGN] Evaluating: _result0 := registerSeller(sellerEmail, sellerPassword, sellerFullName, storeName, storeDescription)
[SEE] Mapping base name '_result' -> '_result0'
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail0'
    [EVAL] Found in sigma: "seller@example.com"
  [EVAL] Var lookup: sellerPassword
    [EVAL] Resolved base name 'sellerPassword' -> 'sellerPassword0'
    [EVAL] Found in sigma: "SellerPass123!"
  [EVAL] Var lookup: sellerFullName
    [EVAL] Resolved base name 'sellerFullName' -> 'sellerFullName0'
    [EVAL] Found in sigma: "Test Seller"
  [EVAL] Var lookup: storeName
    [EVAL] Resolved base name 'storeName' -> 'storeName0'
    [EVAL] Found in sigma: "Test Store"
  [EVAL] Var lookup: storeDescription
    [EVAL] Resolved base name 'storeDescription' -> 'storeDescription0'
    [EVAL] Found in sigma: "A quality test store"
[API_CALL] Executing API function: registerSeller
  [API_ARG] "seller@example.com"
  [API_ARG] "SellerPass123!"
  [API_ARG] "Test Seller"
  [API_ARG] "Test Store"
  [API_ARG] "A quality test store"
  [API_CALL] Getting function from factory...
[Factory] Creating function: registerSeller
  [API_CALL] Executing function...
[RegisterSellerFunc] Registering seller: seller@example.com
[HttpClient] POST /api/auth/register -> 201
  [API_CALL] Function returned: 201
  [API_CALL] Storing result in variable: _result0
[ASSIGN] Result: _result0 := 201
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_2 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_2'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {seller@example.com -> "SellerPass123!"}
  [API_CALL] Storing result in variable: tmp_U_2
[ASSIGN] Result: tmp_U_2 := {seller@example.com -> "SellerPass123!"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_1 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_1'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {seller@example.com -> "Seller"}
  [API_CALL] Storing result in variable: tmp_Roles_1
[ASSIGN] Result: tmp_Roles_1 := {seller@example.com -> "Seller"}

[ASSERT] Evaluating: AND(=([](tmp_U_2, sellerEmail), sellerPassword), =([](tmp_Roles_1, sellerEmail), SELLER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: =([](tmp_U_2, sellerEmail), sellerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_2
    [EVAL] Found in sigma: {seller@example.com -> "SellerPass123!"}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail0'
    [EVAL] Found in sigma: "seller@example.com"
    [EVAL] Map expr evaluated: {seller@example.com -> "SellerPass123!"}
    [EVAL] Key expr evaluated: "seller@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "SellerPass123!"
  [EVAL] Var lookup: sellerPassword
    [EVAL] Resolved base name 'sellerPassword' -> 'sellerPassword0'
    [EVAL] Found in sigma: "SellerPass123!"
    [EVAL] Eq result: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_1, sellerEmail), SELLER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_1
    [EVAL] Found in sigma: {seller@example.com -> "Seller"}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail0'
    [EVAL] Found in sigma: "seller@example.com"
    [EVAL] Map expr evaluated: {seller@example.com -> "Seller"}
    [EVAL] Key expr evaluated: "seller@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "Seller"
  [EVAL] Var lookup: SELLER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "Seller" SELLER)
    [EVAL] FuncCall result: AND(true, (= "Seller" SELLER))
[ASSERT] Result: AND(true, (= "Seller" SELLER))
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: sellerEmail1 := "seller@example.com"
[SEE] Mapping base name 'sellerEmail' -> 'sellerEmail1'
  [EVAL] String: "seller@example.com"
[ASSIGN] Result: sellerEmail1 := "seller@example.com"

[ASSIGN] Evaluating: sellerPassword1 := "SellerPass123!"
[SEE] Mapping base name 'sellerPassword' -> 'sellerPassword1'
  [EVAL] String: "SellerPass123!"
[ASSIGN] Result: sellerPassword1 := "SellerPass123!"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_0 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_0'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_0
[ASSIGN] Result: tmp_T_0 := {}

[ASSIGN] Evaluating: T_old := tmp_T_0
  [EVAL] Var lookup: tmp_T_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: T_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_3 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_3'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {seller@example.com -> "SellerPass123!"}
  [API_CALL] Storing result in variable: tmp_U_3
[ASSIGN] Result: tmp_U_3 := {seller@example.com -> "SellerPass123!"}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_4 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_4'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {seller@example.com -> "SellerPass123!"}
  [API_CALL] Storing result in variable: tmp_U_4
[ASSIGN] Result: tmp_U_4 := {seller@example.com -> "SellerPass123!"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_2 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_2'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {seller@example.com -> "Seller"}
  [API_CALL] Storing result in variable: tmp_Roles_2
[ASSIGN] Result: tmp_Roles_2 := {seller@example.com -> "Seller"}

[ASSUME] Evaluating: AND(in(sellerEmail, dom(tmp_U_3)), =([](tmp_U_4, sellerEmail), sellerPassword), =([](tmp_Roles_2, sellerEmail), SELLER))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(sellerEmail, dom(tmp_U_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail1'
    [EVAL] Found in sigma: "seller@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_3
    [EVAL] Found in sigma: {seller@example.com -> "SellerPass123!"}
    [EVAL] Map expr evaluated: {seller@example.com -> "SellerPass123!"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "seller@example.com"
    [EVAL] Set: {"seller@example.com"}
    [EVAL] Element: "seller@example.com"
    [EVAL] Set: {"seller@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_U_4, sellerEmail), sellerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_4
    [EVAL] Found in sigma: {seller@example.com -> "SellerPass123!"}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail1'
    [EVAL] Found in sigma: "seller@example.com"
    [EVAL] Map expr evaluated: {seller@example.com -> "SellerPass123!"}
    [EVAL] Key expr evaluated: "seller@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "SellerPass123!"
  [EVAL] Var lookup: sellerPassword
    [EVAL] Resolved base name 'sellerPassword' -> 'sellerPassword1'
    [EVAL] Found in sigma: "SellerPass123!"
    [EVAL] Eq result: true
    [EVAL] Arg[1] result: true
    [EVAL] Arg[2]: =([](tmp_Roles_2, sellerEmail), SELLER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_2
    [EVAL] Found in sigma: {seller@example.com -> "Seller"}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail1'
    [EVAL] Found in sigma: "seller@example.com"
    [EVAL] Map expr evaluated: {seller@example.com -> "Seller"}
    [EVAL] Key expr evaluated: "seller@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "Seller"
  [EVAL] Var lookup: SELLER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[2] result: (= "Seller" SELLER)
    [EVAL] FuncCall result: AND(true, true, (= "Seller" SELLER))
[ASSUME] Adding constraint: AND(true, true, (= "Seller" SELLER))
[SEE] API call 'login' ready for actual execution

[ASSIGN] Evaluating: _result1 := login(sellerEmail, sellerPassword)
[SEE] Mapping base name '_result' -> '_result1'
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail1'
    [EVAL] Found in sigma: "seller@example.com"
  [EVAL] Var lookup: sellerPassword
    [EVAL] Resolved base name 'sellerPassword' -> 'sellerPassword1'
    [EVAL] Found in sigma: "SellerPass123!"
[API_CALL] Executing API function: login
  [API_ARG] "seller@example.com"
  [API_ARG] "SellerPass123!"
  [API_CALL] Getting function from factory...
[Factory] Creating function: login
  [API_CALL] Executing function...
[LoginFunc] Logging in: seller@example.com
[HttpClient] POST /api/auth/login -> 200
[LoginFunc] Token received for: seller@example.com
  [API_CALL] Function returned: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"
  [API_CALL] Storing result in variable: _result1
[ASSIGN] Result: _result1 := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_1 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_1'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
  [API_CALL] Storing result in variable: tmp_T_1
[ASSIGN] Result: tmp_T_1 := {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}

[ASSERT] Evaluating: =([](tmp_T_1, sellerEmail), _result1)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_T_1
    [EVAL] Found in sigma: {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail1'
    [EVAL] Found in sigma: "seller@example.com"
    [EVAL] Map expr evaluated: {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Key expr evaluated: "seller@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"
  [EVAL] Var lookup: _result1
    [EVAL] Found in sigma: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"
    [EVAL] Eq result: true
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[ASSIGN] Evaluating: sellerEmail2 := "seller@example.com"
[SEE] Mapping base name 'sellerEmail' -> 'sellerEmail2'
  [EVAL] String: "seller@example.com"
[ASSIGN] Result: sellerEmail2 := "seller@example.com"

[ASSIGN] Evaluating: title2 := "Test Product"
[SEE] Mapping base name 'title' -> 'title2'
  [EVAL] String: "Test Product"
[ASSIGN] Result: title2 := "Test Product"

[ASSIGN] Evaluating: description2 := "A great test product description"
[SEE] Mapping base name 'description' -> 'description2'
  [EVAL] String: "A great test product description"
[ASSIGN] Result: description2 := "A great test product description"

[ASSIGN] Evaluating: category2 := "Electronics"
[SEE] Mapping base name 'category' -> 'category2'
  [EVAL] String: "Electronics"
[ASSIGN] Result: category2 := "Electronics"

[ASSIGN] Evaluating: price2 := 99
[SEE] Mapping base name 'price' -> 'price2'
  [EVAL] Num: 99
[ASSIGN] Result: price2 := 99

[ASSIGN] Evaluating: quantity2 := 2
[SEE] Mapping base name 'quantity' -> 'quantity2'
  [EVAL] Num: 2
[ASSIGN] Result: quantity2 := 2
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_0 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_0'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_P_0
[ASSIGN] Result: tmp_P_0 := {}

[ASSIGN] Evaluating: P_old := tmp_P_0
  [EVAL] Var lookup: tmp_P_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: P_old := {}
[SEE] API call 'get_Sellers' ready for actual execution

[ASSIGN] Evaluating: tmp_Sellers_0 := get_Sellers()
[SEE] Mapping base name 'tmp_Sellers_' -> 'tmp_Sellers_0'
[API_CALL] Executing API function: get_Sellers
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Sellers
  [API_CALL] Executing function...
[GetSellersFunc] Fetching Sellers...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Sellers_0
[ASSIGN] Result: tmp_Sellers_0 := {}

[ASSIGN] Evaluating: Sellers_old := tmp_Sellers_0
  [EVAL] Var lookup: tmp_Sellers_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Sellers_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_2 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_2'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
  [API_CALL] Storing result in variable: tmp_T_2
[ASSIGN] Result: tmp_T_2 := {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_3 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_3'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {seller@example.com -> "Seller"}
  [API_CALL] Storing result in variable: tmp_Roles_3
[ASSIGN] Result: tmp_Roles_3 := {seller@example.com -> "Seller"}

[ASSUME] Evaluating: AND(in(sellerEmail, dom(tmp_T_2)), =([](tmp_Roles_3, sellerEmail), SELLER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(sellerEmail, dom(tmp_T_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: "seller@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_2
    [EVAL] Found in sigma: {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Map expr evaluated: {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "seller@example.com"
    [EVAL] Set: {"seller@example.com"}
    [EVAL] Element: "seller@example.com"
    [EVAL] Set: {"seller@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_3, sellerEmail), SELLER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_3
    [EVAL] Found in sigma: {seller@example.com -> "Seller"}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: "seller@example.com"
    [EVAL] Map expr evaluated: {seller@example.com -> "Seller"}
    [EVAL] Key expr evaluated: "seller@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "Seller"
  [EVAL] Var lookup: SELLER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "Seller" SELLER)
    [EVAL] FuncCall result: AND(true, (= "Seller" SELLER))
[ASSUME] Adding constraint: AND(true, (= "Seller" SELLER))
[SEE] API call 'createProduct' ready for actual execution

[ASSIGN] Evaluating: _result2 := createProduct(sellerEmail, title, description, category, price, quantity)
[SEE] Mapping base name '_result' -> '_result2'
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: "seller@example.com"
  [EVAL] Var lookup: title
    [EVAL] Resolved base name 'title' -> 'title2'
    [EVAL] Found in sigma: "Test Product"
  [EVAL] Var lookup: description
    [EVAL] Resolved base name 'description' -> 'description2'
    [EVAL] Found in sigma: "A great test product description"
  [EVAL] Var lookup: category
    [EVAL] Resolved base name 'category' -> 'category2'
    [EVAL] Found in sigma: "Electronics"
  [EVAL] Var lookup: price
    [EVAL] Resolved base name 'price' -> 'price2'
    [EVAL] Found in sigma: 99
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity2'
    [EVAL] Found in sigma: 2
[API_CALL] Executing API function: createProduct
  [API_ARG] "seller@example.com"
  [API_ARG] "Test Product"
  [API_ARG] "A great test product description"
  [API_ARG] "Electronics"
  [API_ARG] 99
  [API_ARG] 2
  [API_CALL] Getting function from factory...
[Factory] Creating function: createProduct
  [API_CALL] Executing function...
[CreateProductFunc] seller@example.com creating product: Test Product
[HttpClient] POST /api/products -> 201
[CreateProductFunc] Product created: 696caf2909fc7fa2c06c261d
  [API_CALL] Function returned: "696caf2909fc7fa2c06c261d"
  [API_CALL] Storing result in variable: _result2
[ASSIGN] Result: _result2 := "696caf2909fc7fa2c06c261d"
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_1 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_1'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {696caf2909fc7fa2c06c261d -> "Test Product"}
  [API_CALL] Storing result in variable: tmp_P_1
[ASSIGN] Result: tmp_P_1 := {696caf2909fc7fa2c06c261d -> "Test Product"}
[SEE] API call 'get_Sellers' ready for actual execution

[ASSIGN] Evaluating: tmp_Sellers_1 := get_Sellers()
[SEE] Mapping base name 'tmp_Sellers_' -> 'tmp_Sellers_1'
[API_CALL] Executing API function: get_Sellers
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Sellers
  [API_CALL] Executing function...
[GetSellersFunc] Fetching Sellers...
  [API_CALL] Function returned: {696caf2909fc7fa2c06c261d -> "seller@example.com"}
  [API_CALL] Storing result in variable: tmp_Sellers_1
[ASSIGN] Result: tmp_Sellers_1 := {696caf2909fc7fa2c06c261d -> "seller@example.com"}

[ASSERT] Evaluating: AND(in(_result2, dom(tmp_P_1)), =([](tmp_Sellers_1, _result2), sellerEmail))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(_result2, dom(tmp_P_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result2
    [EVAL] Found in sigma: "696caf2909fc7fa2c06c261d"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_P_1
    [EVAL] Found in sigma: {696caf2909fc7fa2c06c261d -> "Test Product"}
    [EVAL] Map expr evaluated: {696caf2909fc7fa2c06c261d -> "Test Product"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "696caf2909fc7fa2c06c261d"
    [EVAL] Set: {"696caf2909fc7fa2c06c261d"}
    [EVAL] Element: "696caf2909fc7fa2c06c261d"
    [EVAL] Set: {"696caf2909fc7fa2c06c261d"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Sellers_1, _result2), sellerEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Sellers_1
    [EVAL] Found in sigma: {696caf2909fc7fa2c06c261d -> "seller@example.com"}
  [EVAL] Var lookup: _result2
    [EVAL] Found in sigma: "696caf2909fc7fa2c06c261d"
    [EVAL] Map expr evaluated: {696caf2909fc7fa2c06c261d -> "seller@example.com"}
    [EVAL] Key expr evaluated: "696caf2909fc7fa2c06c261d"
    [EVAL] Key found in map, returning value
  [EVAL] String: "seller@example.com"
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail2'
    [EVAL] Found in sigma: "seller@example.com"
    [EVAL] Eq result: true
    [EVAL] Arg[1] result: true
    [EVAL] FuncCall result: AND(...) = true
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[ASSIGN] Evaluating: sellerEmail3 := "seller@example.com"
[SEE] Mapping base name 'sellerEmail' -> 'sellerEmail3'
  [EVAL] String: "seller@example.com"
[ASSIGN] Result: sellerEmail3 := "seller@example.com"

[ASSIGN] Evaluating: title3 := "Test Product"
[SEE] Mapping base name 'title' -> 'title3'
  [EVAL] String: "Test Product"
[ASSIGN] Result: title3 := "Test Product"

[ASSIGN] Evaluating: description3 := "A great test product description"
[SEE] Mapping base name 'description' -> 'description3'
  [EVAL] String: "A great test product description"
[ASSIGN] Result: description3 := "A great test product description"

[ASSIGN] Evaluating: category3 := "Electronics"
[SEE] Mapping base name 'category' -> 'category3'
  [EVAL] String: "Electronics"
[ASSIGN] Result: category3 := "Electronics"

[ASSIGN] Evaluating: price3 := 99
[SEE] Mapping base name 'price' -> 'price3'
  [EVAL] Num: 99
[ASSIGN] Result: price3 := 99

[ASSIGN] Evaluating: quantity3 := 2
[SEE] Mapping base name 'quantity' -> 'quantity3'
  [EVAL] Num: 2
[ASSIGN] Result: quantity3 := 2
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_2 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_2'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {696caf2909fc7fa2c06c261d -> "Test Product"}
  [API_CALL] Storing result in variable: tmp_P_2
[ASSIGN] Result: tmp_P_2 := {696caf2909fc7fa2c06c261d -> "Test Product"}

[ASSIGN] Evaluating: P_old := tmp_P_2
  [EVAL] Var lookup: tmp_P_2
    [EVAL] Found in sigma: {696caf2909fc7fa2c06c261d -> "Test Product"}
[ASSIGN] Result: P_old := {696caf2909fc7fa2c06c261d -> "Test Product"}
[SEE] API call 'get_Sellers' ready for actual execution

[ASSIGN] Evaluating: tmp_Sellers_2 := get_Sellers()
[SEE] Mapping base name 'tmp_Sellers_' -> 'tmp_Sellers_2'
[API_CALL] Executing API function: get_Sellers
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Sellers
  [API_CALL] Executing function...
[GetSellersFunc] Fetching Sellers...
  [API_CALL] Function returned: {696caf2909fc7fa2c06c261d -> "seller@example.com"}
  [API_CALL] Storing result in variable: tmp_Sellers_2
[ASSIGN] Result: tmp_Sellers_2 := {696caf2909fc7fa2c06c261d -> "seller@example.com"}

[ASSIGN] Evaluating: Sellers_old := tmp_Sellers_2
  [EVAL] Var lookup: tmp_Sellers_2
    [EVAL] Found in sigma: {696caf2909fc7fa2c06c261d -> "seller@example.com"}
[ASSIGN] Result: Sellers_old := {696caf2909fc7fa2c06c261d -> "seller@example.com"}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_3 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_3'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
  [API_CALL] Storing result in variable: tmp_T_3
[ASSIGN] Result: tmp_T_3 := {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_4 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_4'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {seller@example.com -> "Seller"}
  [API_CALL] Storing result in variable: tmp_Roles_4
[ASSIGN] Result: tmp_Roles_4 := {seller@example.com -> "Seller"}

[ASSUME] Evaluating: AND(in(sellerEmail, dom(tmp_T_3)), =([](tmp_Roles_4, sellerEmail), SELLER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(sellerEmail, dom(tmp_T_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail3'
    [EVAL] Found in sigma: "seller@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_3
    [EVAL] Found in sigma: {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Map expr evaluated: {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "seller@example.com"
    [EVAL] Set: {"seller@example.com"}
    [EVAL] Element: "seller@example.com"
    [EVAL] Set: {"seller@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_4, sellerEmail), SELLER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_4
    [EVAL] Found in sigma: {seller@example.com -> "Seller"}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail3'
    [EVAL] Found in sigma: "seller@example.com"
    [EVAL] Map expr evaluated: {seller@example.com -> "Seller"}
    [EVAL] Key expr evaluated: "seller@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "Seller"
  [EVAL] Var lookup: SELLER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "Seller" SELLER)
    [EVAL] FuncCall result: AND(true, (= "Seller" SELLER))
[ASSUME] Adding constraint: AND(true, (= "Seller" SELLER))
[SEE] API call 'createProduct' ready for actual execution

[ASSIGN] Evaluating: _result3 := createProduct(sellerEmail, title, description, category, price, quantity)
[SEE] Mapping base name '_result' -> '_result3'
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail3'
    [EVAL] Found in sigma: "seller@example.com"
  [EVAL] Var lookup: title
    [EVAL] Resolved base name 'title' -> 'title3'
    [EVAL] Found in sigma: "Test Product"
  [EVAL] Var lookup: description
    [EVAL] Resolved base name 'description' -> 'description3'
    [EVAL] Found in sigma: "A great test product description"
  [EVAL] Var lookup: category
    [EVAL] Resolved base name 'category' -> 'category3'
    [EVAL] Found in sigma: "Electronics"
  [EVAL] Var lookup: price
    [EVAL] Resolved base name 'price' -> 'price3'
    [EVAL] Found in sigma: 99
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity3'
    [EVAL] Found in sigma: 2
[API_CALL] Executing API function: createProduct
  [API_ARG] "seller@example.com"
  [API_ARG] "Test Product"
  [API_ARG] "A great test product description"
  [API_ARG] "Electronics"
  [API_ARG] 99
  [API_ARG] 2
  [API_CALL] Getting function from factory...
[Factory] Creating function: createProduct
  [API_CALL] Executing function...
[CreateProductFunc] seller@example.com creating product: Test Product
[HttpClient] POST /api/products -> 201
[CreateProductFunc] Product created: 696caf2909fc7fa2c06c2629
  [API_CALL] Function returned: "696caf2909fc7fa2c06c2629"
  [API_CALL] Storing result in variable: _result3
[ASSIGN] Result: _result3 := "696caf2909fc7fa2c06c2629"
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_3 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_3'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product"}
  [API_CALL] Storing result in variable: tmp_P_3
[ASSIGN] Result: tmp_P_3 := {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product"}
[SEE] API call 'get_Sellers' ready for actual execution

[ASSIGN] Evaluating: tmp_Sellers_3 := get_Sellers()
[SEE] Mapping base name 'tmp_Sellers_' -> 'tmp_Sellers_3'
[API_CALL] Executing API function: get_Sellers
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Sellers
  [API_CALL] Executing function...
[GetSellersFunc] Fetching Sellers...
  [API_CALL] Function returned: {696caf2909fc7fa2c06c261d -> "seller@example.com", 696caf2909fc7fa2c06c2629 -> "seller@example.com"}
  [API_CALL] Storing result in variable: tmp_Sellers_3
[ASSIGN] Result: tmp_Sellers_3 := {696caf2909fc7fa2c06c261d -> "seller@example.com", 696caf2909fc7fa2c06c2629 -> "seller@example.com"}

[ASSERT] Evaluating: AND(in(_result3, dom(tmp_P_3)), =([](tmp_Sellers_3, _result3), sellerEmail))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(_result3, dom(tmp_P_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result3
    [EVAL] Found in sigma: "696caf2909fc7fa2c06c2629"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_P_3
    [EVAL] Found in sigma: {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product"}
    [EVAL] Map expr evaluated: {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product"}
    [EVAL] Domain has 2 keys
    [EVAL] Element: "696caf2909fc7fa2c06c261d"
    [EVAL] Element: "696caf2909fc7fa2c06c2629"
    [EVAL] Set: {"696caf2909fc7fa2c06c261d", "696caf2909fc7fa2c06c2629"}
    [EVAL] Element: "696caf2909fc7fa2c06c2629"
    [EVAL] Set: {"696caf2909fc7fa2c06c261d", "696caf2909fc7fa2c06c2629"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Sellers_3, _result3), sellerEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Sellers_3
    [EVAL] Found in sigma: {696caf2909fc7fa2c06c261d -> "seller@example.com", 696caf2909fc7fa2c06c2629 -> "seller@example.com"}
  [EVAL] Var lookup: _result3
    [EVAL] Found in sigma: "696caf2909fc7fa2c06c2629"
    [EVAL] Map expr evaluated: {696caf2909fc7fa2c06c261d -> "seller@example.com", 696caf2909fc7fa2c06c2629 -> "seller@example.com"}
    [EVAL] Key expr evaluated: "696caf2909fc7fa2c06c2629"
    [EVAL] Key found in map, returning value
  [EVAL] String: "seller@example.com"
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail3'
    [EVAL] Found in sigma: "seller@example.com"
    [EVAL] Eq result: true
    [EVAL] Arg[1] result: true
    [EVAL] FuncCall result: AND(...) = true
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[ASSIGN] Evaluating: sellerEmail4 := "seller@example.com"
[SEE] Mapping base name 'sellerEmail' -> 'sellerEmail4'
  [EVAL] String: "seller@example.com"
[ASSIGN] Result: sellerEmail4 := "seller@example.com"

[ASSIGN] Evaluating: title4 := "Test Product"
[SEE] Mapping base name 'title' -> 'title4'
  [EVAL] String: "Test Product"
[ASSIGN] Result: title4 := "Test Product"

[ASSIGN] Evaluating: description4 := "A great test product description"
[SEE] Mapping base name 'description' -> 'description4'
  [EVAL] String: "A great test product description"
[ASSIGN] Result: description4 := "A great test product description"

[ASSIGN] Evaluating: category4 := "Electronics"
[SEE] Mapping base name 'category' -> 'category4'
  [EVAL] String: "Electronics"
[ASSIGN] Result: category4 := "Electronics"

[ASSIGN] Evaluating: price4 := 99
[SEE] Mapping base name 'price' -> 'price4'
  [EVAL] Num: 99
[ASSIGN] Result: price4 := 99

[ASSIGN] Evaluating: quantity4 := 2
[SEE] Mapping base name 'quantity' -> 'quantity4'
  [EVAL] Num: 2
[ASSIGN] Result: quantity4 := 2
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_4 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_4'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product"}
  [API_CALL] Storing result in variable: tmp_P_4
[ASSIGN] Result: tmp_P_4 := {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product"}

[ASSIGN] Evaluating: P_old := tmp_P_4
  [EVAL] Var lookup: tmp_P_4
    [EVAL] Found in sigma: {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product"}
[ASSIGN] Result: P_old := {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product"}
[SEE] API call 'get_Sellers' ready for actual execution

[ASSIGN] Evaluating: tmp_Sellers_4 := get_Sellers()
[SEE] Mapping base name 'tmp_Sellers_' -> 'tmp_Sellers_4'
[API_CALL] Executing API function: get_Sellers
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Sellers
  [API_CALL] Executing function...
[GetSellersFunc] Fetching Sellers...
  [API_CALL] Function returned: {696caf2909fc7fa2c06c261d -> "seller@example.com", 696caf2909fc7fa2c06c2629 -> "seller@example.com"}
  [API_CALL] Storing result in variable: tmp_Sellers_4
[ASSIGN] Result: tmp_Sellers_4 := {696caf2909fc7fa2c06c261d -> "seller@example.com", 696caf2909fc7fa2c06c2629 -> "seller@example.com"}

[ASSIGN] Evaluating: Sellers_old := tmp_Sellers_4
  [EVAL] Var lookup: tmp_Sellers_4
    [EVAL] Found in sigma: {696caf2909fc7fa2c06c261d -> "seller@example.com", 696caf2909fc7fa2c06c2629 -> "seller@example.com"}
[ASSIGN] Result: Sellers_old := {696caf2909fc7fa2c06c261d -> "seller@example.com", 696caf2909fc7fa2c06c2629 -> "seller@example.com"}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_4 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_4'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
  [API_CALL] Storing result in variable: tmp_T_4
[ASSIGN] Result: tmp_T_4 := {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_5 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_5'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {seller@example.com -> "Seller"}
  [API_CALL] Storing result in variable: tmp_Roles_5
[ASSIGN] Result: tmp_Roles_5 := {seller@example.com -> "Seller"}

[ASSUME] Evaluating: AND(in(sellerEmail, dom(tmp_T_4)), =([](tmp_Roles_5, sellerEmail), SELLER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(sellerEmail, dom(tmp_T_4))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail4'
    [EVAL] Found in sigma: "seller@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_4
    [EVAL] Found in sigma: {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Map expr evaluated: {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "seller@example.com"
    [EVAL] Set: {"seller@example.com"}
    [EVAL] Element: "seller@example.com"
    [EVAL] Set: {"seller@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_5, sellerEmail), SELLER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_5
    [EVAL] Found in sigma: {seller@example.com -> "Seller"}
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail4'
    [EVAL] Found in sigma: "seller@example.com"
    [EVAL] Map expr evaluated: {seller@example.com -> "Seller"}
    [EVAL] Key expr evaluated: "seller@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "Seller"
  [EVAL] Var lookup: SELLER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "Seller" SELLER)
    [EVAL] FuncCall result: AND(true, (= "Seller" SELLER))
[ASSUME] Adding constraint: AND(true, (= "Seller" SELLER))
[SEE] API call 'createProduct' ready for actual execution

[ASSIGN] Evaluating: _result4 := createProduct(sellerEmail, title, description, category, price, quantity)
[SEE] Mapping base name '_result' -> '_result4'
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail4'
    [EVAL] Found in sigma: "seller@example.com"
  [EVAL] Var lookup: title
    [EVAL] Resolved base name 'title' -> 'title4'
    [EVAL] Found in sigma: "Test Product"
  [EVAL] Var lookup: description
    [EVAL] Resolved base name 'description' -> 'description4'
    [EVAL] Found in sigma: "A great test product description"
  [EVAL] Var lookup: category
    [EVAL] Resolved base name 'category' -> 'category4'
    [EVAL] Found in sigma: "Electronics"
  [EVAL] Var lookup: price
    [EVAL] Resolved base name 'price' -> 'price4'
    [EVAL] Found in sigma: 99
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity4'
    [EVAL] Found in sigma: 2
[API_CALL] Executing API function: createProduct
  [API_ARG] "seller@example.com"
  [API_ARG] "Test Product"
  [API_ARG] "A great test product description"
  [API_ARG] "Electronics"
  [API_ARG] 99
  [API_ARG] 2
  [API_CALL] Getting function from factory...
[Factory] Creating function: createProduct
  [API_CALL] Executing function...
[CreateProductFunc] seller@example.com creating product: Test Product
[HttpClient] POST /api/products -> 201
[CreateProductFunc] Product created: 696caf2909fc7fa2c06c2635
  [API_CALL] Function returned: "696caf2909fc7fa2c06c2635"
  [API_CALL] Storing result in variable: _result4
[ASSIGN] Result: _result4 := "696caf2909fc7fa2c06c2635"
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_5 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_5'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product", 696caf2909fc7fa2c06c2635 -> "Test Product"}
  [API_CALL] Storing result in variable: tmp_P_5
[ASSIGN] Result: tmp_P_5 := {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product", 696caf2909fc7fa2c06c2635 -> "Test Product"}
[SEE] API call 'get_Sellers' ready for actual execution

[ASSIGN] Evaluating: tmp_Sellers_5 := get_Sellers()
[SEE] Mapping base name 'tmp_Sellers_' -> 'tmp_Sellers_5'
[API_CALL] Executing API function: get_Sellers
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Sellers
  [API_CALL] Executing function...
[GetSellersFunc] Fetching Sellers...
  [API_CALL] Function returned: {696caf2909fc7fa2c06c261d -> "seller@example.com", 696caf2909fc7fa2c06c2629 -> "seller@example.com", 696caf2909fc7fa2c06c2635 -> "seller@example.com"}
  [API_CALL] Storing result in variable: tmp_Sellers_5
[ASSIGN] Result: tmp_Sellers_5 := {696caf2909fc7fa2c06c261d -> "seller@example.com", 696caf2909fc7fa2c06c2629 -> "seller@example.com", 696caf2909fc7fa2c06c2635 -> "seller@example.com"}

[ASSERT] Evaluating: AND(in(_result4, dom(tmp_P_5)), =([](tmp_Sellers_5, _result4), sellerEmail))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(_result4, dom(tmp_P_5))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result4
    [EVAL] Found in sigma: "696caf2909fc7fa2c06c2635"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_P_5
    [EVAL] Found in sigma: {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product", 696caf2909fc7fa2c06c2635 -> "Test Product"}
    [EVAL] Map expr evaluated: {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product", 696caf2909fc7fa2c06c2635 -> "Test Product"}
    [EVAL] Domain has 3 keys
    [EVAL] Element: "696caf2909fc7fa2c06c261d"
    [EVAL] Element: "696caf2909fc7fa2c06c2629"
    [EVAL] Element: "696caf2909fc7fa2c06c2635"
    [EVAL] Set: {"696caf2909fc7fa2c06c261d", "696caf2909fc7fa2c06c2629", "696caf2909fc7fa2c06c2635"}
    [EVAL] Element: "696caf2909fc7fa2c06c2635"
    [EVAL] Set: {"696caf2909fc7fa2c06c261d", "696caf2909fc7fa2c06c2629", "696caf2909fc7fa2c06c2635"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Sellers_5, _result4), sellerEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Sellers_5
    [EVAL] Found in sigma: {696caf2909fc7fa2c06c261d -> "seller@example.com", 696caf2909fc7fa2c06c2629 -> "seller@example.com", 696caf2909fc7fa2c06c2635 -> "seller@example.com"}
  [EVAL] Var lookup: _result4
    [EVAL] Found in sigma: "696caf2909fc7fa2c06c2635"
    [EVAL] Map expr evaluated: {696caf2909fc7fa2c06c261d -> "seller@example.com", 696caf2909fc7fa2c06c2629 -> "seller@example.com", 696caf2909fc7fa2c06c2635 -> "seller@example.com"}
    [EVAL] Key expr evaluated: "696caf2909fc7fa2c06c2635"
    [EVAL] Key found in map, returning value
  [EVAL] String: "seller@example.com"
  [EVAL] Var lookup: sellerEmail
    [EVAL] Resolved base name 'sellerEmail' -> 'sellerEmail4'
    [EVAL] Found in sigma: "seller@example.com"
    [EVAL] Eq result: true
    [EVAL] Arg[1] result: true
    [EVAL] FuncCall result: AND(...) = true
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[ASSIGN] Evaluating: buyerEmail5 := "buyer@example.com"
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail5'
  [EVAL] String: "buyer@example.com"
[ASSIGN] Result: buyerEmail5 := "buyer@example.com"

[ASSIGN] Evaluating: buyerPassword5 := "BuyerPass123!"
[SEE] Mapping base name 'buyerPassword' -> 'buyerPassword5'
  [EVAL] String: "BuyerPass123!"
[ASSIGN] Result: buyerPassword5 := "BuyerPass123!"

[ASSIGN] Evaluating: buyerFullName5 := "Test Buyer"
[SEE] Mapping base name 'buyerFullName' -> 'buyerFullName5'
  [EVAL] String: "Test Buyer"
[ASSIGN] Result: buyerFullName5 := "Test Buyer"
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_6 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_6'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {seller@example.com -> "Seller"}
  [API_CALL] Storing result in variable: tmp_Roles_6
[ASSIGN] Result: tmp_Roles_6 := {seller@example.com -> "Seller"}

[ASSIGN] Evaluating: Roles_old := tmp_Roles_6
  [EVAL] Var lookup: tmp_Roles_6
    [EVAL] Found in sigma: {seller@example.com -> "Seller"}
[ASSIGN] Result: Roles_old := {seller@example.com -> "Seller"}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_5 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_5'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {seller@example.com -> "SellerPass123!"}
  [API_CALL] Storing result in variable: tmp_U_5
[ASSIGN] Result: tmp_U_5 := {seller@example.com -> "SellerPass123!"}

[ASSIGN] Evaluating: U_old := tmp_U_5
  [EVAL] Var lookup: tmp_U_5
    [EVAL] Found in sigma: {seller@example.com -> "SellerPass123!"}
[ASSIGN] Result: U_old := {seller@example.com -> "SellerPass123!"}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_6 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_6'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {seller@example.com -> "SellerPass123!"}
  [API_CALL] Storing result in variable: tmp_U_6
[ASSIGN] Result: tmp_U_6 := {seller@example.com -> "SellerPass123!"}

[ASSUME] Evaluating: not_in(buyerEmail, dom(tmp_U_6))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail5'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_6
    [EVAL] Found in sigma: {seller@example.com -> "SellerPass123!"}
    [EVAL] Map expr evaluated: {seller@example.com -> "SellerPass123!"}
    [EVAL] Domain has 1 keys
    [EVAL] Element: "seller@example.com"
    [EVAL] Set: {"seller@example.com"}
    [EVAL] not_in result: true (element not found)
[ASSUME] Adding constraint: true
[SEE] API call 'registerBuyer' ready for actual execution

[ASSIGN] Evaluating: _result5 := registerBuyer(buyerEmail, buyerPassword, buyerFullName)
[SEE] Mapping base name '_result' -> '_result5'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail5'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword5'
    [EVAL] Found in sigma: "BuyerPass123!"
  [EVAL] Var lookup: buyerFullName
    [EVAL] Resolved base name 'buyerFullName' -> 'buyerFullName5'
    [EVAL] Found in sigma: "Test Buyer"
[API_CALL] Executing API function: registerBuyer
  [API_ARG] "buyer@example.com"
  [API_ARG] "BuyerPass123!"
  [API_ARG] "Test Buyer"
  [API_CALL] Getting function from factory...
[Factory] Creating function: registerBuyer
  [API_CALL] Executing function...
[RegisterBuyerFunc] Registering buyer: buyer@example.com
[HttpClient] POST /api/auth/register -> 201
  [API_CALL] Function returned: 201
  [API_CALL] Storing result in variable: _result5
[ASSIGN] Result: _result5 := 201
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_7 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_7'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {buyer@example.com -> "BuyerPass123!", seller@example.com -> "SellerPass123!"}
  [API_CALL] Storing result in variable: tmp_U_7
[ASSIGN] Result: tmp_U_7 := {buyer@example.com -> "BuyerPass123!", seller@example.com -> "SellerPass123!"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_7 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_7'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
  [API_CALL] Storing result in variable: tmp_Roles_7
[ASSIGN] Result: tmp_Roles_7 := {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}

[ASSERT] Evaluating: AND(=([](tmp_U_7, buyerEmail), buyerPassword), =([](tmp_Roles_7, buyerEmail), BUYER))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: =([](tmp_U_7, buyerEmail), buyerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_7
    [EVAL] Found in sigma: {buyer@example.com -> "BuyerPass123!", seller@example.com -> "SellerPass123!"}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail5'
    [EVAL] Found in sigma: "buyer@example.com"
    [EVAL] Map expr evaluated: {buyer@example.com -> "BuyerPass123!", seller@example.com -> "SellerPass123!"}
    [EVAL] Key expr evaluated: "buyer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "BuyerPass123!"
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword5'
    [EVAL] Found in sigma: "BuyerPass123!"
    [EVAL] Eq result: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_7, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_7
    [EVAL] Found in sigma: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail5'
    [EVAL] Found in sigma: "buyer@example.com"
    [EVAL] Map expr evaluated: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
    [EVAL] Key expr evaluated: "buyer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "Buyer"
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "Buyer" BUYER)
    [EVAL] FuncCall result: AND(true, (= "Buyer" BUYER))
[ASSERT] Result: AND(true, (= "Buyer" BUYER))
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: buyerEmail6 := "buyer@example.com"
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail6'
  [EVAL] String: "buyer@example.com"
[ASSIGN] Result: buyerEmail6 := "buyer@example.com"

[ASSIGN] Evaluating: buyerPassword6 := "BuyerPass123!"
[SEE] Mapping base name 'buyerPassword' -> 'buyerPassword6'
  [EVAL] String: "BuyerPass123!"
[ASSIGN] Result: buyerPassword6 := "BuyerPass123!"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_5 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_5'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
  [API_CALL] Storing result in variable: tmp_T_5
[ASSIGN] Result: tmp_T_5 := {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}

[ASSIGN] Evaluating: T_old := tmp_T_5
  [EVAL] Var lookup: tmp_T_5
    [EVAL] Found in sigma: {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
[ASSIGN] Result: T_old := {seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_8 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_8'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {buyer@example.com -> "BuyerPass123!", seller@example.com -> "SellerPass123!"}
  [API_CALL] Storing result in variable: tmp_U_8
[ASSIGN] Result: tmp_U_8 := {buyer@example.com -> "BuyerPass123!", seller@example.com -> "SellerPass123!"}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_9 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_9'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {buyer@example.com -> "BuyerPass123!", seller@example.com -> "SellerPass123!"}
  [API_CALL] Storing result in variable: tmp_U_9
[ASSIGN] Result: tmp_U_9 := {buyer@example.com -> "BuyerPass123!", seller@example.com -> "SellerPass123!"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_8 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_8'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
  [API_CALL] Storing result in variable: tmp_Roles_8
[ASSIGN] Result: tmp_Roles_8 := {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_U_8)), =([](tmp_U_9, buyerEmail), buyerPassword), =([](tmp_Roles_8, buyerEmail), BUYER))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_U_8))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail6'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_8
    [EVAL] Found in sigma: {buyer@example.com -> "BuyerPass123!", seller@example.com -> "SellerPass123!"}
    [EVAL] Map expr evaluated: {buyer@example.com -> "BuyerPass123!", seller@example.com -> "SellerPass123!"}
    [EVAL] Domain has 2 keys
    [EVAL] Element: "buyer@example.com"
    [EVAL] Element: "seller@example.com"
    [EVAL] Set: {"buyer@example.com", "seller@example.com"}
    [EVAL] Element: "buyer@example.com"
    [EVAL] Set: {"buyer@example.com", "seller@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_U_9, buyerEmail), buyerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_9
    [EVAL] Found in sigma: {buyer@example.com -> "BuyerPass123!", seller@example.com -> "SellerPass123!"}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail6'
    [EVAL] Found in sigma: "buyer@example.com"
    [EVAL] Map expr evaluated: {buyer@example.com -> "BuyerPass123!", seller@example.com -> "SellerPass123!"}
    [EVAL] Key expr evaluated: "buyer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "BuyerPass123!"
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword6'
    [EVAL] Found in sigma: "BuyerPass123!"
    [EVAL] Eq result: true
    [EVAL] Arg[1] result: true
    [EVAL] Arg[2]: =([](tmp_Roles_8, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_8
    [EVAL] Found in sigma: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail6'
    [EVAL] Found in sigma: "buyer@example.com"
    [EVAL] Map expr evaluated: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
    [EVAL] Key expr evaluated: "buyer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "Buyer"
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[2] result: (= "Buyer" BUYER)
    [EVAL] FuncCall result: AND(true, true, (= "Buyer" BUYER))
[ASSUME] Adding constraint: AND(true, true, (= "Buyer" BUYER))
[SEE] API call 'login' ready for actual execution

[ASSIGN] Evaluating: _result6 := login(buyerEmail, buyerPassword)
[SEE] Mapping base name '_result' -> '_result6'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail6'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword6'
    [EVAL] Found in sigma: "BuyerPass123!"
[API_CALL] Executing API function: login
  [API_ARG] "buyer@example.com"
  [API_ARG] "BuyerPass123!"
  [API_CALL] Getting function from factory...
[Factory] Creating function: login
  [API_CALL] Executing function...
[LoginFunc] Logging in: buyer@example.com
[HttpClient] POST /api/auth/login -> 200
[LoginFunc] Token received for: buyer@example.com
  [API_CALL] Function returned: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg"
  [API_CALL] Storing result in variable: _result6
[ASSIGN] Result: _result6 := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg"
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_6 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_6'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
  [API_CALL] Storing result in variable: tmp_T_6
[ASSIGN] Result: tmp_T_6 := {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}

[ASSERT] Evaluating: =([](tmp_T_6, buyerEmail), _result6)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_T_6
    [EVAL] Found in sigma: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail6'
    [EVAL] Found in sigma: "buyer@example.com"
    [EVAL] Map expr evaluated: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Key expr evaluated: "buyer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg"
  [EVAL] Var lookup: _result6
    [EVAL] Found in sigma: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg"
    [EVAL] Eq result: true
[ASSERT] Result: true
[ASSERT] ✓ Assertion PASSED

[ASSUME] Evaluating: 1
  [EVAL] Num: 1
[ASSUME] Adding constraint: 1
[SEE] API call 'getAllProducts' ready for actual execution

[ASSIGN] Evaluating: _result7 := getAllProducts()
[SEE] Mapping base name '_result' -> '_result7'
[API_CALL] Executing API function: getAllProducts
  [API_CALL] Getting function from factory...
[Factory] Creating function: getAllProducts
  [API_CALL] Executing function...
[GetAllProductsFunc] Fetching all products...
[GetAllProductsFunc] Found 3 products
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _result7
[ASSIGN] Result: _result7 := 200

[ASSERT] Empty assertion, PASSED

[ASSIGN] Evaluating: buyerEmail8 := "buyer@example.com"
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail8'
  [EVAL] String: "buyer@example.com"
[ASSIGN] Result: buyerEmail8 := "buyer@example.com"

[ASSIGN] Evaluating: productId8 := "__NEEDS_PRODUCT_ID__"
[SEE] Mapping base name 'productId' -> 'productId8'
  [EVAL] String: "__NEEDS_PRODUCT_ID__"
[ASSIGN] Result: productId8 := "__NEEDS_PRODUCT_ID__"

[ASSIGN] Evaluating: quantity8 := 2
[SEE] Mapping base name 'quantity' -> 'quantity8'
  [EVAL] Num: 2
[ASSIGN] Result: quantity8 := 2
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_0 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_0'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_0
[ASSIGN] Result: tmp_C_0 := {}

[ASSIGN] Evaluating: C_old := tmp_C_0
  [EVAL] Var lookup: tmp_C_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: C_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_7 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_7'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
  [API_CALL] Storing result in variable: tmp_T_7
[ASSIGN] Result: tmp_T_7 := {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_9 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_9'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
  [API_CALL] Storing result in variable: tmp_Roles_9
[ASSIGN] Result: tmp_Roles_9 := {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_6 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_6'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product", 696caf2909fc7fa2c06c2635 -> "Test Product"}
  [API_CALL] Storing result in variable: tmp_P_6
[ASSIGN] Result: tmp_P_6 := {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product", 696caf2909fc7fa2c06c2635 -> "Test Product"}

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_T_7)), =([](tmp_Roles_9, buyerEmail), BUYER), in(productId, dom(tmp_P_6)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_T_7))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail8'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_7
    [EVAL] Found in sigma: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Map expr evaluated: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Domain has 2 keys
    [EVAL] Element: "buyer@example.com"
    [EVAL] Element: "seller@example.com"
    [EVAL] Set: {"buyer@example.com", "seller@example.com"}
    [EVAL] Element: "buyer@example.com"
    [EVAL] Set: {"buyer@example.com", "seller@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_9, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_9
    [EVAL] Found in sigma: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail8'
    [EVAL] Found in sigma: "buyer@example.com"
    [EVAL] Map expr evaluated: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
    [EVAL] Key expr evaluated: "buyer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "Buyer"
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "Buyer" BUYER)
    [EVAL] Arg[2]: in(productId, dom(tmp_P_6))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: productId
    [EVAL] Resolved base name 'productId' -> 'productId8'
    [EVAL] Found in sigma: "__NEEDS_PRODUCT_ID__"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_P_6
    [EVAL] Found in sigma: {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product", 696caf2909fc7fa2c06c2635 -> "Test Product"}
    [EVAL] Map expr evaluated: {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product", 696caf2909fc7fa2c06c2635 -> "Test Product"}
    [EVAL] Domain has 3 keys
    [EVAL] Element: "696caf2909fc7fa2c06c261d"
    [EVAL] Element: "696caf2909fc7fa2c06c2629"
    [EVAL] Element: "696caf2909fc7fa2c06c2635"
    [EVAL] Set: {"696caf2909fc7fa2c06c261d", "696caf2909fc7fa2c06c2629", "696caf2909fc7fa2c06c2635"}
    [EVAL] Element: "__NEEDS_PRODUCT_ID__"
    [EVAL] Set: {"696caf2909fc7fa2c06c261d", "696caf2909fc7fa2c06c2629", "696caf2909fc7fa2c06c2635"}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'addToCart' ready for actual execution

[ASSIGN] Evaluating: _result8 := addToCart(buyerEmail, productId, quantity)
[SEE] Mapping base name '_result' -> '_result8'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail8'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] Var lookup: productId
    [EVAL] Resolved base name 'productId' -> 'productId8'
    [EVAL] Found in sigma: "__NEEDS_PRODUCT_ID__"
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity8'
    [EVAL] Found in sigma: 2
[API_CALL] Executing API function: addToCart
  [API_ARG] "buyer@example.com"
  [API_ARG] "__NEEDS_PRODUCT_ID__"
  [API_ARG] 2
  [API_CALL] Getting function from factory...
[Factory] Creating function: addToCart
  [API_CALL] Executing function...
[AddToCartFunc] buyer@example.com adding product __NEEDS_PRODUCT_ID__ (qty: 2)
[HttpClient] POST /api/cart/add -> 500
  [API_CALL] Function returned: ""
  [API_CALL] Storing result in variable: _result8
[ASSIGN] Result: _result8 := ""
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_1 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_1'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_1
[ASSIGN] Result: tmp_C_1 := {}

[ASSERT] Evaluating: in(buyerEmail, dom(tmp_C_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail8'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: "buyer@example.com"
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: buyerEmail9 := "buyer@example.com"
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail9'
  [EVAL] String: "buyer@example.com"
[ASSIGN] Result: buyerEmail9 := "buyer@example.com"

[ASSIGN] Evaluating: productId9 := "__NEEDS_PRODUCT_ID__"
[SEE] Mapping base name 'productId' -> 'productId9'
  [EVAL] String: "__NEEDS_PRODUCT_ID__"
[ASSIGN] Result: productId9 := "__NEEDS_PRODUCT_ID__"

[ASSIGN] Evaluating: quantity9 := 2
[SEE] Mapping base name 'quantity' -> 'quantity9'
  [EVAL] Num: 2
[ASSIGN] Result: quantity9 := 2
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_2 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_2'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_2
[ASSIGN] Result: tmp_C_2 := {}

[ASSIGN] Evaluating: C_old := tmp_C_2
  [EVAL] Var lookup: tmp_C_2
    [EVAL] Found in sigma: {}
[ASSIGN] Result: C_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_8 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_8'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
  [API_CALL] Storing result in variable: tmp_T_8
[ASSIGN] Result: tmp_T_8 := {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_10 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_10'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
  [API_CALL] Storing result in variable: tmp_Roles_10
[ASSIGN] Result: tmp_Roles_10 := {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_7 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_7'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product", 696caf2909fc7fa2c06c2635 -> "Test Product"}
  [API_CALL] Storing result in variable: tmp_P_7
[ASSIGN] Result: tmp_P_7 := {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product", 696caf2909fc7fa2c06c2635 -> "Test Product"}

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_T_8)), =([](tmp_Roles_10, buyerEmail), BUYER), in(productId, dom(tmp_P_7)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_T_8))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail9'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_8
    [EVAL] Found in sigma: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Map expr evaluated: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Domain has 2 keys
    [EVAL] Element: "buyer@example.com"
    [EVAL] Element: "seller@example.com"
    [EVAL] Set: {"buyer@example.com", "seller@example.com"}
    [EVAL] Element: "buyer@example.com"
    [EVAL] Set: {"buyer@example.com", "seller@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_10, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_10
    [EVAL] Found in sigma: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail9'
    [EVAL] Found in sigma: "buyer@example.com"
    [EVAL] Map expr evaluated: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
    [EVAL] Key expr evaluated: "buyer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "Buyer"
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "Buyer" BUYER)
    [EVAL] Arg[2]: in(productId, dom(tmp_P_7))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: productId
    [EVAL] Resolved base name 'productId' -> 'productId9'
    [EVAL] Found in sigma: "__NEEDS_PRODUCT_ID__"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_P_7
    [EVAL] Found in sigma: {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product", 696caf2909fc7fa2c06c2635 -> "Test Product"}
    [EVAL] Map expr evaluated: {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product", 696caf2909fc7fa2c06c2635 -> "Test Product"}
    [EVAL] Domain has 3 keys
    [EVAL] Element: "696caf2909fc7fa2c06c261d"
    [EVAL] Element: "696caf2909fc7fa2c06c2629"
    [EVAL] Element: "696caf2909fc7fa2c06c2635"
    [EVAL] Set: {"696caf2909fc7fa2c06c261d", "696caf2909fc7fa2c06c2629", "696caf2909fc7fa2c06c2635"}
    [EVAL] Element: "__NEEDS_PRODUCT_ID__"
    [EVAL] Set: {"696caf2909fc7fa2c06c261d", "696caf2909fc7fa2c06c2629", "696caf2909fc7fa2c06c2635"}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'addToCart' ready for actual execution

[ASSIGN] Evaluating: _result9 := addToCart(buyerEmail, productId, quantity)
[SEE] Mapping base name '_result' -> '_result9'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail9'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] Var lookup: productId
    [EVAL] Resolved base name 'productId' -> 'productId9'
    [EVAL] Found in sigma: "__NEEDS_PRODUCT_ID__"
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity9'
    [EVAL] Found in sigma: 2
[API_CALL] Executing API function: addToCart
  [API_ARG] "buyer@example.com"
  [API_ARG] "__NEEDS_PRODUCT_ID__"
  [API_ARG] 2
  [API_CALL] Getting function from factory...
[Factory] Creating function: addToCart
  [API_CALL] Executing function...
[AddToCartFunc] buyer@example.com adding product __NEEDS_PRODUCT_ID__ (qty: 2)
[HttpClient] POST /api/cart/add -> 500
  [API_CALL] Function returned: ""
  [API_CALL] Storing result in variable: _result9
[ASSIGN] Result: _result9 := ""
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_3 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_3'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_3
[ASSIGN] Result: tmp_C_3 := {}

[ASSERT] Evaluating: in(buyerEmail, dom(tmp_C_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail9'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: "buyer@example.com"
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: buyerEmail10 := "buyer@example.com"
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail10'
  [EVAL] String: "buyer@example.com"
[ASSIGN] Result: buyerEmail10 := "buyer@example.com"

[ASSIGN] Evaluating: shippingAddress10 := "123 Test St,Test City,TS,12345,USA"
[SEE] Mapping base name 'shippingAddress' -> 'shippingAddress10'
  [EVAL] String: "123 Test St,Test City,TS,12345,USA"
[ASSIGN] Result: shippingAddress10 := "123 Test St,Test City,TS,12345,USA"

[ASSIGN] Evaluating: paymentMethod10 := "card"
[SEE] Mapping base name 'paymentMethod' -> 'paymentMethod10'
  [EVAL] String: "card"
[ASSIGN] Result: paymentMethod10 := "card"
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_4 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_4'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_4
[ASSIGN] Result: tmp_C_4 := {}

[ASSIGN] Evaluating: C_old := tmp_C_4
  [EVAL] Var lookup: tmp_C_4
    [EVAL] Found in sigma: {}
[ASSIGN] Result: C_old := {}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_0 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_0'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O (Orders)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_0
[ASSIGN] Result: tmp_O_0 := {}

[ASSIGN] Evaluating: O_old := tmp_O_0
  [EVAL] Var lookup: tmp_O_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: O_old := {}
[SEE] API call 'get_OrderStatus' ready for actual execution

[ASSIGN] Evaluating: tmp_OrderStatus_0 := get_OrderStatus()
[SEE] Mapping base name 'tmp_OrderStatus_' -> 'tmp_OrderStatus_0'
[API_CALL] Executing API function: get_OrderStatus
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_OrderStatus
  [API_CALL] Executing function...
[GetOrderStatusFunc] Fetching OrderStatus...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_OrderStatus_0
[ASSIGN] Result: tmp_OrderStatus_0 := {}

[ASSIGN] Evaluating: OrderStatus_old := tmp_OrderStatus_0
  [EVAL] Var lookup: tmp_OrderStatus_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: OrderStatus_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_9 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_9'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
  [API_CALL] Storing result in variable: tmp_T_9
[ASSIGN] Result: tmp_T_9 := {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_11 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_11'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
  [API_CALL] Storing result in variable: tmp_Roles_11
[ASSIGN] Result: tmp_Roles_11 := {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_5 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_5'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_5
[ASSIGN] Result: tmp_C_5 := {}

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_T_9)), =([](tmp_Roles_11, buyerEmail), BUYER), in(buyerEmail, dom(tmp_C_5)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_T_9))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail10'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_9
    [EVAL] Found in sigma: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Map expr evaluated: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Domain has 2 keys
    [EVAL] Element: "buyer@example.com"
    [EVAL] Element: "seller@example.com"
    [EVAL] Set: {"buyer@example.com", "seller@example.com"}
    [EVAL] Element: "buyer@example.com"
    [EVAL] Set: {"buyer@example.com", "seller@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_11, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_11
    [EVAL] Found in sigma: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail10'
    [EVAL] Found in sigma: "buyer@example.com"
    [EVAL] Map expr evaluated: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
    [EVAL] Key expr evaluated: "buyer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "Buyer"
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "Buyer" BUYER)
    [EVAL] Arg[2]: in(buyerEmail, dom(tmp_C_5))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail10'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_5
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: "buyer@example.com"
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'createOrder' ready for actual execution

[ASSIGN] Evaluating: _result10 := createOrder(buyerEmail, shippingAddress, paymentMethod)
[SEE] Mapping base name '_result' -> '_result10'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail10'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] Var lookup: shippingAddress
    [EVAL] Resolved base name 'shippingAddress' -> 'shippingAddress10'
    [EVAL] Found in sigma: "123 Test St,Test City,TS,12345,USA"
  [EVAL] Var lookup: paymentMethod
    [EVAL] Resolved base name 'paymentMethod' -> 'paymentMethod10'
    [EVAL] Found in sigma: "card"
[API_CALL] Executing API function: createOrder
  [API_ARG] "buyer@example.com"
  [API_ARG] "123 Test St,Test City,TS,12345,USA"
  [API_ARG] "card"
  [API_CALL] Getting function from factory...
[Factory] Creating function: createOrder
  [API_CALL] Executing function...
[CreateOrderFunc] buyer@example.com placing order...
[HttpClient] POST /api/orders -> 400
[CreateOrderFunc] Error response: {"error":"Cart is empty"}
  [API_CALL] Function returned: ""
  [API_CALL] Storing result in variable: _result10
[ASSIGN] Result: _result10 := ""
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_1 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_1'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O (Orders)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_1
[ASSIGN] Result: tmp_O_1 := {}
[SEE] API call 'get_OrderStatus' ready for actual execution

[ASSIGN] Evaluating: tmp_OrderStatus_1 := get_OrderStatus()
[SEE] Mapping base name 'tmp_OrderStatus_' -> 'tmp_OrderStatus_1'
[API_CALL] Executing API function: get_OrderStatus
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_OrderStatus
  [API_CALL] Executing function...
[GetOrderStatusFunc] Fetching OrderStatus...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_OrderStatus_1
[ASSIGN] Result: tmp_OrderStatus_1 := {}
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_6 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_6'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_6
[ASSIGN] Result: tmp_C_6 := {}

[ASSERT] Evaluating: AND(in(_result10, dom(tmp_O_1)), =([](tmp_OrderStatus_1, _result10), PENDING), not_in(buyerEmail, dom(tmp_C_6)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(_result10, dom(tmp_O_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result10
    [EVAL] Found in sigma: ""
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: ""
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_OrderStatus_1, _result10), PENDING)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_OrderStatus_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: _result10
    [EVAL] Found in sigma: ""
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: ""
    [EVAL] Key not found in map
  [EVAL] Var lookup: PENDING
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, "") PENDING)
    [EVAL] Arg[2]: not_in(buyerEmail, dom(tmp_C_6))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail10'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_6
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
    [EVAL] Arg[2] result: true
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: buyerEmail11 := "buyer@example.com"
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail11'
  [EVAL] String: "buyer@example.com"
[ASSIGN] Result: buyerEmail11 := "buyer@example.com"

[ASSIGN] Evaluating: productId11 := "__NEEDS_PRODUCT_ID__"
[SEE] Mapping base name 'productId' -> 'productId11'
  [EVAL] String: "__NEEDS_PRODUCT_ID__"
[ASSIGN] Result: productId11 := "__NEEDS_PRODUCT_ID__"

[ASSIGN] Evaluating: orderId11 := "__NEEDS_ORDER_ID__"
[SEE] Mapping base name 'orderId' -> 'orderId11'
  [EVAL] String: "__NEEDS_ORDER_ID__"
[ASSIGN] Result: orderId11 := "__NEEDS_ORDER_ID__"

[ASSIGN] Evaluating: rating11 := 5
[SEE] Mapping base name 'rating' -> 'rating11'
  [EVAL] Num: 5
[ASSIGN] Result: rating11 := 5

[ASSIGN] Evaluating: comment11 := "Great product, highly recommend!"
[SEE] Mapping base name 'comment' -> 'comment11'
  [EVAL] String: "Great product, highly recommend!"
[ASSIGN] Result: comment11 := "Great product, highly recommend!"
[SEE] API call 'get_Rev' ready for actual execution

[ASSIGN] Evaluating: tmp_Rev_0 := get_Rev()
[SEE] Mapping base name 'tmp_Rev_' -> 'tmp_Rev_0'
[API_CALL] Executing API function: get_Rev
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Rev
  [API_CALL] Executing function...
[GetRevFunc] Fetching Rev...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Rev_0
[ASSIGN] Result: tmp_Rev_0 := {}

[ASSIGN] Evaluating: Rev_old := tmp_Rev_0
  [EVAL] Var lookup: tmp_Rev_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Rev_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_10 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_10'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
  [API_CALL] Storing result in variable: tmp_T_10
[ASSIGN] Result: tmp_T_10 := {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_12 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_12'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
  [API_CALL] Storing result in variable: tmp_Roles_12
[ASSIGN] Result: tmp_Roles_12 := {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_2 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_2'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O (Orders)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_2
[ASSIGN] Result: tmp_O_2 := {}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_3 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_3'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O (Orders)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_3
[ASSIGN] Result: tmp_O_3 := {}

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_T_10)), =([](tmp_Roles_12, buyerEmail), BUYER), in(orderId, dom(tmp_O_2)), =([](tmp_O_3, orderId), buyerEmail))
  [EVAL] FuncCall: AND with 4 args
    [EVAL] N-ary AND with 4 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_T_10))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail11'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_10
    [EVAL] Found in sigma: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Map expr evaluated: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Domain has 2 keys
    [EVAL] Element: "buyer@example.com"
    [EVAL] Element: "seller@example.com"
    [EVAL] Set: {"buyer@example.com", "seller@example.com"}
    [EVAL] Element: "buyer@example.com"
    [EVAL] Set: {"buyer@example.com", "seller@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_12, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_12
    [EVAL] Found in sigma: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail11'
    [EVAL] Found in sigma: "buyer@example.com"
    [EVAL] Map expr evaluated: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
    [EVAL] Key expr evaluated: "buyer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "Buyer"
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "Buyer" BUYER)
    [EVAL] Arg[2]: in(orderId, dom(tmp_O_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId11'
    [EVAL] Found placeholder __NEEDS_ORDER_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_7 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [EVAL] Found in sigma: "__NEEDS_ORDER_ID__"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_2
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: "__NEEDS_ORDER_ID__"
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] Arg[3]: =([](tmp_O_3, orderId), buyerEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_O_3
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId11'
    [EVAL] Found placeholder __NEEDS_ORDER_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_7 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [EVAL] Found in sigma: "__NEEDS_ORDER_ID__"
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: "__NEEDS_ORDER_ID__"
    [EVAL] Key not found in map
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail11'
    [EVAL] Found in sigma: "buyer@example.com"
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[3] result: (= []({}, "__NEEDS_ORDER_ID__") "buyer@example.com")
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'createReview' ready for actual execution

[ASSIGN] Evaluating: _result11 := createReview(buyerEmail, productId, orderId, rating, comment)
[SEE] Mapping base name '_result' -> '_result11'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail11'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] Var lookup: productId
    [EVAL] Resolved base name 'productId' -> 'productId11'
    [EVAL] Found in sigma: "__NEEDS_PRODUCT_ID__"
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId11'
    [EVAL] Found placeholder __NEEDS_ORDER_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_7 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [EVAL] Found in sigma: "__NEEDS_ORDER_ID__"
  [EVAL] Var lookup: rating
    [EVAL] Resolved base name 'rating' -> 'rating11'
    [EVAL] Found in sigma: 5
  [EVAL] Var lookup: comment
    [EVAL] Resolved base name 'comment' -> 'comment11'
    [EVAL] Found in sigma: "Great product, highly recommend!"
[API_CALL] Executing API function: createReview
  [API_ARG] "buyer@example.com"
  [API_ARG] "__NEEDS_PRODUCT_ID__"
  [API_ARG] "__NEEDS_ORDER_ID__"
  [API_ARG] 5
  [API_ARG] "Great product, highly recommend!"
  [API_CALL] Getting function from factory...
[Factory] Creating function: createReview
  [API_CALL] Executing function...
[CreateReviewFunc] buyer@example.com reviewing product: __NEEDS_PRODUCT_ID__
[HttpClient] POST /api/reviews -> 500
[CreateReviewFunc] Error response: {"error":"Cannot read properties of undefined (reading '_id')"}
  [API_CALL] Function returned: ""
  [API_CALL] Storing result in variable: _result11
[ASSIGN] Result: _result11 := ""
[SEE] API call 'get_Rev' ready for actual execution

[ASSIGN] Evaluating: tmp_Rev_1 := get_Rev()
[SEE] Mapping base name 'tmp_Rev_' -> 'tmp_Rev_1'
[API_CALL] Executing API function: get_Rev
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Rev
  [API_CALL] Executing function...
[GetRevFunc] Fetching Rev...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Rev_1
[ASSIGN] Result: tmp_Rev_1 := {}

[ASSERT] Evaluating: in(_result11, dom(tmp_Rev_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result11
    [EVAL] Found in sigma: ""
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_Rev_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: ""
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: buyerEmail12 := "buyer@example.com"
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail12'
  [EVAL] String: "buyer@example.com"
[ASSIGN] Result: buyerEmail12 := "buyer@example.com"

[ASSIGN] Evaluating: productId12 := "__NEEDS_PRODUCT_ID__"
[SEE] Mapping base name 'productId' -> 'productId12'
  [EVAL] String: "__NEEDS_PRODUCT_ID__"
[ASSIGN] Result: productId12 := "__NEEDS_PRODUCT_ID__"

[ASSIGN] Evaluating: quantity12 := 2
[SEE] Mapping base name 'quantity' -> 'quantity12'
  [EVAL] Num: 2
[ASSIGN] Result: quantity12 := 2
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_7 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_7'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_7
[ASSIGN] Result: tmp_C_7 := {}

[ASSIGN] Evaluating: C_old := tmp_C_7
  [EVAL] Var lookup: tmp_C_7
    [EVAL] Found in sigma: {}
[ASSIGN] Result: C_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_11 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_11'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
  [API_CALL] Storing result in variable: tmp_T_11
[ASSIGN] Result: tmp_T_11 := {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_13 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_13'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
  [API_CALL] Storing result in variable: tmp_Roles_13
[ASSIGN] Result: tmp_Roles_13 := {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
[SEE] API call 'get_P' ready for actual execution

[ASSIGN] Evaluating: tmp_P_8 := get_P()
[SEE] Mapping base name 'tmp_P_' -> 'tmp_P_8'
[API_CALL] Executing API function: get_P
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_P
  [API_CALL] Executing function...
[GetPFunc] Fetching P (Products)...
  [API_CALL] Function returned: {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product", 696caf2909fc7fa2c06c2635 -> "Test Product"}
  [API_CALL] Storing result in variable: tmp_P_8
[ASSIGN] Result: tmp_P_8 := {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product", 696caf2909fc7fa2c06c2635 -> "Test Product"}

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_T_11)), =([](tmp_Roles_13, buyerEmail), BUYER), in(productId, dom(tmp_P_8)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_T_11))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail12'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_11
    [EVAL] Found in sigma: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Map expr evaluated: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Domain has 2 keys
    [EVAL] Element: "buyer@example.com"
    [EVAL] Element: "seller@example.com"
    [EVAL] Set: {"buyer@example.com", "seller@example.com"}
    [EVAL] Element: "buyer@example.com"
    [EVAL] Set: {"buyer@example.com", "seller@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_13, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_13
    [EVAL] Found in sigma: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail12'
    [EVAL] Found in sigma: "buyer@example.com"
    [EVAL] Map expr evaluated: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
    [EVAL] Key expr evaluated: "buyer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "Buyer"
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "Buyer" BUYER)
    [EVAL] Arg[2]: in(productId, dom(tmp_P_8))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: productId
    [EVAL] Resolved base name 'productId' -> 'productId12'
    [EVAL] Found in sigma: "__NEEDS_PRODUCT_ID__"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_P_8
    [EVAL] Found in sigma: {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product", 696caf2909fc7fa2c06c2635 -> "Test Product"}
    [EVAL] Map expr evaluated: {696caf2909fc7fa2c06c261d -> "Test Product", 696caf2909fc7fa2c06c2629 -> "Test Product", 696caf2909fc7fa2c06c2635 -> "Test Product"}
    [EVAL] Domain has 3 keys
    [EVAL] Element: "696caf2909fc7fa2c06c261d"
    [EVAL] Element: "696caf2909fc7fa2c06c2629"
    [EVAL] Element: "696caf2909fc7fa2c06c2635"
    [EVAL] Set: {"696caf2909fc7fa2c06c261d", "696caf2909fc7fa2c06c2629", "696caf2909fc7fa2c06c2635"}
    [EVAL] Element: "__NEEDS_PRODUCT_ID__"
    [EVAL] Set: {"696caf2909fc7fa2c06c261d", "696caf2909fc7fa2c06c2629", "696caf2909fc7fa2c06c2635"}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'addToCart' ready for actual execution

[ASSIGN] Evaluating: _result12 := addToCart(buyerEmail, productId, quantity)
[SEE] Mapping base name '_result' -> '_result12'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail12'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] Var lookup: productId
    [EVAL] Resolved base name 'productId' -> 'productId12'
    [EVAL] Found in sigma: "__NEEDS_PRODUCT_ID__"
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity12'
    [EVAL] Found in sigma: 2
[API_CALL] Executing API function: addToCart
  [API_ARG] "buyer@example.com"
  [API_ARG] "__NEEDS_PRODUCT_ID__"
  [API_ARG] 2
  [API_CALL] Getting function from factory...
[Factory] Creating function: addToCart
  [API_CALL] Executing function...
[AddToCartFunc] buyer@example.com adding product __NEEDS_PRODUCT_ID__ (qty: 2)
[HttpClient] POST /api/cart/add -> 500
  [API_CALL] Function returned: ""
  [API_CALL] Storing result in variable: _result12
[ASSIGN] Result: _result12 := ""
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_8 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_8'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_8
[ASSIGN] Result: tmp_C_8 := {}

[ASSERT] Evaluating: in(buyerEmail, dom(tmp_C_8))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail12'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_8
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: "buyer@example.com"
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: buyerEmail13 := "buyer@example.com"
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail13'
  [EVAL] String: "buyer@example.com"
[ASSIGN] Result: buyerEmail13 := "buyer@example.com"

[ASSIGN] Evaluating: shippingAddress13 := "123 Test St,Test City,TS,12345,USA"
[SEE] Mapping base name 'shippingAddress' -> 'shippingAddress13'
  [EVAL] String: "123 Test St,Test City,TS,12345,USA"
[ASSIGN] Result: shippingAddress13 := "123 Test St,Test City,TS,12345,USA"

[ASSIGN] Evaluating: paymentMethod13 := "card"
[SEE] Mapping base name 'paymentMethod' -> 'paymentMethod13'
  [EVAL] String: "card"
[ASSIGN] Result: paymentMethod13 := "card"
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_9 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_9'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_9
[ASSIGN] Result: tmp_C_9 := {}

[ASSIGN] Evaluating: C_old := tmp_C_9
  [EVAL] Var lookup: tmp_C_9
    [EVAL] Found in sigma: {}
[ASSIGN] Result: C_old := {}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_4 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_4'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O (Orders)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_4
[ASSIGN] Result: tmp_O_4 := {}

[ASSIGN] Evaluating: O_old := tmp_O_4
  [EVAL] Var lookup: tmp_O_4
    [EVAL] Found in sigma: {}
[ASSIGN] Result: O_old := {}
[SEE] API call 'get_OrderStatus' ready for actual execution

[ASSIGN] Evaluating: tmp_OrderStatus_2 := get_OrderStatus()
[SEE] Mapping base name 'tmp_OrderStatus_' -> 'tmp_OrderStatus_2'
[API_CALL] Executing API function: get_OrderStatus
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_OrderStatus
  [API_CALL] Executing function...
[GetOrderStatusFunc] Fetching OrderStatus...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_OrderStatus_2
[ASSIGN] Result: tmp_OrderStatus_2 := {}

[ASSIGN] Evaluating: OrderStatus_old := tmp_OrderStatus_2
  [EVAL] Var lookup: tmp_OrderStatus_2
    [EVAL] Found in sigma: {}
[ASSIGN] Result: OrderStatus_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_12 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_12'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
  [API_CALL] Storing result in variable: tmp_T_12
[ASSIGN] Result: tmp_T_12 := {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_14 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_14'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
  [API_CALL] Storing result in variable: tmp_Roles_14
[ASSIGN] Result: tmp_Roles_14 := {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_10 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_10'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_10
[ASSIGN] Result: tmp_C_10 := {}

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_T_12)), =([](tmp_Roles_14, buyerEmail), BUYER), in(buyerEmail, dom(tmp_C_10)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_T_12))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail13'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_12
    [EVAL] Found in sigma: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Map expr evaluated: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Domain has 2 keys
    [EVAL] Element: "buyer@example.com"
    [EVAL] Element: "seller@example.com"
    [EVAL] Set: {"buyer@example.com", "seller@example.com"}
    [EVAL] Element: "buyer@example.com"
    [EVAL] Set: {"buyer@example.com", "seller@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_14, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_14
    [EVAL] Found in sigma: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail13'
    [EVAL] Found in sigma: "buyer@example.com"
    [EVAL] Map expr evaluated: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
    [EVAL] Key expr evaluated: "buyer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "Buyer"
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "Buyer" BUYER)
    [EVAL] Arg[2]: in(buyerEmail, dom(tmp_C_10))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail13'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_10
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: "buyer@example.com"
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'createOrder' ready for actual execution

[ASSIGN] Evaluating: _result13 := createOrder(buyerEmail, shippingAddress, paymentMethod)
[SEE] Mapping base name '_result' -> '_result13'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail13'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] Var lookup: shippingAddress
    [EVAL] Resolved base name 'shippingAddress' -> 'shippingAddress13'
    [EVAL] Found in sigma: "123 Test St,Test City,TS,12345,USA"
  [EVAL] Var lookup: paymentMethod
    [EVAL] Resolved base name 'paymentMethod' -> 'paymentMethod13'
    [EVAL] Found in sigma: "card"
[API_CALL] Executing API function: createOrder
  [API_ARG] "buyer@example.com"
  [API_ARG] "123 Test St,Test City,TS,12345,USA"
  [API_ARG] "card"
  [API_CALL] Getting function from factory...
[Factory] Creating function: createOrder
  [API_CALL] Executing function...
[CreateOrderFunc] buyer@example.com placing order...
[HttpClient] POST /api/orders -> 400
[CreateOrderFunc] Error response: {"error":"Cart is empty"}
  [API_CALL] Function returned: ""
  [API_CALL] Storing result in variable: _result13
[ASSIGN] Result: _result13 := ""
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_5 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_5'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O (Orders)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_5
[ASSIGN] Result: tmp_O_5 := {}
[SEE] API call 'get_OrderStatus' ready for actual execution

[ASSIGN] Evaluating: tmp_OrderStatus_3 := get_OrderStatus()
[SEE] Mapping base name 'tmp_OrderStatus_' -> 'tmp_OrderStatus_3'
[API_CALL] Executing API function: get_OrderStatus
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_OrderStatus
  [API_CALL] Executing function...
[GetOrderStatusFunc] Fetching OrderStatus...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_OrderStatus_3
[ASSIGN] Result: tmp_OrderStatus_3 := {}
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_11 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_11'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C (Carts)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_11
[ASSIGN] Result: tmp_C_11 := {}

[ASSERT] Evaluating: AND(in(_result13, dom(tmp_O_5)), =([](tmp_OrderStatus_3, _result13), PENDING), not_in(buyerEmail, dom(tmp_C_11)))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(_result13, dom(tmp_O_5))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result13
    [EVAL] Found in sigma: ""
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_5
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: ""
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_OrderStatus_3, _result13), PENDING)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_OrderStatus_3
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: _result13
    [EVAL] Found in sigma: ""
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: ""
    [EVAL] Key not found in map
  [EVAL] Var lookup: PENDING
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, "") PENDING)
    [EVAL] Arg[2]: not_in(buyerEmail, dom(tmp_C_11))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail13'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_11
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
    [EVAL] Arg[2] result: true
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: buyerEmail14 := "buyer@example.com"
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail14'
  [EVAL] String: "buyer@example.com"
[ASSIGN] Result: buyerEmail14 := "buyer@example.com"

[ASSIGN] Evaluating: productId14 := "__NEEDS_PRODUCT_ID__"
[SEE] Mapping base name 'productId' -> 'productId14'
  [EVAL] String: "__NEEDS_PRODUCT_ID__"
[ASSIGN] Result: productId14 := "__NEEDS_PRODUCT_ID__"

[ASSIGN] Evaluating: orderId14 := "__NEEDS_ORDER_ID__"
[SEE] Mapping base name 'orderId' -> 'orderId14'
  [EVAL] String: "__NEEDS_ORDER_ID__"
[ASSIGN] Result: orderId14 := "__NEEDS_ORDER_ID__"

[ASSIGN] Evaluating: rating14 := 5
[SEE] Mapping base name 'rating' -> 'rating14'
  [EVAL] Num: 5
[ASSIGN] Result: rating14 := 5

[ASSIGN] Evaluating: comment14 := "Great product, highly recommend!"
[SEE] Mapping base name 'comment' -> 'comment14'
  [EVAL] String: "Great product, highly recommend!"
[ASSIGN] Result: comment14 := "Great product, highly recommend!"
[SEE] API call 'get_Rev' ready for actual execution

[ASSIGN] Evaluating: tmp_Rev_2 := get_Rev()
[SEE] Mapping base name 'tmp_Rev_' -> 'tmp_Rev_2'
[API_CALL] Executing API function: get_Rev
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Rev
  [API_CALL] Executing function...
[GetRevFunc] Fetching Rev...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Rev_2
[ASSIGN] Result: tmp_Rev_2 := {}

[ASSIGN] Evaluating: Rev_old := tmp_Rev_2
  [EVAL] Var lookup: tmp_Rev_2
    [EVAL] Found in sigma: {}
[ASSIGN] Result: Rev_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_13 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_13'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
  [API_CALL] Storing result in variable: tmp_T_13
[ASSIGN] Result: tmp_T_13 := {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_15 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_15'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
  [API_CALL] Storing result in variable: tmp_Roles_15
[ASSIGN] Result: tmp_Roles_15 := {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_6 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_6'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O (Orders)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_6
[ASSIGN] Result: tmp_O_6 := {}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_7 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_7'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O (Orders)...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_7
[ASSIGN] Result: tmp_O_7 := {}

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_T_13)), =([](tmp_Roles_15, buyerEmail), BUYER), in(orderId, dom(tmp_O_6)), =([](tmp_O_7, orderId), buyerEmail))
  [EVAL] FuncCall: AND with 4 args
    [EVAL] N-ary AND with 4 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_T_13))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail14'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_13
    [EVAL] Found in sigma: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Map expr evaluated: {buyer@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyOTA5ZmM3ZmEyYzA2YzI2M2YiLCJpYXQiOjE3Njg3MzA0MDksImV4cCI6MTc2ODgxNjgwOX0.RsFYlkzxxLb2i_BhPO_0I9fhXagIrFSMvgDQt_CpBzg", seller@example.com -> "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI2OTZjYWYyODA5ZmM3ZmEyYzA2YzI2MGQiLCJpYXQiOjE3Njg3MzA0MDgsImV4cCI6MTc2ODgxNjgwOH0.XsfMFV-5YZwYiO9z9ty_SKxjtJOluGWcp5nSMuzXp18"}
    [EVAL] Domain has 2 keys
    [EVAL] Element: "buyer@example.com"
    [EVAL] Element: "seller@example.com"
    [EVAL] Set: {"buyer@example.com", "seller@example.com"}
    [EVAL] Element: "buyer@example.com"
    [EVAL] Set: {"buyer@example.com", "seller@example.com"}
    [EVAL] Element found in set: true
    [EVAL] Arg[0] result: true
    [EVAL] Arg[1]: =([](tmp_Roles_15, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_15
    [EVAL] Found in sigma: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail14'
    [EVAL] Found in sigma: "buyer@example.com"
    [EVAL] Map expr evaluated: {buyer@example.com -> "Buyer", seller@example.com -> "Seller"}
    [EVAL] Key expr evaluated: "buyer@example.com"
    [EVAL] Key found in map, returning value
  [EVAL] String: "Buyer"
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= "Buyer" BUYER)
    [EVAL] Arg[2]: in(orderId, dom(tmp_O_6))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId14'
    [EVAL] Found placeholder __NEEDS_ORDER_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_7 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [EVAL] Found in sigma: "__NEEDS_ORDER_ID__"
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_6
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: "__NEEDS_ORDER_ID__"
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[2] result: false
    [EVAL] Arg[3]: =([](tmp_O_7, orderId), buyerEmail)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_O_7
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId14'
    [EVAL] Found placeholder __NEEDS_ORDER_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_7 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [EVAL] Found in sigma: "__NEEDS_ORDER_ID__"
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: "__NEEDS_ORDER_ID__"
    [EVAL] Key not found in map
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail14'
    [EVAL] Found in sigma: "buyer@example.com"
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[3] result: (= []({}, "__NEEDS_ORDER_ID__") "buyer@example.com")
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'createReview' ready for actual execution

[ASSIGN] Evaluating: _result14 := createReview(buyerEmail, productId, orderId, rating, comment)
[SEE] Mapping base name '_result' -> '_result14'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail14'
    [EVAL] Found in sigma: "buyer@example.com"
  [EVAL] Var lookup: productId
    [EVAL] Resolved base name 'productId' -> 'productId14'
    [EVAL] Found in sigma: "__NEEDS_PRODUCT_ID__"
  [EVAL] Var lookup: orderId
    [EVAL] Resolved base name 'orderId' -> 'orderId14'
    [EVAL] Found placeholder __NEEDS_ORDER_ID__, attempting runtime resolution
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_7 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [EVAL] Found in sigma: "__NEEDS_ORDER_ID__"
  [EVAL] Var lookup: rating
    [EVAL] Resolved base name 'rating' -> 'rating14'
    [EVAL] Found in sigma: 5
  [EVAL] Var lookup: comment
    [EVAL] Resolved base name 'comment' -> 'comment14'
    [EVAL] Found in sigma: "Great product, highly recommend!"
[API_CALL] Executing API function: createReview
  [API_ARG] "buyer@example.com"
  [API_ARG] "__NEEDS_PRODUCT_ID__"
  [API_ARG] "__NEEDS_ORDER_ID__"
  [API_ARG] 5
  [API_ARG] "Great product, highly recommend!"
  [API_CALL] Getting function from factory...
[Factory] Creating function: createReview
  [API_CALL] Executing function...
[CreateReviewFunc] buyer@example.com reviewing product: __NEEDS_PRODUCT_ID__
[HttpClient] POST /api/reviews -> 500
[CreateReviewFunc] Error response: {"error":"Cannot read properties of undefined (reading '_id')"}
  [API_CALL] Function returned: ""
  [API_CALL] Storing result in variable: _result14
[ASSIGN] Result: _result14 := ""
[SEE] API call 'get_Rev' ready for actual execution

[ASSIGN] Evaluating: tmp_Rev_3 := get_Rev()
[SEE] Mapping base name 'tmp_Rev_' -> 'tmp_Rev_3'
[API_CALL] Executing API function: get_Rev
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Rev
  [API_CALL] Executing function...
[GetRevFunc] Fetching Rev...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Rev_3
[ASSIGN] Result: tmp_Rev_3 := {}

[ASSERT] Evaluating: in(_result14, dom(tmp_Rev_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result14
    [EVAL] Found in sigma: ""
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_Rev_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: ""
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[SEE] Path Constraint: And(true, And(true, And(AND(true, (= "Seller" SELLER)), And(AND(true, true, (= "Seller" SELLER)), And(AND(true, (= "Seller" SELLER)), And(AND(true, (= "Seller" SELLER)), And(AND(true, (= "Seller" SELLER)), And(true, And(AND(true, (= "Buyer" BUYER)), And(AND(true, true, (= "Buyer" BUYER)), And(1, And(false, And(false, And(false, And(false, And(false, And(false, false)))))))))))))))))

[UNSAT-CHECK] Path constraint contains FALSE - checking dependencies...

[DEPENDENCY-CHECK] Analyzing sequence for true UNSAT...
[DEPENDENCY-CHECK] ✓ All dependencies satisfied - sequence is potentially satisfiable.
>>> generateCTC: After symex - Is abstract: 0, Has placeholders: 1

>>> generateCTC: STEP 3a - Resolving placeholders in AST

>>> Resolving placeholders in program AST
    [findKeyFromMapInSigma] Searching for prefix: tmp_P_
    [findKeyFromMapInSigma] Found tmp_P_8 with 3 entries, returning key: 696caf2909fc7fa2c06c261d
    [AST RESOLVED] productId8 = "696caf2909fc7fa2c06c261d"
    [findKeyFromMapInSigma] Searching for prefix: tmp_P_
    [findKeyFromMapInSigma] Found tmp_P_8 with 3 entries, returning key: 696caf2909fc7fa2c06c261d
    [AST RESOLVED] productId9 = "696caf2909fc7fa2c06c261d"
    [findKeyFromMapInSigma] Searching for prefix: tmp_P_
    [findKeyFromMapInSigma] Found tmp_P_8 with 3 entries, returning key: 696caf2909fc7fa2c06c261d
    [AST RESOLVED] productId11 = "696caf2909fc7fa2c06c261d"
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_7 is empty map
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [AST RESOLVED] orderId11 = "no_order_available"
    [findKeyFromMapInSigma] Searching for prefix: tmp_P_
    [findKeyFromMapInSigma] Found tmp_P_8 with 3 entries, returning key: 696caf2909fc7fa2c06c261d
    [AST RESOLVED] productId12 = "696caf2909fc7fa2c06c261d"
    [findKeyFromMapInSigma] Searching for prefix: tmp_P_
    [findKeyFromMapInSigma] Found tmp_P_8 with 3 entries, returning key: 696caf2909fc7fa2c06c261d
    [AST RESOLVED] productId14 = "696caf2909fc7fa2c06c261d"
    [findKeyFromMapInSigma] Searching for prefix: tmp_O_
    [findKeyFromMapInSigma] tmp_O_7 is empty map
    [findKeyFromMapInSigma] tmp_O_6 is empty map
    [findKeyFromMapInSigma] tmp_O_5 is empty map
    [findKeyFromMapInSigma] tmp_O_4 is empty map
    [findKeyFromMapInSigma] tmp_O_3 is empty map
    [findKeyFromMapInSigma] tmp_O_2 is empty map
    [findKeyFromMapInSigma] tmp_O_1 is empty map
    [findKeyFromMapInSigma] tmp_O_0 is empty map
    [findKeyFromMapInSigma] No non-empty map found for tmp_O_
    [AST RESOLVED] orderId14 = "no_order_available"
>>> generateCTC: All placeholders resolved, program is fully concrete

[FINAL CTC]
=== Program ===
Statement 0: _ := reset()
Statement 1: sellerEmail0 := "seller@example.com"
Statement 2: sellerPassword0 := "SellerPass123!"
Statement 3: sellerFullName0 := "Test Seller"
Statement 4: storeName0 := "Test Store"
Statement 5: storeDescription0 := "A quality test store"
Statement 6: tmp_Roles_0 := get_Roles()
Statement 7: Roles_old := tmp_Roles_0
Statement 8: tmp_U_0 := get_U()
Statement 9: U_old := tmp_U_0
Statement 10: tmp_U_1 := get_U()
Statement 11: assume(not_in(sellerEmail, dom(tmp_U_1)))
Statement 12: _result0 := registerSeller(sellerEmail, sellerPassword, sellerFullName, storeName, storeDescription)
Statement 13: tmp_U_2 := get_U()
Statement 14: tmp_Roles_1 := get_Roles()
Statement 15: assert(AND(=([](tmp_U_2, sellerEmail), sellerPassword), =([](tmp_Roles_1, sellerEmail), SELLER)))
Statement 16: sellerEmail1 := "seller@example.com"
Statement 17: sellerPassword1 := "SellerPass123!"
Statement 18: tmp_T_0 := get_T()
Statement 19: T_old := tmp_T_0
Statement 20: tmp_U_3 := get_U()
Statement 21: tmp_U_4 := get_U()
Statement 22: tmp_Roles_2 := get_Roles()
Statement 23: assume(AND(in(sellerEmail, dom(tmp_U_3)), =([](tmp_U_4, sellerEmail), sellerPassword), =([](tmp_Roles_2, sellerEmail), SELLER)))
Statement 24: _result1 := login(sellerEmail, sellerPassword)
Statement 25: tmp_T_1 := get_T()
Statement 26: assert(=([](tmp_T_1, sellerEmail), _result1))
Statement 27: sellerEmail2 := "seller@example.com"
Statement 28: title2 := "Test Product"
Statement 29: description2 := "A great test product description"
Statement 30: category2 := "Electronics"
Statement 31: price2 := 99
Statement 32: quantity2 := 2
Statement 33: tmp_P_0 := get_P()
Statement 34: P_old := tmp_P_0
Statement 35: tmp_Sellers_0 := get_Sellers()
Statement 36: Sellers_old := tmp_Sellers_0
Statement 37: tmp_T_2 := get_T()
Statement 38: tmp_Roles_3 := get_Roles()
Statement 39: assume(AND(in(sellerEmail, dom(tmp_T_2)), =([](tmp_Roles_3, sellerEmail), SELLER)))
Statement 40: _result2 := createProduct(sellerEmail, title, description, category, price, quantity)
Statement 41: tmp_P_1 := get_P()
Statement 42: tmp_Sellers_1 := get_Sellers()
Statement 43: assert(AND(in(_result2, dom(tmp_P_1)), =([](tmp_Sellers_1, _result2), sellerEmail)))
Statement 44: sellerEmail3 := "seller@example.com"
Statement 45: title3 := "Test Product"
Statement 46: description3 := "A great test product description"
Statement 47: category3 := "Electronics"
Statement 48: price3 := 99
Statement 49: quantity3 := 2
Statement 50: tmp_P_2 := get_P()
Statement 51: P_old := tmp_P_2
Statement 52: tmp_Sellers_2 := get_Sellers()
Statement 53: Sellers_old := tmp_Sellers_2
Statement 54: tmp_T_3 := get_T()
Statement 55: tmp_Roles_4 := get_Roles()
Statement 56: assume(AND(in(sellerEmail, dom(tmp_T_3)), =([](tmp_Roles_4, sellerEmail), SELLER)))
Statement 57: _result3 := createProduct(sellerEmail, title, description, category, price, quantity)
Statement 58: tmp_P_3 := get_P()
Statement 59: tmp_Sellers_3 := get_Sellers()
Statement 60: assert(AND(in(_result3, dom(tmp_P_3)), =([](tmp_Sellers_3, _result3), sellerEmail)))
Statement 61: sellerEmail4 := "seller@example.com"
Statement 62: title4 := "Test Product"
Statement 63: description4 := "A great test product description"
Statement 64: category4 := "Electronics"
Statement 65: price4 := 99
Statement 66: quantity4 := 2
Statement 67: tmp_P_4 := get_P()
Statement 68: P_old := tmp_P_4
Statement 69: tmp_Sellers_4 := get_Sellers()
Statement 70: Sellers_old := tmp_Sellers_4
Statement 71: tmp_T_4 := get_T()
Statement 72: tmp_Roles_5 := get_Roles()
Statement 73: assume(AND(in(sellerEmail, dom(tmp_T_4)), =([](tmp_Roles_5, sellerEmail), SELLER)))
Statement 74: _result4 := createProduct(sellerEmail, title, description, category, price, quantity)
Statement 75: tmp_P_5 := get_P()
Statement 76: tmp_Sellers_5 := get_Sellers()
Statement 77: assert(AND(in(_result4, dom(tmp_P_5)), =([](tmp_Sellers_5, _result4), sellerEmail)))
Statement 78: buyerEmail5 := "buyer@example.com"
Statement 79: buyerPassword5 := "BuyerPass123!"
Statement 80: buyerFullName5 := "Test Buyer"
Statement 81: tmp_Roles_6 := get_Roles()
Statement 82: Roles_old := tmp_Roles_6
Statement 83: tmp_U_5 := get_U()
Statement 84: U_old := tmp_U_5
Statement 85: tmp_U_6 := get_U()
Statement 86: assume(not_in(buyerEmail, dom(tmp_U_6)))
Statement 87: _result5 := registerBuyer(buyerEmail, buyerPassword, buyerFullName)
Statement 88: tmp_U_7 := get_U()
Statement 89: tmp_Roles_7 := get_Roles()
Statement 90: assert(AND(=([](tmp_U_7, buyerEmail), buyerPassword), =([](tmp_Roles_7, buyerEmail), BUYER)))
Statement 91: buyerEmail6 := "buyer@example.com"
Statement 92: buyerPassword6 := "BuyerPass123!"
Statement 93: tmp_T_5 := get_T()
Statement 94: T_old := tmp_T_5
Statement 95: tmp_U_8 := get_U()
Statement 96: tmp_U_9 := get_U()
Statement 97: tmp_Roles_8 := get_Roles()
Statement 98: assume(AND(in(buyerEmail, dom(tmp_U_8)), =([](tmp_U_9, buyerEmail), buyerPassword), =([](tmp_Roles_8, buyerEmail), BUYER)))
Statement 99: _result6 := login(buyerEmail, buyerPassword)
Statement 100: tmp_T_6 := get_T()
Statement 101: assert(=([](tmp_T_6, buyerEmail), _result6))
Statement 102: assume(1)
Statement 103: _result7 := getAllProducts()
Statement 104: assert()
Statement 105: buyerEmail8 := "buyer@example.com"
Statement 106: productId8 := "696caf2909fc7fa2c06c261d"
Statement 107: quantity8 := 2
Statement 108: tmp_C_0 := get_C()
Statement 109: C_old := tmp_C_0
Statement 110: tmp_T_7 := get_T()
Statement 111: tmp_Roles_9 := get_Roles()
Statement 112: tmp_P_6 := get_P()
Statement 113: assume(AND(in(buyerEmail, dom(tmp_T_7)), =([](tmp_Roles_9, buyerEmail), BUYER), in(productId, dom(tmp_P_6))))
Statement 114: _result8 := addToCart(buyerEmail, productId, quantity)
Statement 115: tmp_C_1 := get_C()
Statement 116: assert(in(buyerEmail, dom(tmp_C_1)))
Statement 117: buyerEmail9 := "buyer@example.com"
Statement 118: productId9 := "696caf2909fc7fa2c06c261d"
Statement 119: quantity9 := 2
Statement 120: tmp_C_2 := get_C()
Statement 121: C_old := tmp_C_2
Statement 122: tmp_T_8 := get_T()
Statement 123: tmp_Roles_10 := get_Roles()
Statement 124: tmp_P_7 := get_P()
Statement 125: assume(AND(in(buyerEmail, dom(tmp_T_8)), =([](tmp_Roles_10, buyerEmail), BUYER), in(productId, dom(tmp_P_7))))
Statement 126: _result9 := addToCart(buyerEmail, productId, quantity)
Statement 127: tmp_C_3 := get_C()
Statement 128: assert(in(buyerEmail, dom(tmp_C_3)))
Statement 129: buyerEmail10 := "buyer@example.com"
Statement 130: shippingAddress10 := "123 Test St,Test City,TS,12345,USA"
Statement 131: paymentMethod10 := "card"
Statement 132: tmp_C_4 := get_C()
Statement 133: C_old := tmp_C_4
Statement 134: tmp_O_0 := get_O()
Statement 135: O_old := tmp_O_0
Statement 136: tmp_OrderStatus_0 := get_OrderStatus()
Statement 137: OrderStatus_old := tmp_OrderStatus_0
Statement 138: tmp_T_9 := get_T()
Statement 139: tmp_Roles_11 := get_Roles()
Statement 140: tmp_C_5 := get_C()
Statement 141: assume(AND(in(buyerEmail, dom(tmp_T_9)), =([](tmp_Roles_11, buyerEmail), BUYER), in(buyerEmail, dom(tmp_C_5))))
Statement 142: _result10 := createOrder(buyerEmail, shippingAddress, paymentMethod)
Statement 143: tmp_O_1 := get_O()
Statement 144: tmp_OrderStatus_1 := get_OrderStatus()
Statement 145: tmp_C_6 := get_C()
Statement 146: assert(AND(in(_result10, dom(tmp_O_1)), =([](tmp_OrderStatus_1, _result10), PENDING), not_in(buyerEmail, dom(tmp_C_6))))
Statement 147: buyerEmail11 := "buyer@example.com"
Statement 148: productId11 := "696caf2909fc7fa2c06c261d"
Statement 149: orderId11 := "no_order_available"
Statement 150: rating11 := 5
Statement 151: comment11 := "Great product, highly recommend!"
Statement 152: tmp_Rev_0 := get_Rev()
Statement 153: Rev_old := tmp_Rev_0
Statement 154: tmp_T_10 := get_T()
Statement 155: tmp_Roles_12 := get_Roles()
Statement 156: tmp_O_2 := get_O()
Statement 157: tmp_O_3 := get_O()
Statement 158: assume(AND(in(buyerEmail, dom(tmp_T_10)), =([](tmp_Roles_12, buyerEmail), BUYER), in(orderId, dom(tmp_O_2)), =([](tmp_O_3, orderId), buyerEmail)))
Statement 159: _result11 := createReview(buyerEmail, productId, orderId, rating, comment)
Statement 160: tmp_Rev_1 := get_Rev()
Statement 161: assert(in(_result11, dom(tmp_Rev_1)))
Statement 162: buyerEmail12 := "buyer@example.com"
Statement 163: productId12 := "696caf2909fc7fa2c06c261d"
Statement 164: quantity12 := 2
Statement 165: tmp_C_7 := get_C()
Statement 166: C_old := tmp_C_7
Statement 167: tmp_T_11 := get_T()
Statement 168: tmp_Roles_13 := get_Roles()
Statement 169: tmp_P_8 := get_P()
Statement 170: assume(AND(in(buyerEmail, dom(tmp_T_11)), =([](tmp_Roles_13, buyerEmail), BUYER), in(productId, dom(tmp_P_8))))
Statement 171: _result12 := addToCart(buyerEmail, productId, quantity)
Statement 172: tmp_C_8 := get_C()
Statement 173: assert(in(buyerEmail, dom(tmp_C_8)))
Statement 174: buyerEmail13 := "buyer@example.com"
Statement 175: shippingAddress13 := "123 Test St,Test City,TS,12345,USA"
Statement 176: paymentMethod13 := "card"
Statement 177: tmp_C_9 := get_C()
Statement 178: C_old := tmp_C_9
Statement 179: tmp_O_4 := get_O()
Statement 180: O_old := tmp_O_4
Statement 181: tmp_OrderStatus_2 := get_OrderStatus()
Statement 182: OrderStatus_old := tmp_OrderStatus_2
Statement 183: tmp_T_12 := get_T()
Statement 184: tmp_Roles_14 := get_Roles()
Statement 185: tmp_C_10 := get_C()
Statement 186: assume(AND(in(buyerEmail, dom(tmp_T_12)), =([](tmp_Roles_14, buyerEmail), BUYER), in(buyerEmail, dom(tmp_C_10))))
Statement 187: _result13 := createOrder(buyerEmail, shippingAddress, paymentMethod)
Statement 188: tmp_O_5 := get_O()
Statement 189: tmp_OrderStatus_3 := get_OrderStatus()
Statement 190: tmp_C_11 := get_C()
Statement 191: assert(AND(in(_result13, dom(tmp_O_5)), =([](tmp_OrderStatus_3, _result13), PENDING), not_in(buyerEmail, dom(tmp_C_11))))
Statement 192: buyerEmail14 := "buyer@example.com"
Statement 193: productId14 := "696caf2909fc7fa2c06c261d"
Statement 194: orderId14 := "no_order_available"
Statement 195: rating14 := 5
Statement 196: comment14 := "Great product, highly recommend!"
Statement 197: tmp_Rev_2 := get_Rev()
Statement 198: Rev_old := tmp_Rev_2
Statement 199: tmp_T_13 := get_T()
Statement 200: tmp_Roles_15 := get_Roles()
Statement 201: tmp_O_6 := get_O()
Statement 202: tmp_O_7 := get_O()
Statement 203: assume(AND(in(buyerEmail, dom(tmp_T_13)), =([](tmp_Roles_15, buyerEmail), BUYER), in(orderId, dom(tmp_O_6)), =([](tmp_O_7, orderId), buyerEmail)))
Statement 204: _result14 := createReview(buyerEmail, productId, orderId, rating, comment)
Statement 205: tmp_Rev_3 := get_Rev()
Statement 206: assert(in(_result14, dom(tmp_Rev_3)))
=== End Program ===

✓ [SAT] Test 21: Deep E-Commerce Workflow (Depth=15) COMPLETE!

