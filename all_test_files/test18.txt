
╔════════════════════════════════════════╗
║  TESTGEN - RESTAURANT TEST SUITE      ║
║  Total Tests: 25                       ║
╚════════════════════════════════════════╝


=== DEPTH TESTS ===

========================================
TEST: Test 18: Login → Browse → Add 3 Items to Cart → Place Order (Depth=6)
MODE: Full Pipeline (With Backend)
DEPTH: 6 API calls
========================================

[RestaurantFunctionFactory] Initialized with baseUrl: http://localhost:5002
[RewriteGlobalsVisitor] Detected 10 globals: Assignments C M O Owners R Rev Roles T U 
[RewriteGlobalsVisitor] Generated 0 statements in rewritten program

=== TEST-API ATC (After Rewrite) ===
=== Program ===
Statement 0: _ := reset()
Statement 1: customerEmail0 := input()
Statement 2: customerPassword0 := input()
Statement 3: tmp_T_0 := get_T()
Statement 4: T_old := tmp_T_0
Statement 5: tmp_U_0 := get_U()
Statement 6: tmp_U_1 := get_U()
Statement 7: assume(AND(in(customerEmail, dom(tmp_U_0)), =([](tmp_U_1, customerEmail), customerPassword)))
Statement 8: _result0 := login(customerEmail, customerPassword)
Statement 9: tmp_T_1 := get_T()
Statement 10: assert(=([](tmp_T_1, customerEmail), _result0))
Statement 11: customerEmail1 := input()
Statement 12: tmp_T_2 := get_T()
Statement 13: assume(in(customerEmail, dom(tmp_T_2)))
Statement 14: _result1 := browseRestaurants(customerEmail)
Statement 15: assert()
Statement 16: customerEmail2 := input()
Statement 17: menuItemId2 := input()
Statement 18: quantity2 := input()
Statement 19: tmp_C_0 := get_C()
Statement 20: C_old := tmp_C_0
Statement 21: tmp_T_3 := get_T()
Statement 22: tmp_M_0 := get_M()
Statement 23: assume(AND(in(customerEmail, dom(tmp_T_3)), in(menuItemId, dom(tmp_M_0))))
Statement 24: _result2 := addToCart(customerEmail, menuItemId, quantity)
Statement 25: tmp_C_1 := get_C()
Statement 26: assert(in(customerEmail, dom(tmp_C_1)))
Statement 27: customerEmail3 := input()
Statement 28: menuItemId3 := input()
Statement 29: quantity3 := input()
Statement 30: tmp_C_2 := get_C()
Statement 31: C_old := tmp_C_2
Statement 32: tmp_T_4 := get_T()
Statement 33: tmp_M_1 := get_M()
Statement 34: assume(AND(in(customerEmail, dom(tmp_T_4)), in(menuItemId, dom(tmp_M_1))))
Statement 35: _result3 := addToCart(customerEmail, menuItemId, quantity)
Statement 36: tmp_C_3 := get_C()
Statement 37: assert(in(customerEmail, dom(tmp_C_3)))
Statement 38: customerEmail4 := input()
Statement 39: menuItemId4 := input()
Statement 40: quantity4 := input()
Statement 41: tmp_C_4 := get_C()
Statement 42: C_old := tmp_C_4
Statement 43: tmp_T_5 := get_T()
Statement 44: tmp_M_2 := get_M()
Statement 45: assume(AND(in(customerEmail, dom(tmp_T_5)), in(menuItemId, dom(tmp_M_2))))
Statement 46: _result4 := addToCart(customerEmail, menuItemId, quantity)
Statement 47: tmp_C_5 := get_C()
Statement 48: assert(in(customerEmail, dom(tmp_C_5)))
Statement 49: customerEmail5 := input()
Statement 50: deliveryAddress5 := input()
Statement 51: paymentMethod5 := input()
Statement 52: tmp_C_6 := get_C()
Statement 53: C_old := tmp_C_6
Statement 54: tmp_O_0 := get_O()
Statement 55: O_old := tmp_O_0
Statement 56: tmp_T_6 := get_T()
Statement 57: tmp_C_7 := get_C()
Statement 58: assume(AND(in(customerEmail, dom(tmp_T_6)), in(customerEmail, dom(tmp_C_7))))
Statement 59: _result5 := placeOrder(customerEmail, deliveryAddress, paymentMethod)
Statement 60: tmp_O_1 := get_O()
Statement 61: tmp_C_8 := get_C()
Statement 62: assert(AND(in(_result5, dom(tmp_O_1)), not_in(customerEmail, dom(tmp_C_8))))
=== End Program ===

========================================
>>> generateCTC: Starting iteration
========================================
>>> generateCTC: Program needs processing
>>> generateCTC: Concrete values provided: 0
>>> generateCTC: Is abstract: 1
>>> generateCTC: Has placeholders: 0

>>> generateCTC: STEP 1 - Rewriting ATC with concrete values

>>> generateCTC: STEP 2 - Running symbolic execution
[SEE] API call 'reset' ready for actual execution

[ASSIGN] Evaluating: _ := reset()
[API_CALL] Executing API function: reset
  [API_CALL] Getting function from factory...
[Factory] Creating function: reset
  [API_CALL] Executing function...
[ResetFunc] Clearing all collections...
[HttpClient] POST /api/test/reset -> 200
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _
[ASSIGN] Result: _ := 200

[ASSIGN] Evaluating: customerEmail0 := input()
[SEE] Mapping base name 'customerEmail' -> 'customerEmail0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X0
[ASSIGN] Result: customerEmail0 := X0

[ASSIGN] Evaluating: customerPassword0 := input()
[SEE] Mapping base name 'customerPassword' -> 'customerPassword0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X1
[ASSIGN] Result: customerPassword0 := X1
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_0 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_0'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_0
[ASSIGN] Result: tmp_T_0 := {}

[ASSIGN] Evaluating: T_old := tmp_T_0
  [EVAL] Var lookup: tmp_T_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: T_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_0 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_0'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_0
[ASSIGN] Result: tmp_U_0 := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_1 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_1'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_1
[ASSIGN] Result: tmp_U_1 := {}
[SEE] Interruption at statement 7

[ASSUME] Evaluating: AND(in(customerEmail, dom(tmp_U_0)), =([](tmp_U_1, customerEmail), customerPassword))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(customerEmail, dom(tmp_U_0))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail0'
    [EVAL] Found in sigma: X0
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_0
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X0
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_U_1, customerEmail), customerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail0'
    [EVAL] Found in sigma: X0
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X0
    [EVAL] Key not found in map
  [EVAL] Var lookup: customerPassword
    [EVAL] Resolved base name 'customerPassword' -> 'customerPassword0'
    [EVAL] Found in sigma: X1
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X0) X1)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'login' with symbolic arguments - interruption point
[SEE] Interruption at statement 8

[ASSIGN] Evaluating: _result0 := login(customerEmail, customerPassword)
[SEE] Mapping base name '_result' -> '_result0'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail0'
    [EVAL] Found in sigma: X0
  [EVAL] Var lookup: customerPassword
    [EVAL] Resolved base name 'customerPassword' -> 'customerPassword0'
    [EVAL] Found in sigma: X1
[API_CALL] login has symbolic arguments - skipping actual execution
  [API_ARG 0] X0 (symbolic: 1)
  [API_ARG 1] X1 (symbolic: 1)
[ASSIGN] Result: _result0 := -1 (symbolic placeholder)
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_1 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_1'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_1
[ASSIGN] Result: tmp_T_1 := {}

[ASSERT] Evaluating: =([](tmp_T_1, customerEmail), _result0)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_T_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail0'
    [EVAL] Found in sigma: X0
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X0
    [EVAL] Key not found in map
  [EVAL] Var lookup: _result0
    [EVAL] Found in sigma: -1
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
[ASSERT] Result: (= []({}, X0) -1)
[ASSERT] Adding to path constraints (not fully concrete)

[ASSIGN] Evaluating: customerEmail1 := input()
[SEE] Mapping base name 'customerEmail' -> 'customerEmail1'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X2
[ASSIGN] Result: customerEmail1 := X2
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_2 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_2'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_2
[ASSIGN] Result: tmp_T_2 := {}

[ASSUME] Evaluating: in(customerEmail, dom(tmp_T_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail1'
    [EVAL] Found in sigma: X2
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_2
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X2
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSUME] Adding constraint: false
[SEE] API call 'browseRestaurants' with symbolic arguments - interruption point
[SEE] Interruption at statement 14

[ASSIGN] Evaluating: _result1 := browseRestaurants(customerEmail)
[SEE] Mapping base name '_result' -> '_result1'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail1'
    [EVAL] Found in sigma: X2
[API_CALL] browseRestaurants has symbolic arguments - skipping actual execution
  [API_ARG 0] X2 (symbolic: 1)
[ASSIGN] Result: _result1 := -1 (symbolic placeholder)

[ASSERT] Empty assertion, PASSED

[ASSIGN] Evaluating: customerEmail2 := input()
[SEE] Mapping base name 'customerEmail' -> 'customerEmail2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X3
[ASSIGN] Result: customerEmail2 := X3

[ASSIGN] Evaluating: menuItemId2 := input()
[SEE] Mapping base name 'menuItemId' -> 'menuItemId2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X4
[ASSIGN] Result: menuItemId2 := X4

[ASSIGN] Evaluating: quantity2 := input()
[SEE] Mapping base name 'quantity' -> 'quantity2'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X5
[ASSIGN] Result: quantity2 := X5
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_0 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_0'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_0
[ASSIGN] Result: tmp_C_0 := {}

[ASSIGN] Evaluating: C_old := tmp_C_0
  [EVAL] Var lookup: tmp_C_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: C_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_3 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_3'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_3
[ASSIGN] Result: tmp_T_3 := {}
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_0 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_0'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_M_0
[ASSIGN] Result: tmp_M_0 := {}
[SEE] Interruption at statement 23

[ASSUME] Evaluating: AND(in(customerEmail, dom(tmp_T_3)), in(menuItemId, dom(tmp_M_0)))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(customerEmail, dom(tmp_T_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail2'
    [EVAL] Found in sigma: X3
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X3
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: in(menuItemId, dom(tmp_M_0))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: menuItemId
    [EVAL] Resolved base name 'menuItemId' -> 'menuItemId2'
    [EVAL] Found in sigma: X4
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_M_0
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X4
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[1] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'addToCart' with symbolic arguments - interruption point
[SEE] Interruption at statement 24

[ASSIGN] Evaluating: _result2 := addToCart(customerEmail, menuItemId, quantity)
[SEE] Mapping base name '_result' -> '_result2'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail2'
    [EVAL] Found in sigma: X3
  [EVAL] Var lookup: menuItemId
    [EVAL] Resolved base name 'menuItemId' -> 'menuItemId2'
    [EVAL] Found in sigma: X4
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity2'
    [EVAL] Found in sigma: X5
[API_CALL] addToCart has symbolic arguments - skipping actual execution
  [API_ARG 0] X3 (symbolic: 1)
  [API_ARG 1] X4 (symbolic: 1)
  [API_ARG 2] X5 (symbolic: 1)
[ASSIGN] Result: _result2 := -1 (symbolic placeholder)
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_1 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_1'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_1
[ASSIGN] Result: tmp_C_1 := {}

[ASSERT] Evaluating: in(customerEmail, dom(tmp_C_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail2'
    [EVAL] Found in sigma: X3
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X3
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: customerEmail3 := input()
[SEE] Mapping base name 'customerEmail' -> 'customerEmail3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X6
[ASSIGN] Result: customerEmail3 := X6

[ASSIGN] Evaluating: menuItemId3 := input()
[SEE] Mapping base name 'menuItemId' -> 'menuItemId3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X7
[ASSIGN] Result: menuItemId3 := X7

[ASSIGN] Evaluating: quantity3 := input()
[SEE] Mapping base name 'quantity' -> 'quantity3'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X8
[ASSIGN] Result: quantity3 := X8
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_2 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_2'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_2
[ASSIGN] Result: tmp_C_2 := {}

[ASSIGN] Evaluating: C_old := tmp_C_2
  [EVAL] Var lookup: tmp_C_2
    [EVAL] Found in sigma: {}
[ASSIGN] Result: C_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_4 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_4'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_4
[ASSIGN] Result: tmp_T_4 := {}
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_1 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_1'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_M_1
[ASSIGN] Result: tmp_M_1 := {}
[SEE] Interruption at statement 34

[ASSUME] Evaluating: AND(in(customerEmail, dom(tmp_T_4)), in(menuItemId, dom(tmp_M_1)))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(customerEmail, dom(tmp_T_4))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail3'
    [EVAL] Found in sigma: X6
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_4
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X6
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: in(menuItemId, dom(tmp_M_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: menuItemId
    [EVAL] Resolved base name 'menuItemId' -> 'menuItemId3'
    [EVAL] Found in sigma: X7
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_M_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X7
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[1] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'addToCart' with symbolic arguments - interruption point
[SEE] Interruption at statement 35

[ASSIGN] Evaluating: _result3 := addToCart(customerEmail, menuItemId, quantity)
[SEE] Mapping base name '_result' -> '_result3'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail3'
    [EVAL] Found in sigma: X6
  [EVAL] Var lookup: menuItemId
    [EVAL] Resolved base name 'menuItemId' -> 'menuItemId3'
    [EVAL] Found in sigma: X7
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity3'
    [EVAL] Found in sigma: X8
[API_CALL] addToCart has symbolic arguments - skipping actual execution
  [API_ARG 0] X6 (symbolic: 1)
  [API_ARG 1] X7 (symbolic: 1)
  [API_ARG 2] X8 (symbolic: 1)
[ASSIGN] Result: _result3 := -1 (symbolic placeholder)
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_3 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_3'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_3
[ASSIGN] Result: tmp_C_3 := {}

[ASSERT] Evaluating: in(customerEmail, dom(tmp_C_3))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail3'
    [EVAL] Found in sigma: X6
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_3
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X6
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: customerEmail4 := input()
[SEE] Mapping base name 'customerEmail' -> 'customerEmail4'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X9
[ASSIGN] Result: customerEmail4 := X9

[ASSIGN] Evaluating: menuItemId4 := input()
[SEE] Mapping base name 'menuItemId' -> 'menuItemId4'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X10
[ASSIGN] Result: menuItemId4 := X10

[ASSIGN] Evaluating: quantity4 := input()
[SEE] Mapping base name 'quantity' -> 'quantity4'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X11
[ASSIGN] Result: quantity4 := X11
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_4 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_4'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_4
[ASSIGN] Result: tmp_C_4 := {}

[ASSIGN] Evaluating: C_old := tmp_C_4
  [EVAL] Var lookup: tmp_C_4
    [EVAL] Found in sigma: {}
[ASSIGN] Result: C_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_5 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_5'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_5
[ASSIGN] Result: tmp_T_5 := {}
[SEE] API call 'get_M' ready for actual execution

[ASSIGN] Evaluating: tmp_M_2 := get_M()
[SEE] Mapping base name 'tmp_M_' -> 'tmp_M_2'
[API_CALL] Executing API function: get_M
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_M
  [API_CALL] Executing function...
[GetMFunc] Fetching M...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_M_2
[ASSIGN] Result: tmp_M_2 := {}
[SEE] Interruption at statement 45

[ASSUME] Evaluating: AND(in(customerEmail, dom(tmp_T_5)), in(menuItemId, dom(tmp_M_2)))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(customerEmail, dom(tmp_T_5))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail4'
    [EVAL] Found in sigma: X9
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_5
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X9
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: in(menuItemId, dom(tmp_M_2))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: menuItemId
    [EVAL] Resolved base name 'menuItemId' -> 'menuItemId4'
    [EVAL] Found in sigma: X10
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_M_2
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X10
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[1] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'addToCart' with symbolic arguments - interruption point
[SEE] Interruption at statement 46

[ASSIGN] Evaluating: _result4 := addToCart(customerEmail, menuItemId, quantity)
[SEE] Mapping base name '_result' -> '_result4'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail4'
    [EVAL] Found in sigma: X9
  [EVAL] Var lookup: menuItemId
    [EVAL] Resolved base name 'menuItemId' -> 'menuItemId4'
    [EVAL] Found in sigma: X10
  [EVAL] Var lookup: quantity
    [EVAL] Resolved base name 'quantity' -> 'quantity4'
    [EVAL] Found in sigma: X11
[API_CALL] addToCart has symbolic arguments - skipping actual execution
  [API_ARG 0] X9 (symbolic: 1)
  [API_ARG 1] X10 (symbolic: 1)
  [API_ARG 2] X11 (symbolic: 1)
[ASSIGN] Result: _result4 := -1 (symbolic placeholder)
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_5 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_5'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_5
[ASSIGN] Result: tmp_C_5 := {}

[ASSERT] Evaluating: in(customerEmail, dom(tmp_C_5))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail4'
    [EVAL] Found in sigma: X9
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_5
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X9
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[ASSIGN] Evaluating: customerEmail5 := input()
[SEE] Mapping base name 'customerEmail' -> 'customerEmail5'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X12
[ASSIGN] Result: customerEmail5 := X12

[ASSIGN] Evaluating: deliveryAddress5 := input()
[SEE] Mapping base name 'deliveryAddress' -> 'deliveryAddress5'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X13
[ASSIGN] Result: deliveryAddress5 := X13

[ASSIGN] Evaluating: paymentMethod5 := input()
[SEE] Mapping base name 'paymentMethod' -> 'paymentMethod5'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X14
[ASSIGN] Result: paymentMethod5 := X14
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_6 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_6'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_6
[ASSIGN] Result: tmp_C_6 := {}

[ASSIGN] Evaluating: C_old := tmp_C_6
  [EVAL] Var lookup: tmp_C_6
    [EVAL] Found in sigma: {}
[ASSIGN] Result: C_old := {}
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_0 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_0'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_0
[ASSIGN] Result: tmp_O_0 := {}

[ASSIGN] Evaluating: O_old := tmp_O_0
  [EVAL] Var lookup: tmp_O_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: O_old := {}
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_6 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_6'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_6
[ASSIGN] Result: tmp_T_6 := {}
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_7 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_7'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_7
[ASSIGN] Result: tmp_C_7 := {}
[SEE] Interruption at statement 58

[ASSUME] Evaluating: AND(in(customerEmail, dom(tmp_T_6)), in(customerEmail, dom(tmp_C_7)))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(customerEmail, dom(tmp_T_6))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail5'
    [EVAL] Found in sigma: X12
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_T_6
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X12
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: in(customerEmail, dom(tmp_C_7))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail5'
    [EVAL] Found in sigma: X12
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_7
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X12
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[1] result: false
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'placeOrder' with symbolic arguments - interruption point
[SEE] Interruption at statement 59

[ASSIGN] Evaluating: _result5 := placeOrder(customerEmail, deliveryAddress, paymentMethod)
[SEE] Mapping base name '_result' -> '_result5'
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail5'
    [EVAL] Found in sigma: X12
  [EVAL] Var lookup: deliveryAddress
    [EVAL] Resolved base name 'deliveryAddress' -> 'deliveryAddress5'
    [EVAL] Found in sigma: X13
  [EVAL] Var lookup: paymentMethod
    [EVAL] Resolved base name 'paymentMethod' -> 'paymentMethod5'
    [EVAL] Found in sigma: X14
[API_CALL] placeOrder has symbolic arguments - skipping actual execution
  [API_ARG 0] X12 (symbolic: 1)
  [API_ARG 1] X13 (symbolic: 1)
  [API_ARG 2] X14 (symbolic: 1)
[ASSIGN] Result: _result5 := -1 (symbolic placeholder)
[SEE] API call 'get_O' ready for actual execution

[ASSIGN] Evaluating: tmp_O_1 := get_O()
[SEE] Mapping base name 'tmp_O_' -> 'tmp_O_1'
[API_CALL] Executing API function: get_O
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_O
  [API_CALL] Executing function...
[GetOFunc] Fetching O...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_O_1
[ASSIGN] Result: tmp_O_1 := {}
[SEE] API call 'get_C' ready for actual execution

[ASSIGN] Evaluating: tmp_C_8 := get_C()
[SEE] Mapping base name 'tmp_C_' -> 'tmp_C_8'
[API_CALL] Executing API function: get_C
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_C
  [API_CALL] Executing function...
[GetCFunc] Fetching C...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_C_8
[ASSIGN] Result: tmp_C_8 := {}
[SEE] Interruption at statement 62

[ASSERT] Evaluating: AND(in(_result5, dom(tmp_O_1)), not_in(customerEmail, dom(tmp_C_8)))
  [EVAL] FuncCall: AND with 2 args
    [EVAL] N-ary AND with 2 args
    [EVAL] Arg[0]: in(_result5, dom(tmp_O_1))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: _result5
    [EVAL] Found in sigma: -1
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_O_1
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: -1
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: not_in(customerEmail, dom(tmp_C_8))
  [EVAL] FuncCall: not_in with 2 args
    [EVAL] Set non-membership: not_in
  [EVAL] Var lookup: customerEmail
    [EVAL] Resolved base name 'customerEmail' -> 'customerEmail5'
    [EVAL] Found in sigma: X12
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_C_8
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] not_in result: true (element not found)
    [EVAL] Arg[1] result: true
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSERT] Result: false
[ASSERT] ✗ Assertion FAILED

[SEE] Path Constraint: And(true, And(false, And((= []({}, X0) -1), And(false, And(false, And(false, And(false, false)))))))

>>> generateCTC: UNSAT DETECTED!
>>> Precondition cannot be satisfied with current database state.
>>> This test sequence requires prerequisite operations.

[RESULT] UNSAT - Test preconditions cannot be satisfied

⊘ Test 18: Login → Browse → Add 3 Items to Cart → Place Order (Depth=6) UNSAT: Preconditions not satisfiable

