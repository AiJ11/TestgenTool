
╔════════════════════════════════════════╗
║  TESTGEN - E-COMMERCE TEST SUITE       ║
║  Total Tests: 30 (21 SAT, 9 UNSAT)     ║
╚════════════════════════════════════════╝


========================================
TEST: [UNSAT] Test 22: Buyer Login Without Registration (Depth=1)
MODE: Full Pipeline (With Backend)
DEPTH: 1 API calls
========================================

[EcommerceFunctionFactory] Initialized with baseUrl: http://localhost:3000
[RewriteGlobalsVisitor] Detected 10 globals: C O OrderStatus P Rev Roles Sellers Stock T U 
[RewriteGlobalsVisitor] Generated 0 statements in rewritten program

=== TEST-API ATC (After Rewrite) ===
=== Program ===
Statement 0: _ := reset()
Statement 1: buyerEmail0 := input()
Statement 2: buyerPassword0 := input()
Statement 3: tmp_T_0 := get_T()
Statement 4: T_old := tmp_T_0
Statement 5: tmp_U_0 := get_U()
Statement 6: tmp_U_1 := get_U()
Statement 7: tmp_Roles_0 := get_Roles()
Statement 8: assume(AND(in(buyerEmail, dom(tmp_U_0)), =([](tmp_U_1, buyerEmail), buyerPassword), =([](tmp_Roles_0, buyerEmail), BUYER)))
Statement 9: _result0 := login(buyerEmail, buyerPassword)
Statement 10: tmp_T_1 := get_T()
Statement 11: assert(=([](tmp_T_1, buyerEmail), _result0))
=== End Program ===

========================================
>>> generateCTC: Starting iteration
========================================
>>> generateCTC: Program needs processing
>>> generateCTC: Concrete values provided: 0
>>> generateCTC: Is abstract: 1
>>> generateCTC: Has placeholders: 0

>>> generateCTC: STEP 1 - Rewriting ATC with concrete values

>>> generateCTC: STEP 2 - Running symbolic execution
[SEE] API call 'reset' ready for actual execution

[ASSIGN] Evaluating: _ := reset()
[API_CALL] Executing API function: reset
  [API_CALL] Getting function from factory...
[Factory] Creating function: reset
  [API_CALL] Executing function...
[ResetFunc] Clearing all collections...
[HttpClient] POST /api/test/reset -> 200
  [API_CALL] Function returned: 200
  [API_CALL] Storing result in variable: _
[ASSIGN] Result: _ := 200

[ASSIGN] Evaluating: buyerEmail0 := input()
[SEE] Mapping base name 'buyerEmail' -> 'buyerEmail0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X0
[ASSIGN] Result: buyerEmail0 := X0

[ASSIGN] Evaluating: buyerPassword0 := input()
[SEE] Mapping base name 'buyerPassword' -> 'buyerPassword0'
  [EVAL] FuncCall: input with 0 args
    [EVAL] input() returns new symbolic variable: X1
[ASSIGN] Result: buyerPassword0 := X1
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_0 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_0'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_0
[ASSIGN] Result: tmp_T_0 := {}

[ASSIGN] Evaluating: T_old := tmp_T_0
  [EVAL] Var lookup: tmp_T_0
    [EVAL] Found in sigma: {}
[ASSIGN] Result: T_old := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_0 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_0'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_0
[ASSIGN] Result: tmp_U_0 := {}
[SEE] API call 'get_U' ready for actual execution

[ASSIGN] Evaluating: tmp_U_1 := get_U()
[SEE] Mapping base name 'tmp_U_' -> 'tmp_U_1'
[API_CALL] Executing API function: get_U
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_U
  [API_CALL] Executing function...
[GetUFunc] Fetching U...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_U_1
[ASSIGN] Result: tmp_U_1 := {}
[SEE] API call 'get_Roles' ready for actual execution

[ASSIGN] Evaluating: tmp_Roles_0 := get_Roles()
[SEE] Mapping base name 'tmp_Roles_' -> 'tmp_Roles_0'
[API_CALL] Executing API function: get_Roles
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_Roles
  [API_CALL] Executing function...
[GetRolesFunc] Fetching Roles...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_Roles_0
[ASSIGN] Result: tmp_Roles_0 := {}
[SEE] Interruption at statement 8

[ASSUME] Evaluating: AND(in(buyerEmail, dom(tmp_U_0)), =([](tmp_U_1, buyerEmail), buyerPassword), =([](tmp_Roles_0, buyerEmail), BUYER))
  [EVAL] FuncCall: AND with 3 args
    [EVAL] N-ary AND with 3 args
    [EVAL] Arg[0]: in(buyerEmail, dom(tmp_U_0))
  [EVAL] FuncCall: in with 2 args
    [EVAL] Set membership: in
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail0'
    [EVAL] Found in sigma: X0
  [EVAL] FuncCall: dom with 1 args
    [EVAL] Map domain: dom
  [EVAL] Var lookup: tmp_U_0
    [EVAL] Found in sigma: {}
    [EVAL] Map expr evaluated: {}
    [EVAL] Domain has 0 keys
    [EVAL] Set: {}
    [EVAL] Element: X0
    [EVAL] Set: {}
    [EVAL] Element not found in set: false
    [EVAL] Arg[0] result: false
    [EVAL] Arg[1]: =([](tmp_U_1, buyerEmail), buyerPassword)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_U_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail0'
    [EVAL] Found in sigma: X0
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X0
    [EVAL] Key not found in map
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword0'
    [EVAL] Found in sigma: X1
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[1] result: (= []({}, X0) X1)
    [EVAL] Arg[2]: =([](tmp_Roles_0, buyerEmail), BUYER)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_Roles_0
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail0'
    [EVAL] Found in sigma: X0
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X0
    [EVAL] Key not found in map
  [EVAL] Var lookup: BUYER
    [EVAL] Not found in sigma, returning as-is
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
    [EVAL] Arg[2] result: (= []({}, X0) BUYER)
    [EVAL] FuncCall result: AND(...) = false (short-circuit)
[ASSUME] Adding constraint: false
[SEE] API call 'login' with symbolic arguments - interruption point
[SEE] Interruption at statement 9

[ASSIGN] Evaluating: _result0 := login(buyerEmail, buyerPassword)
[SEE] Mapping base name '_result' -> '_result0'
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail0'
    [EVAL] Found in sigma: X0
  [EVAL] Var lookup: buyerPassword
    [EVAL] Resolved base name 'buyerPassword' -> 'buyerPassword0'
    [EVAL] Found in sigma: X1
[API_CALL] login has symbolic arguments - skipping actual execution
  [API_ARG 0] X0 (symbolic: 1)
  [API_ARG 1] X1 (symbolic: 1)
[ASSIGN] Result: _result0 := -1 (symbolic placeholder)
[SEE] API call 'get_T' ready for actual execution

[ASSIGN] Evaluating: tmp_T_1 := get_T()
[SEE] Mapping base name 'tmp_T_' -> 'tmp_T_1'
[API_CALL] Executing API function: get_T
  [API_CALL] Getting function from factory...
[Factory] Creating function: get_T
  [API_CALL] Executing function...
[GetTFunc] Fetching T...
  [API_CALL] Function returned: {}
  [API_CALL] Storing result in variable: tmp_T_1
[ASSIGN] Result: tmp_T_1 := {}

[ASSERT] Evaluating: =([](tmp_T_1, buyerEmail), _result0)
  [EVAL] FuncCall: = with 2 args
    [EVAL] Equality: Eq
  [EVAL] FuncCall: [] with 2 args
    [EVAL] Map access: []
  [EVAL] Var lookup: tmp_T_1
    [EVAL] Found in sigma: {}
  [EVAL] Var lookup: buyerEmail
    [EVAL] Resolved base name 'buyerEmail' -> 'buyerEmail0'
    [EVAL] Found in sigma: X0
    [EVAL] Map expr evaluated: {}
    [EVAL] Key expr evaluated: X0
    [EVAL] Key not found in map
  [EVAL] Var lookup: _result0
    [EVAL] Found in sigma: -1
    [EVAL] Symbolic Eq, returning BinaryOpExpr(EQ)
[ASSERT] Result: (= []({}, X0) -1)
[ASSERT] Adding to path constraints (not fully concrete)

[SEE] Path Constraint: And(true, And(false, (= []({}, X0) -1)))

[UNSAT-CHECK] Path constraint contains FALSE - checking dependencies...

[DEPENDENCY-CHECK] Analyzing sequence for true UNSAT...
[DEPENDENCY-CHECK] ✗ Operation 'loginBuyerOk' requires state 'U' but no prior operation produces it.
[DEPENDENCY-CHECK] Sequence is TRULY UNSAT.

>>> generateCTC: UNSAT DETECTED!
>>> Precondition cannot be satisfied with current database state.
>>> This test sequence requires prerequisite operations.

[RESULT] UNSAT - Test preconditions cannot be satisfied

⊘ [UNSAT] Test 22: Buyer Login Without Registration (Depth=1) UNSAT: Preconditions not satisfiable

